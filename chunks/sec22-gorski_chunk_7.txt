We note that Deputy 5 was previously independently identified by Invetter  via an alternative analysis approach designed to study input validation. Whether or not Deputy 5 is a vulnerability is also subjective. The RPC documentation indicates that it is designed to discard logged data after reaching 1000 files. However, the service is designed to only be accessed by other system services, as evidenced by the documentation and the system permissions checked by the other RPCs (READ_LOGS or DUMP). We include it in our vulnerability list, because it allows third-party applications to perform this manipulation.

# 5 VC2: Data Leaks
FRED identified 5 deputies (6→10 in Table 6) that leak data from security sensitive files to third-party applications. getSharedAccountsAsUser (CVE-2020-0210), like 1→2, affects data in the databases managed by the AccountManagerService. It allows any application running on the current user to get a list of the accounts for that user, an action that is typically restricted to the application that manages the account. Similar to 3→4, getPreviousName and isCredentialsUpdateSuggested both manipulate data in the same databases. Finally, deputies 9→10, return information about security sensitive files, with getTotalBytes returning the size of /data and isStorageLow returning if /data is low on space. /data has ownership system:system.

# 5 VC3: Denial of Service
FRED identified 2 deputies (11→12 in Table 6) that result in a local temporary denial of service. Both of these deputies are unique to the Samsung firmware and exist within the BlockchainTZService. In both cases, the Java RPC entry points (sspInit and sspExit) contain no authorization logic and immediately call JNI methods (nativeSspInit and nativeSspExit). Our native code analysis identified that these JNI methods both access the /dev/ssp device node, which is assigned the user and group system. We were unable to reverse
1536 31st USENIX Security Symposium USENIX Association
Deputy (RPC Service)1. removeSharedAccountAsUser (AccountManagerService)2. renameSharedAccountAsUser (AccountManagerService)3. invalidateAuthToken (AccountManagerService)4. updateCredentials (AccountManagerService)5. add (DropBoxManagerService)6. getSharedAccountsAsUser (AccountManagerService)7. getPreviousName (AccountManagerService)8. isCredentialsUpdateSuggested (AccountManagerService)9. getTotalBytes (StorageStatsService)10. isStorageLow (PackageManagerService)(11. sspInitBlockchainTZService)12. sspExit (BlockchainTZService)
Engineer the logic in the native library. We informed Samsung of the potential vulnerability, and they confirmed that the RPC entry points were indeed missing checks. Samsung indicated that the missing checks allow a third-party application to start or terminate the BlockchainTZService, leading to a local temporary denial of service of the /dev/ssp device node. Samsung assigned two CVEs (CVE-2021-25459 and CVE-2021-25460) and added SELinux policy to ensure only privileged callers can access the BlockchainTZService.

# 5 Non-Vulnerable RPCs
Of the 23 candidate RPCs for AOSP 10, 13 were determined to be non-vulnerable. As outlined in the inspection methodology (Appendix B), these were eliminated for two reasons. (1) The arguments passed in or actions of a RPC caller could not effect modifications made to the files by the RPCs or the data returned by the RPCs from the files. (2) The RPCs were determined to be operating correctly by delegating restricted access to a more sensitive file. The same reasoning was used to eliminate the additional 8 candidate RPCs for the Google device. We also applied the reasoning to the additional 35 candidate RPC entry points for the Samsung device; however, the significant amount of new functionality restricted the manual inspection. We focused efforts on RPCs and files with interesting names, but found many new types of Samsung-specific authorization checks, which prevented improper file re-delegation.

# 6 Limitations
FRED relies on ACMiner  and retains many of its limitations. These limitations include the limitations shared by static analysis tools of Android (e.g., native code, runtime modifications, reflection, dynamic code loading, and Message Handlers), the inability to reason about authorization check ordering, and manually defined input. In addition to the manually defined input required by ACMiner, FRED requires a domain expert to define the file methods used for file path extraction. Additionally, as file access control policy is sometimes defined at runtime, FRED can only detect re-delegation instances for files that exist on the device at the time the file system dump is produced. Finally, as the extracted file paths sometimes depend on runtime generated values (e.g., values from databases, RPC callers, package information, etc.), FRED approximates these values by replacing them with .* in the regular expressions. We found these approximations minimal effect on FRED’s ability to detect re-delegation.

# 7 Related Work
Nearly all modern operating systems rely on privileged deputies to protect security sensitive resources while providing an interface for indirect access by lesser-privileged software. As such, it is no surprise that confused deputy vulnerabilities  are a classic software security problem. Felt et al.  were the first to directly discuss confused deputies in the context of Android, introducing the concept of permission re-delegation (though Davi et al.  had previously).

USENIX Association 31st USENIX Security Symposium 1537
identified privilege escalation attacks). However, these and other works  largely considered permission re-delegation in cases where the deputies are applications. Performing static program analysis of Android applications is significantly easier than the Android framework, and there are many tools  publicly available for doing so.

# 8 Conclusion
ARF  was the first tool to consider permission re-delegation in the Android framework, which contains a highly interconnected collection of system services that frequently call RPC interfaces in one another. This work identified that this high degree of interconnection combined with frequent changes in ambient authority can easily result in confused deputy vulnerabilities. This paper proposed FRED, a static program analysis tool that maps Android’s Java-based RPC entry points to the security-sensitive files they access. By contrasting permission checks by RPC entry points with the corresponding file access control policy, FRED identifies candidate RPC entry points that perform re-delegation. We used FRED to study three devices running Android 10 and identify 10 confused deputy vulnerabilities, three of which were assigned moderate severity CVEs by Google. These results demonstrate the utility of semi-automated approaches to discover subtle flaws in access control enforcement.

# Policy for Security Enhanced Android
In Proceedings of the ACM Asia Conference on Computer and Communications Security (ASIACCS), April 2017.

# A Details of Java Path String Reconstruction
There are various scenarios when the use-def analysis for a PlaceHolder node does not find a constant at the definition. The following describes the special cases handled by FRED.

# String Builders
The Java compiler translates inline string concatenation into calls to the append() method of the StringBuilder and StringBuffer classes. While these classes have many methods, we empirically found that only the append() method occurred during our data flow analysis of file paths. Furthermore, these instances were the result of inline string concatenation, which allows FRED to assume all StringBuilder and StringBuffer objects are only used within the method they are declared. Therefore, FRED handles these classes using an Append node.

# Path Builders
Android provides two similar APIs for file path construction: buildPath() in android.os.Environment, and get() in java.nio.file.Paths. Both methods take a root file path and an array of zero or more file path parts, which are appended to the root path. For example, calling buildPath() with arguments /foo/bar, first/part, and /second/part produces the path /foo/bar/first/part/second/part. Empirically, we found that the target array of file path parts is generated at compile-time from a variable number of string arguments. This observation allows FRED to assume the array is defined and filled immediately before a call to buildPath() and get(). Hence, FRED can determine the values in the array. FRED uses an Append node to append the values, inserting a ‘/’ between each part as needed.

# Arrays and Collections
Extracting values from Arrays, Collections, Iterators, and Maps is a known hard problem for static analysis. Therefore, in most cases FRED represents access to them as Any nodes. Exceptions include the Paths and Environment scenarios.

# Directory Listing
The java.io.File class provides five methods for listing files in the directory. Since the return value is runtime dependent, FRED appends an Any node to the child path of a known directory path.

# Parent Path and File Name
The java.io.File and java.nio.file.Path classes provide methods for getting the parent path or file name of an existing file path. To model this functionality, FRED uses the Parent and Name nodes. These Branch nodes wrap an expression for the existing path, indicating that either the parent path or file name needs to be resolved once the existing path expression is known.

# Environmental Variable and System Properties
Some file paths are constructed from the values of environmental variables and system properties. However, these runtime values can be looked up using a string that exists in the Java source code. Therefore, FRED uses its data flow analysis to determine the lookup string, which can be resolved later. As such, FRED encodes lookup strings into intermediate expressions using EnvVar and SysVar nodes.