T.D2 Exploiting code that processes untrusted content in the OS or apps, e.g., in media libraries . This can be both a local as well as a remote attack surface, depending on where input data is taken from.

# 3 THE ANDROID PLATFORM SECURITY MODEL
The basic security model described in this section has informed the design of Android and has been refined but not fundamentally changed. Given the ecosystem context and threat model explained above, the Android security model balances security and privacy requirements of users with security requirements of applications and the platform itself. The threat model described above includes threats to all stakeholders, and the security model and its enforcement by the Android platform aims to address all of them. The Android platform security model is informally defined by five rules:
© Multi-party consent. No action should be executed unless all main parties agree—in the standard case, these are user, platform, and developer (implicitly representing stakeholders such as content producers and service providers). Any one party can veto the action. This multi-party consent spans the traditional two dimensions of subjects (users and application processes) vs. objects (files, network sockets and IPC interfaces, memory regions, virtual data providers, etc.) that underlie most security models (e.g., Reference ). Any party (or more generally actor) that creates a data item is implicitly granted control over this particular instance of data representation. Focusing on (regular and pseudo) files as the main category of objects to protect, the default control over these files depends on their location and which party created them:
- Data in shared storage are controlled by users.

- Data in private app directories and app virtual address space are controlled by apps.

- Data in special system locations are controlled by the platform (e.g., list of granted permissions).

Data in Runtime Memory (RAM) is by default controlled by the respective platform or app process. However, it is important to point out that, under multi-party consent, even if one party primarily controls a data item, it may only act on it if the other involved parties consent. Control over data also does not imply ownership (which is a legal concept rather than a technical one and therefore outside the scope of an OS security model).

While this principle has long been the default for filesystem access control (Discretionary Access Control (DAC), cf. Section 4 below), we consider it a global model rule and exceptions such as device backup (cf. Section 5) can be argued about within the scope of the security model. There are other corner cases in which only a subset of all parties may need to consent (for actions in which the user only uses platform/OS services without involvement of additional apps) or an additional party may be introduced (e.g., on devices or profiles controlled by a mobile device management, this policy is also considered as a party for consenting to an action).

Public information and resources are out of scope of this access control and available to all parties; particularly all static code and data contained in the AOSP system image and apps (mostly in the Android Package (APK) format) is considered to be public (cf. Kerckhoff’s principle)—if an actor publishes the code, this is interpreted as implicit consent to access. However, it is generally accepted that such public code and data is read-only to all parties and its integrity needs to be protected, which is explicitly in scope of the security measures.

© Open ecosystem access. Both users and developers are part of an open ecosystem that is not limited to a single application store. Central vetting of developers or registration of users is not required.

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

# The Android Platform Security Model
required. This aspect has an important implication for the security model: Generic app-to-app interaction is explicitly supported. Instead of creating specific platform APIs for every conceivable workflow, app developers are free to define their own APIs they offer to other apps.

© Security is a compatibility requirement. The security model is part of the Android specification, which is defined in the Compatibility Definition Document (CDD)  and enforced by the Compatibility (CTS), Vendor, and other test suites. Devices that do not conform to CDD and do not pass CTS are not Android. Within the scope of this article, we define rooting as modifying the system to allow starting processes that are not subject to sandboxing and isolation. Such rooting, both intentional and malicious, is a specific example of a non-compliant change that violates CDD. As such, only CDD-compliant devices are considered. While many devices support unlocking their bootloader and flashing modified firmware, such modifications may be considered incompatible under CDD if security assurances do not hold. Verified boot and hardware key attestation can be used to validate if currently running firmware is in a known-good state and in turn may influence consent decisions by users and developers.

© Factory reset restores the device to a safe state. In the event of security model bypass leading to a persistent compromise, a factory reset, which wipes/reformats the writable data partitions, returns a device to a state that depends only on integrity protected partitions. In other words, system software does not need to be re-installed, but wiping the data partition(s) will return a device to its default state. Note that the general expectation is that the read-only device software may have been updated since originally taking it out of the box, which is intentionally not downgraded by factory reset. Therefore, more specifically, factory reset returns an Android device to a state that only depends on system code that is covered by Verified Boot but does not depend on writable data partitions.

© Applications are security principals. The main difference to traditional operating systems that run apps in the context of the logged-in user account is that Android apps are not considered to be fully authorized agents for user actions. In the traditional model typically implemented by server and desktop OS, there is often no need to even exploit the security boundary, because running malicious code with the full permissions of the main user is sufficient for abuse. Examples are many, including file encrypting ransomware (which does not violate the OS security model if it simply re-writes all the files the current user account has access to) and private data leakage (e.g., browser login tokens, history or other tracking data, cryptocurrency wallet keys, etc.).

Summary. Even though, at first glance, the Android security model grants less power to users compared to traditional operating systems that do not impose a multi-party consent model, there is an immediate benefit to end users: If one app cannot act with full user privileges, then the user cannot be tricked into letting it access data controlled by other apps. In other words, requiring application developer consent—enforced by the platform—helps avoid user confusion attacks and therefore better protects private data.

The Android platform security model does not currently have a simple, consistent representation in formal notation, because these rules evolved from practical experience instead of a top-down theoretical design; the meaning of the term “model” is consequently slightly different from how conventional security models use it. Balancing the different requirements of a complex.

Google Nexus and Pixel devices as well as many others support the standard fastboot oem unlock command to allow flashing any firmware images to actively support developers and power users. However, executing this unlocking workflow will forcibly factory reset the device (wiping all data) to make sure that security guarantees are not retroactively violated for data on the device.

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

ecosystem is a large scale engineering problem that requires layers of abstraction. Therefore, we have to combine multiple different security controls (such as memory isolation, filesystem DAC/MAC, biometric user authentication, or network traffic encryption) that operate under their own respective models and are not necessarily consistent with each other (see, e.g., Reference  for interactions between only the DAC and MAC policies). The five rules are, at the time of this writing, the simplest expression of how these different security controls combine at the meta level.

# 4 IMPLEMENTATION
Android’s security measures implement the security model and are designed to address the threats outlined above. In this section we describe security measures and indicate which threats they mitigate, taking into account the architectural security principles of “defense in depth” and “safe by design.”
# Defense in depth.

A robust security system is not sufficient if the acceptable behavior of the operating system allows an attacker to accomplish all of their goals without bypassing the security model (e.g., ransomware encrypting all files it has access to under the access control model). Specifically, violating any of the above principles should require such bypassing of controls on-device (in contrast to relying on off-device verification, e.g., at build time).