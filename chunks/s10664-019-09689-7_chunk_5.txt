To answer RQ4 we need information not available neither in the CVE Details nor in the
NVD sites. In particular, we need to identify the commits in which each vulnerability has
been introduced and fixed. As for the commit fixing each vulnerability, we mined it from
# Empirical Software Engineering (2019) 24:2056–2101
The vulnerability-fixing commit is not available for all the 1,235 Android-related vulnerabilities we collected, because (i) some vulnerabilities were reported before the first available bulletin, and (ii) the fixing commit (see e.g., http://tinyurl.com/hrod7q9) is only available for the subset of vulnerabilities fixed in the Android open source project (e.g., it is not available for vulnerabilities related to third-party components such as drivers). Note also that, although the CVE reports include in some cases the bug id, the ids are for the internal bug trackers of Google and hardware manufactures, which are not publicly available. For these reasons, the analysis for RQ 4 is limited to a set of 331 vulnerabilities for which we identified the fixing commit.

Once identified the fixing commit, we used the SZZ algorithm  to identify the commit introducing the vulnerability. The algorithm relies on the annotation/blame feature of versioning systems. Given a vulnerability-fixing commit VFk (where k identifies the vulnerability), the approach works as follows:
1. For each file fi, involved in VFk and fixed in its revision rel-fixi,k, we extract the file revision just before the vulnerability fixing (rel-fixk − 1).

2. Starting from the revision rel-fixk − 1, for each source code line in fi changed to fix the vulnerability k, the blame feature of Git is used to identify the file revision where the last change to that line occurred. In doing that, blank lines are identified and ignored. This produces, for each file fi, a set of ni,k fix-inducing revisions rel-vulnerabilityi,j,k, j = 1 . . . ni,k.

Since more than one commit can be indicated by the SZZ algorithm as responsible for inducing the vulnerability-fix, there are time vulnerability ranges defined by lower (minimum survivability) and upper bounds (maximum survivability). Therefore, we answer RQ4 by following a meta analysis-based procedure (Hedges and Olkin 1985; Cumming 2011): the minimum and the maximum survivability of the vulnerabilities (i.e., number of days between the vulnerability introduction and fixing) are plotted using forest plots with confidence intervals, and a central tendency measure of the survivability is computed by using the random effects model  (based on the recommendations by Cumming 2011). The minimum survivability is the one observed when considering the most recent commit identified by the SZZ algorithm as the one that induced the vulnerability-fix. Vice versa, the maximum survivability is observed when considering the least recent commit identified by the SZZ algorithm as the one that induced the vulnerability-fix. The forest plots are depicted by considering a 95% confidence interval.

We also verified whether vulnerabilities having different severity levels have different survivability. For this analysis, we used the severity classification available in CVSS 2 (low, medium, high). In particular, we compared the distributions of the survivability of the different categories of vulnerabilities (e.g., low vs. medium) via (i) forest plots, and (ii) statistical tests. For the latter we exploited the Mann-Whitney test  with results intended as statistically significant at α = 0. To control the impact of multiple pairwise comparisons (e.g., the survivability of the vulnerabilities having low severity is compared against the survivability of those having medium and high severity), we adjust p-values using the Holm’s correction . We also estimate the magnitude of the differences by using the Cliff’s Delta (d), a non-parametric effect size measure (Grissom and Kim 2005) for ordinal data. We follow well-established guidelines to interpret the effect.

Meta-analysis is a statistical inference technique aimed at consolidating results from more than one study or experiment.

Empirical Software Engineering (2019) 24:2056–2101 2069
size: negligible for |d| &lt; 0, small for 0 ≤ |d| &lt; 0, medium for 0 ≤ |d| &lt; 0, and large for |d| ≥ 0 (Grissom and Kim 2005). Finally, to ease the interpretation of the achieved results, we also compare the survivability of the vulnerabilities with that of other types of bugs, unrelated to security issues, and extracted from the same repositories in which the vulnerabilities were fixed. In particular, for each vulnerability-fixing commit, we randomly selected, from the same repository in which the vulnerability was fixed, three bug-fixing commits having their commit note matching the regular expression fix(es)(ed) bug(s). Then, knowing the possible imprecisions introduced by this procedure, the first author manually analyzed all candidate bug-fixing commits discarding the ones that were related in some way to security issues or that were not bug-fixing activities. This left us with 385 valid bug-fixing commits not related to security vulnerabilities. From this set, we randomly selected 331 of them, to compare the survivability of the bugs they fix to that of the vulnerabilities fixed in the 331 vulnerability-fixing commits. Also in this case, we compute the minimum and the maximum survivability using the same procedure previously described, and we statistically compare the survivability of vulnerabilities with that of other types of bugs by using the Mann-Whitney test and the Cliff’s Delta.

# 4 Results
This section discusses the quantitative results achieved in our study according to the four formulated RQs. Also, we complement quantitative data with qualitative examples, by referring to specific vulnerabilities identified with their CVE id (e.g., CVE-2016-2439). The reader can access the page detailing a vulnerability by visiting “https://web.nvd.nist.gov/view/vuln/detail?vulnId=” followed by the CVE id. We provide in our online appendix (Mazuera-Rozo et al. 2017) the complete list of vulnerabilities considered in our study, including their categorization by subsystem, component, and vulnerability type. Also, we created visualizations aimed at helping the reader when browsing the vulnerabilities list (Mazuera-Rozo et al. 2017).

# 4 RQ 1: Which Types of Security Vulnerabilities Affect the Android OS?
Figures 3 and 4 show the taxonomy reporting the vulnerability types we found in the 1,235 manually inspected vulnerabilities. The vulnerability types are depicted as several hierarchies (each color represents a hierarchy) by following the categorization provided in the CWE dictionary (MITRE 2017p). The hierarchies have been split into two figures for the sake of readability. Note that the two figures only report the classification for 1,066 vulnerabilities. This is due to the fact that we were not able to infer the type of 169 vulnerabilities during our manual analysis. Also, the root categories (i.e., the ones reporting the overall number of vulnerabilities in each hierarchy) have been defined by us to allow an easier navigation of the different vulnerability types. Finally, it is worth noting that changes in the taxonomy are present as compared to the work by Linares-Vásquez et al. (2017) that this paper extends. This is due to (i) new categories identified as a result of the larger set of vulnerabilities analyzed, and (ii) the fact that we updated the previous classification in Linares-Vásquez et al. (2017) to the newest version of the CWE dictionary (2 as compared to the 2 used in Linares-Vásquez et al. 2017).

The vulnerabilities most frequently affecting Android devices are those related to permissions, privileges, and access control with 243 instances (23%). They include, for example, weaknesses due to improper access control and to permission issues, like the
# Empirical Software Engineering (2019) 24:2056–2101
reliance on cookies without validation and integrity checking vulnerability discussed in CVE-2008-7298:
The Android browser cannot properly restrict modifications to cookies established in HTTPS sessions, which allows man-in-the-middle attackers to overwrite or delete arbitrary cookies via a Set-Cookie header in an HTTP response [...]
Vulnerabilities related to weaknesses that affect the memory, are represented in our taxonomy with 209 instances (20%). These weaknesses include all vulnerabilities related to the improper restriction of operations in the bounds of memory buffer, like out-of-bounds
Empirical Software Engineering (2019) 24:2056–2101 2071
read/write. One vulnerability falling in this category is CVE-2016-2439, described as follows:
Buffer overflow in btif dm.c in Bluetooth [...] allows attackers to execute arbitrary code via a long PIN value
The vulnerability was fixed in commit 9b534de, modifying the conditional statement checking a PIN-related error from if (pin code == NULL) to if (pin code == NULL || pin len > PIN CODE LEN). The rationale behind the change is also documented by the developer in the commit message: If a malicious client sets a pin that was too long it would overflow the pin code memory.