Following the LibRadar approach, we first extract packages for the given apps. Here let p be an extracted package. Next, for each p, we derive n(p), which is the total number of API calls in p, and m(p), which is the number of distinct API calls used in p. Finally, for a given package p, we compute its fingerprint F(p): F(p) = h(n(p), m(p)), where h() is a lightweight hash function. After processing all packages found in all apps, packages with the same fingerprint are clustered. We eliminate a cluster if it has only one package.

From the set of all package names found in a cluster, we choose the most frequently used name as the representative package name (RPN). The RPN offers a human-interpretable representation of a cluster while removing the noise introduced by developers who modify the names of packages. While extracting RPNs is common with LibRadar, the method we use to extract RPNs may not be identical because not all details are disclosed in Ref.  and in its open-source tool.

We also apply deobfuscation to package names by heuristically identifying and removing obfuscated package names (e.g., zzz.a.b.c) before choosing the RPN. For deobfuscation, we first extract words that are separated with dots from a given package name. If at least one of the words extracted is a single letter, we identify the package name as obfuscated. For example, if the package name zzz.a.b.c is given, we extract “zzz,” “a,” “b,” and “c” as words. Since the package name included three single-letter components, we detect it as obfuscated and eliminate it from the list of RPNs. Note that this simple rule may falsely eliminate legitimate package names that include a single letter. However, we found that such cases were not common in our datasets.

The extracted RPNs are useful for understanding the provenance of libraries. We use the RPNs to classify detected libraries into categories.

# 3 Library Classification
We aim to classify detected software libraries. Note that existing library detection schemes , ,  have not considered such classification. We define three library categories, i.e., official, private, and third-party, based on how they are distributed. This distinction is particularly important in relation to suggestions for managing libraries in the presence of vulnerabilities. We use RPNs and the number of distinct certificates per library for the classification task.

The descriptions of the three categories of libraries and the ways to detect them are summarized below:
Android SDK Manager , e.g., the Android Support Library. Detected if its RPN matches one of the package names provided by the SDK Manager, e.g., android.support. Private Libraries are those developed by a particular developer intended only to be used privately in apps developed by that developer, e.g., special logging/debugging libraries. Detected if all apps using the library are signed with a single signature. Third-Party Libraries are those distributed freely or commercially to be used by any developers, e.g., an advertisement library. Detected if it is not classified as an official library or a private library. We also listed examples of RPNs for each categories in Table 1.

Next, we classify third-party libraries into sub-categories that describe their functionality or purpose. We considered 8 sub-categories: Ad (Advertisement), Analyt (Mobile analytics), Build (App building framework), Cloud (Cloud-based app building), Dev (Development aid), Game (Game engines), Pymt (Payment), and SNS (Social networks). We also listed examples of RPNs for each sub-categories in Table 2. Our task is to assign a detected library/RPN to one of the categories.

First, we compile a list of package names that are associated with popular third-party libraries listed in websites such as . Let the compiled list be “list A.” Second, for RPNs that are not detected in list A, we manually inspect the top package names used for at least 100 distinct apps. We summarize the results as “list B.” Finally, for libraries not covered by lists A and B, we apply the following prefix-matching heuristics. For a given unclassified RPN C, if there is a classified RPN D that matches a prefix of C, then C is assigned the same category as D.

Finally, using the procedures described above, we construct a fingerprint DB. Each record consists of the following three-tuple, i.e., fingerprint, deobfuscated RPN, and class/category. The fingerprint DB is employed as follows.

# WATANABE et al.: STUDY ON THE VULNERABILITIES OF FREE AND PAID MOBILE APPS
We extract packages from a given APK file and compute a fingerprint for each package. By querying the obtained fingerprints in the DB, we can obtain corresponding deobfuscated RPNs and categories. Note that an APK file may contain code from multiple libraries in the same category, e.g., it is quite common that an app uses more than two distinct ad libraries.

# 3 Dead Code Checker
Since some detected vulnerabilities may reside in dead code, we must distinguish such cases from legitimate cases. Thus, we built a dead code checker that can determine whether a given class is reachable in a generated function call tree.

getf (Line 5) is a function that returns a list of methods that instantiate/call a class. refFunctions (line 21) is a function that returns a list of functions that reference the given function. As an implementation of refFunctions, we adopted Androguard , which we modified for our purpose. If a function of a class, say Foo, implements a function of the Android SDK class whose code is not included in the APK, we cannot trace the path from the function in some cases. To deal with such cases, we made a heuristic to trace the function that calls the init-method of class Foo (lines 16–19). We note that the heuristics can handle several cases such as async tasks, OS message handlers, or callbacks from framework APIs such as onClick(). A method is callable if it is overridden in a subclass or an implementation of the Android SDK and an instance of the class is created. Async tasks, the OS message handler, or other callbacks implement their function by overriding the methods of the Android SDK subclass. Therefore, this should be handled by heuristics. Finally, if there are no paths for which a given class can reach ORIGIN, the algorithm concludes that the class is a dead code.

Note that our approach has an intrinsic limitation associated with static code analysis. This will be discussed in the next subsection.

# 3 Threats to Validity
# 3 Accuracy of Results
To validate the accuracy of the results generated by the Droid-L system, we inspected the detected libraries manually. We randomly sampled 25 apps from each of four datasets, i.e., free top, free random, paid top, and paid random apps. We summarize the dataset in Sect. 5. These 100 apps contained 11,633 packages, which were grouped into 7,620 distinct clusters, and 85% of the clusters (6,460) were detected as libraries using the fingerprint DB. The remaining packages (1,160) were not detected as libraries for the following reasons. First, the fingerprints of those libraries have been changed due to software updates. Second, some libraries use code optimization tools, such as ProGuard, which could also change fingerprints. We then inspected the 6,460 packages manually. First, we disassembled/decompiled the APK files. Then, we looked at the detected packages and inspected the classes/methods within the packages. We also searched the origins of the package source code using Internet search engines. We found that 6,308 packages (97%) were classified correctly. This result clearly validates the accuracy of the Droid-L system.

# 3 Dead Code Checker
Static analysis, which is the basis of our approach, has the
# IEICE TRANS. INF. & SYST., VOL.E103–D, NO FEBRUARY 2020
280
following two limitations. First, although the algorithm can exclude dead code, we cannot precisely ensure that remaining code is actually used in the app. Second, static code analysis cannot dynamically track assigned program code at run time, such as reflection. These limitations are common among static analysis approaches.

# 4. Droid-V: Vulnerability Checker
Our next goal is to identify vulnerabilities in detected libraries. To this end, we built a vulnerability checker, i.e., Droid-V, which uses various vulnerability scanners and compiles their results for further analysis. Taking an app as input, Droid-V detects the presence of vulnerabilities and identifies where in the code the vulnerabilities reside. This information can be combined with the results of Droid-L to identify the responsible libraries. In this section, we list and describe the vulnerabilities we targeted. Some of the limitations of our system are also discussed.

# 4 Vulnerabilities
As summarized in Sect. 8, common and influential vulnerabilities found in recent mobile platforms can be broadly classified into four categories, i.e., information disclosure, SSL/TLS and cryptography, inter-component communication (ICC), and WebView. While the first two are underlying for all softwares, not just mobile apps and devices, the last two are mobile app/device-specific issues.