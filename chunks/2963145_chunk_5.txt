# 4. Permission Decomposition
Coarse-grained permissions can be decomposed into multiple fine-grained permissions to help enforce the PoLP. For example, INTERNET permission can be deconstructed into domain-based permission like INTERNET(google.com), which is already the practice of Chrome Apps and Extensions [Google Inc. 2016b]. Constroid [Schreckling et al. 2012] modifies Android middleware to provide finer-grained data-centric access control policies on top of the Android permission framework. Unlike implementations that require framework or system modification, Aurasium [Xu et al. 2012] and Dr. Android & Mr. Hide [Jeon et al. 2012] perform permission decomposition using app repackaging. Aurasium attaches user-level sandboxing and monitoring code to the repackaged app so that the finer-grained policy can be enforced. For example, a user can define a network policy to allow or disallow the connection to a specific IP address. Similarly, Dr. Android & Mr. Hide replaces the original permission system with Mr. Hide, an Android service that provides finer-grained permissions, by app repackaging. In case if an application owns the INTERNET permission, Mr. Hide introduces a new permission InternetURL(d), which only grants access to the domain d.

# 4. Assignment Decomposition
Recall that in the current permission model, once an app has a permission, all of its components and libraries share the same privilege. This problem is particularly obvious in the case of using advertisement libraries. Since advertisement libraries are usually developed by third parties, it may be risky to allow a third-party library to share the same set of permissions with the app. Tools like Brahmastra [Bhoraskar et al. 2014] have found various cases of privacy violations in third-party libraries.

To address this problem, several works [Paul Pearce et al. 2012; Roesner and Kohno 2013; Shekhar et al. 2012] propose assigning separate permissions to the in-app advertisement component. Compac [Wang et al. 2014b] further generalizes the idea by proposing a component-level permission assignment approach, such that each in-app component only gets the minimum set of permissions needed for preserving the app’s functionalities. FlexDroid [Seo et al. 2016] achieves in-app privilege separation and
ACM Computing Surveys, Vol. 49, No. 2, Article 38, Publication date: August 2016.

# Toward Engineering a Secure Android Ecosystem: A Survey of Existing Techniques
# 4. ICC Tracing
ICC tracing aims to solve the transitivity issue. Solutions [Bugiel et al. 2011, 2012; Dietz et al. 2012; Felt et al. 2011c] in this direction usually monitor both sensitive API calls and ICC. By keeping track of the communication channels between apps, an API call is blocked if any app in the call chain lacks the required permission to access it. This is used to effectively tamper permission escalation attacks including the confused deputy attack and the collusion attack.

Moreover, Saint [Ongtang et al. 2009] demonstrates that it is also possible to reinforce the security check by allowing developers to define policies to protect exposed app interfaces, for example, all conditions in the policy must be satisfied before another app can access the interface.

# 4. Decentralized Information Flow Control
While ICC tracing only checks the permission before sensitive APIs are called, Aquifer [Nadkarni 2012] and Jia et al.  aim to enforce information flow integrity even after data leaves the app. Both works require developers to tag policies on the data that flows into another app, and instrument the system to enforce the policies. Similarly, Maxoid [Xu and Witchel 2015] modifies the Android system to enforce information flow policies between apps, but it focuses on secrecy and integrity for both the invoking app and the invoked app.

# 4. Open Problems
Despite the extensive research on improving the existing permission model, few solutions have been adopted in practice. We believe the following open issues contribute to the low adoption rate:
# 4. Granularity v.s. Intuitiveness
Although finer granularity helps to enforce the PoLP, the permission requester and granter might be over-burdened by the higher complexity. As a result, the more types of permissions are introduced, the less intuitive the permission model becomes. User-driven access control [Roesner et al. 2012] provides a new direction for permission model design which might fundamentally remove this trade-off.

# 4. Permission Granting Authority
Another unaddressed problem in the permission granting mechanism is whether users have the capability to make the right decisions. To deal with this problem, one possible solution is to delegate permission granting to the system or third-parties with expertise; while at the same time, the flexibility can be kept for expert users to adjust permissions, much like the proposed work for a desktop environment [Kushman and Katabi 2010].

# 5. SIDE CHANNELS AND COVERT CHANNELS
All operating systems are subject to side-channel attacks as well as information leakage via covert channels, and Android is no exception. By legitimately observing the behavior patterns of shared resources, an attacker is able to infer sensitive information (side-channel) or use these patterns as a communication channel with another app (covert channel), allowing him/her to bypass both the low-level application sandbox and high-level permission model. Table IV summarizes the existing side-channel attacks and mitigations along with their effectiveness and adoptability for Android.

# 5. Shared Hardware Resources
While sensors in smartphones enable valuable interactions, they can also be abused to infer inputs such as passwords [Al-Haiqi et al. 2013; Aviv et al. 2013; Deshotels 2014;]
ACM Computing Surveys, Vol. 49, No. 2, Article 38, Publication date: August 2016.

# 5. Side-Channel Attacks
# 5. Summary of Side-Channel Attacks
Miluzzo et al. 2012; Schlegel et al. 2011; Xu et al. 2009. Notably, the motion sensor that is mounted beneath the screen, is capable of sniffing users’ interactions with the device by analyzing micro changes in device motion and positioning. For example, TapPrints [Miluzzo et al. 2012] can infer the location of taps on touch screens and subsequently recover English characters. An attacker can use the accelerometer to track the tilt of a mobile device, then he/she can recover PIN code of the lockscreen [Aviv et al. 2013]. Soundcomber [Schlegel et al. 2011] selectively records conversations that carry sensitive information including credit card numbers, and then extracts and transmits the information to another application via either an overt or covert channel. A general problem in the research of hardware-based side channels is the lack of end-to-end practical attack cases. For example, gaining knowledge about the victims’ PIN code or lockscreen patterns are not likely to benefit attackers if they lack physical access to victims’ devices. An even harder problem is how to infiltrate the phone first to mount the appropriate sniffing malware and send out the recorded information. Corresponding mitigations are mainly to limit the sensor usages. For example, mitigations in Aviv et al. , Miluzzo et al. , and Schlegel et al.  rely on the Android’s permission control scheme to limit the use of motion sensors and the microphone.

# 5. Shared Software Resources
Because certain software resources are shared across processes, activity signatures such as CPU, memory, or network usage patterns can be retrieved from the accessible /proc file system, which can be further analyzed to infer ongoing activities in other processes. For example, Zhou et al.  is able to infer the identity, health information, and location of an Android user by monitoring network usage via /proc. Also, Chen et al. [2014b] is able to infer changes of UI state in another app based on the variations of shared memory size in /proc, and inject a fake login page seamlessly to steal login credentials. Applying access control on /proc filesystem could effectively mitigate this side-channel. However, given that Android is an open mobile system designed to facilitate resource sharing, more complete side-channel mitigations are pressing.

# 5. Covert Channel
As shown in Gasior and Yang , seemingly normal operational variances can be abused to stealthily transmit data between apps, which effectively bypasses the permission model and kernel sandbox. Known covert channels take advantage of vibration, screen brightness, volume settings and file lock statuses to transmit bits to a listening application. Also, Marforio et al.  shows a number of other cover channels in Android, such as intent type, UNIX socket discovery, threads enumeration, automatic intents, and free disk space. The method in Deshotels  even leverages the audio channel to transmit ultrasonic sound which can hardly be noticed by the human ear.

ACM Computing Surveys, Vol. 49, No. 2, Article 38, Publication date: August 2016.