# 4 Access Control
Android uses three distinct permission mechanisms to perform access control:
- DAC: Processes may grant or deny access to resources that they own by modifying permissions on the object (e.g., granting world read access) or by passing a handle to the object over IPC. On Android this is implemented using UNIX-style permissions that are enforced by the kernel and URI permission grants. Processes running as the root user often have broad authority to override UNIX permissions (subject to MAC permissions—see below). URI permission grants provide the core mechanism for app-to-app interaction allowing an app to grant selective access to pieces of data it controls.

- MAC: The system has a security policy that dictates what actions are allowed. Only actions explicitly granted by policy are allowed. On Android this is implemented using SELinux  and primarily enforced by the kernel. Android makes extensive use of SELinux to protect system components and assert security model requirements during compatibility testing.

- Android permissions gate access to sensitive data and services. Enforcement is primarily done in userspace by the data/service provider (with notable exceptions such as INTERNET). Permissions are defined statically in an app’s AndroidManifest.xml , though not all permissions requested may be granted. Android 6 brought a major change by no longer guaranteeing that all requested permissions are granted when an application is installed. This was a direct result of the realization that users were not sufficiently equipped to make such a decision at installation time (cf. References ).

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

# The Android Platform Security Model
The second major change in Android permissions was introduced with Android 10 in the form of non-binary, context dependent permissions: in addition to Allow and Deny, some permissions (particularly location, and starting with Android 11 others like camera and microphone) can now be set to Allow only while using the app. This third state only grants the permission when an app is in the foreground, i.e., when it either has a visible activity or runs a foreground service with permanent notification . Android 11 extended this direction with one-time permissions that form another variant in the context dependent state between unconditional allow and deny.

At a high level Android permissions fall into one of five classes in increasing order of severity, whose availability is defined by their protectionLevel attribute  with two parts (the protection level itself and a number of optional flags):
1. Audit-only permissions: These are install time permissions with protection level normal that do not pose much privacy or security risk and are granted automatically at install time. They are primarily used for auditability of app behavior.

2. Runtime permissions: These are permissions with protection level dangerous and apps must both declare them in their manifest as well as request users grant them during use. These permissions are guarding commonly used sensitive user data, and depending on how critical they are for the current functioning of an application, different strategies for requesting them are recommended . While runtime permissions are fairly fine-grained to support auditing and enforcement in-depth, they are grouped into logical permissions using the permissionGroup attribute. When requesting runtime permissions, the group appears as a single permission to avoid over-prompting.

3. Special Access permissions: For permissions that expose more or are higher risk than runtime permissions there exists a special class of permissions with much higher granting friction that the application cannot show a runtime prompt for. Specific examples are device admin, notification listeners, or installing packages. In order for a user to allow an application to use a special access permission, the user must go to settings and manually grant the permission to the application.

4. Privileged permissions: These permissions are for pre-installed applications only and allow privileged actions such as modifying secure settings or carrier billing. They typically cannot be granted by users during runtime but OEMs grant them by whitelisting the privileged permissions for individual apps  in the system image. Privileged protection level permissions are usually coupled with the signature level.

5. Signature permissions: These permissions with protection level signature are only available to components signed with the same key as the (platform or application) component that declares the permission—which is the platform signing key for platform permissions. They are intended to guard internal or highly privileged actions, e.g., configuring the network interfaces and are granted at install time if the application is allowed to use them.

Additionally, there are a number of protection flags that modify the grantability of permissions. For example, the BLUETOOTH_PRIVILEGED permission has a protectionLevel of signature|privileged, with the privileged flag allowing privileged applications to be granted the permission (even if they are not signed with the platform key).

Each of the three permission mechanisms roughly aligns with how one of the three parties of the multi-party grant consent (rule ©). The platform utilizes MAC, apps use DAC, and users consent1.

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

by granting Android permissions. Note that permissions are not intended to be a mechanism for obtaining consent in the legal sense but a technical measure to enforce auditability and control. It is up to the app developer processing personal user data to meet applicable legal requirements.

# 4 Application Sandbox
Android’s original DAC application sandbox separated apps from each other and the system by providing each application with a unique UNIX user ID (UID) and a directory owned by the app. This approach was quite different from the traditional desktop approach of running applications using the UID of the physical user. The unique per-app UID simplifies permission checking and eliminates per-process ID checks, which are often prone to race conditions. Permissions granted to an app are stored in a centralized location (/data/system/packages.xml) to be queried by other services. For example, when an app requests location from the location service, the location service queries the permissions service to see if the requesting UID has been granted the location permission.

Starting with Android 4, UIDs are also used for separating multiple physical device users. As the Linux kernel only supports a single numeric range for UID values, device users are separated through a larger offset (AID_USER_OFFSET=100000 as defined in AOSP source15) and apps installed for each user are assigned UIDs in a defined range (from AID_APP_START=10000 to AID_APP_END=19999) relative to the device user offset. This combination is referred to as the Android ID (AID).

The UID sandbox had a number of shortcomings. Processes running as root were essentially un-sandboxed and possessed extensive power to manipulate the system, apps, and private app data. Likewise, processes running as the system UID were exempt from Android permission checks and permitted to perform many privileged operations. Use of DAC meant that apps and system processes could override safe defaults and were more susceptible to dangerous behavior, such as sym-link following or leaking files/data across security boundaries via IPC or fork/exec. Additionally, DAC mechanisms can only apply to files on file systems that support access controls lists (respectively simple UNIX access bits). The main implication is that the FAT family of file systems, which is still commonly used on extended storage such as (micro-) SD cards or media connected through USB, does not directly support applying DAC. On Android, each app has a well-known directory on external storage devices, where the package name of the app is included into the path (e.g., /sdcard/Android/data/com.example). Since the OS already maintains a mapping from package name to UID, it can assign UID ownership to all files in these well-known directories, effectively creating a DAC on a filesystem that does not natively support it. From Android 4 to Android 7.x, this mapping was implemented through FUSE, while Android 8 and later implement an in-kernel sdcardfs for better performance. Both are equivalent in maintaining the mapping of app UIDs to implement effective DAC. Android 10 introduced scoped storage, which limits app access to its own external directory path as well as media files that itself created in the shared media store.

Despite its deficiencies, the UID sandbox laid the groundwork and is still the primary enforcement mechanism that separates apps from each other. It has proven to be a solid foundation upon which to add additional sandbox restrictions. These shortcomings have been mitigated in a number of ways over subsequent releases, especially through the addition of MAC policies with SElinux in enforcing mode starting with Android 5, but also including many other mechanisms such as runtime permissions and attack surface reduction (cf. Table 1). In addition to SELinux, seccomp filters complement the MAC policy on a different level of syscall granularity. While the Chrome app is currently the main user of fine-grained seccomp filters, others can also use them to internally minimize attack surface for their components.

15 See system/core/include/private/android_filesystem_config.h in the AOSP source tree.

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.