To perform ReMaCi attacks, the attacker needs to inject malicious code that leaks private data such as e-mail or phone numbers to the compromised server after identifying sensitive data flows in applications. Then, the attacker repackages the application and redistributes it. To this end, the attacker first needs to perform dynamic analysis and/or a static analysis to identify sensitive data flows. Once the attacker identified sensitive data flows, it is straightforward to find the exact locations of code that handles the sensitive data. We note that, albeit applications are heavily obfuscated, the attacker can accomplish this step by using a dynamic analyzer that can monitors instructions executed , . Therefore, ReMaCi attacks can be applied to any application regardless of the protection mechanisms applied to them. Once the flow of sensitive data was revealed from a dynamic analyzer and/or static analyzer, an attacker injects malicious code that leaks the sensitive data. Finally, the tampered application is repackaged with the attacker’s private key and re-distributed to a third-party app store. Later, if potential victims download and use the application, their personal information such as a phone number will be leaked to the attacker.

In Section VII-A, we demonstrate the severity of the threat by showing real-world applications downloaded from Google Play Store are really vulnerable to the ReMaCi attack.

# IV. AMPDROID
We demonstrated that the exposure of sensitive data flows can lead to sensitive data leakages in Section III. Therefore, the flow of sensitive data must be hidden to attackers for protecting users’ private information. To this end, we segmentalize our goal as follows and propose an automated multi-layered bytecode generation system for preventing sensitive information leaks.

- G1: Identifying Sensitive Data flows.

To protect sensitive data flows in applications, we first should identify them. Such data flows can be expressed by using the following three components. The entry method is the start method fetching sensitive data from storage or the network into a process (called a source). Next, the end method sends data out of the process (called a sink). Furthermore, execution paths between the start method and end method (called tainted paths). For the rest of this paper, we call the above three components a stem. Our first goal is to find the stems in applications. There can be numerous stems in an application. The more stems we find, the more we can prevent data leakage by hiding them. Also, we should decide which stem will be used to hide among stems (called a selected stem). We demonstrate how we identify and select stems to hide them in Section V-A.

- G2: Generating Multi-Layered Bytecode.

The next goal is to generate bytecodes of an application into multi-layered bytecode. The original dex file will be divided into 3 dex files which are the sensitive code Dex (called SC dex), all of the other user-defined classes Dex (called UDC dex).

# G. Jeon et al.: Automated Multi-Layered Bytecode Generation for Preventing Sensitive Information Leaks
and classes.dex containing library classes such as java, android, and kotlin. By dividing the original dex file, we can manage them separately. Specifically, if we can hide the SC dex files securely, attackers will not discover sensitive data flows from applications. We discuss how we can achieve this goal in Section V-B.

# V. DESIGN
We aim to design an automated anti-analysis mechanism to protect applications against the ReMaCi attack. In this section, we introduce the design of our automated multi-layered bytecode generation system, codenamed AmpDroid, that can identify sensitive data flows and prevent information leaks by isolating code that handles sensitive data.

# A. IDENTIFICATION OF SENSITIVE DATA FLOWS
# 1) FINDING THE STEMS
To discover the stems mentioned in Section IV, we employ a taint analysis tool, Flowdroid . Flowdroid defines functions that find device-dependent sensitive information such as IMEI and serial numbers and the other internal messages used in an application as a source. Flowdroid then defines functions that send sensitive information over the network or save it to storage as a sink. Next, Flowdroid finds the sources in the application to check if the application uses sensitive data obtained by using APIs. If Flowdroid discovers a source, it performs a taint analysis to discover execution paths that end up with transferring the sensitive data (e.g., functions sending data over the network) from the source by using the Inter-procedural Control-Flow Graph (ICFG). Identified execution paths include a sequential procedure that sensitive data is passed into variables or functions from source to sink.

Flowdroid is a widely-used static taint analyzer to analyze data flows in an Android application. Tofighi-Shirazi et al.  demonstrated that Flowdroid with Iccta shows the noticeable accuracy to find information flow in mobile applications compared to other tools. Also, because Flowdroid has been steadily updated by users up to these days, it is quite stable and can be used for applications that run on the most recent version of the Android platform. Therefore, we believe that we can effectively find the stems from applications by employing Flowdroid.

As such, analysis results of Flowdroid are sound, and thus, we can provide a proper defense against ReMaCi attacks by generating multi-layered bytecode based on them.

# 2) SELECTING A CLASS TO ISOLATE
After discovering the stems, we select a class that will be isolated from an application based on the identified stems where the sensitive data is handled. AmpDroid, currently, supports one class to be isolated from the application. For the effectiveness of the isolation, AmpDroid finds a class that has the most instructions in stems. A stem is a series of instructions from the start of processing for data to the end of sending data outside of an application. Therefore, a stem may consist of instructions over multiple classes in an application.

To choose a class, we analyze an application to find which class has the most instructions in stems. To this end, we statically find the number of instructions contained in stems in each class by comparing instructions between a class and each stem. If more than or equal to two classes have the same number of instructions in stems, AmpDroid picks a class randomly. It is worth noting that even though AmpDroid isolates one class, we can successfully mitigate ReMaCi attacks because an AmpDroid-protected application cannot be statically analyzed and dynamically analyzed (it cannot execute without the isolated class). Specifically, if a class can access sensitive data with few instructions that were not be selected for isolating from the application, the few instructions may be exploited by the ReMaCi attack. To this end, the application must execute for leaking sensitive data, but it conclusively cannot start executing without the isolated class. Consequently, the remaining instructions that use sensitive information cannot be exploited. We note that AmpDroid-protected applications can execute only with the isolated class. For the rest of the paper, we call a class that will be isolated by AmpDroid as sensitive code.

# B. MULTI-LAYERED BYTECODE GENERATION
classes.dex of an application includes user-defined classes, third-party libraries, android platform API, etc. To generate multi-layered bytecode, AmpDroid divides classes.dex into three dex files: sensitive code dex (called SC dex), user-defined classes dex (called UDC dex), and the rest code for the classes.dex.

# 1) SC DEX
To prevent ReMaCi attack, we hide the sensitive code so that attackers cannot reveal it through reverse engineering applications. To this end, AmpDroid isolates the sensitive code as an SC dex file from the classes.dex. The isolated sensitive code will be dynamically loaded and used when an application executes. Also, we need to manage the SC dex to not exist in the application. This is because as far as the SC dex is in an application, attackers are able to monitor the execution of the sensitive code and reveal sensitive data flows even if SC dex was heavily obfuscated.

To isolate the sensitive code, AmpDroid first decompiles the classes.dex. It, then, parses decompiled Smali files to obtain and manage all packages, classes, methods, and fields defined in the application. Next, AmpDroid finds the sensitive code and stores it in a separate file. Also, AmpDroid deletes the sensitive code from the decompiled Smali files. Furthermore, AmpDroid finds all instructions invoking methods in the sensitive code to patch them.

To be specific, AmpDroid creates a DexClassLoader object in the classes.dex to dynamically load the SC dex. By using the method, an application dynamically loads the class isolated in the SC dex when it executes.