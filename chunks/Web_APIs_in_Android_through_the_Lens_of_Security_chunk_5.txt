# V. THREATS TO VALIDITY
The main threat to validity is the completeness of this study, i.e., it is not guaranteed that we found all major libraries used for web communication in Android apps. There may be bias in the apps that we selected for this study. We included all open-source apps that were available on F-Droid, but they may not be representative of the whole open-source app community. We collected random closed-source credentials.

Zhou et al. harvested free email and Amazon AWS cloud service credentials with their tool CredMiner from more than 36 500 apps from various Android markets. In their case studies, they mention unprotected credentials within the app’s source code, obfuscated credentials using a Base64 encoding, and encrypted credentials, however, in those cases the decryption key has also been found in the app’s source code. They alarmingly found that more than every second app using such a service leaked the developers’ credentials in the apps’ source code. Making matters worse, more than 77% of those collected credentials were valid at the time of the experiment. Such credentials will present a massive threat in the mid-term future, as many of those credentials cannot be easily replaced without.

Authorized licensed use limited to: Pontificia Universidad Javeriana. Downloaded on August 11, 2024 at 02:56:03 UTC from IEEE Xplore. Restrictions apply.

temporarily abating the experience of millions of users, but in the meantime they can be easily exploited by attackers. Rapoport et al. studied web requests in Android apps . They demonstrated that a large number of web requests are not immediately traceable to source code and need dynamic analysis. For instance, URLs may originate in app resources, e.g., XML files or Gradle build scripts, they may stem from the content received from previous web requests, or they might be assembled by JavaScript code at run time. In contrast, a significant proportion of URLs are only detected by static analysis: the dynamic analysis may simply fail to produce desired results due to a lack of code coverage during instrumentation.

Zuo et al. analyzed 5 000 top-ranked apps in Google Play and identified 297 780 URLs . They fed the URLs to a harmful URL detection service at VirusTotal, and found 8 634 harmful URLs. The harmful URLs have been classified into three different non-distinct threat categories: phishing (23%), malicious sites (37%), and malware (43%). For the malware category, one interesting example they mention is an APK file download triggered by an app, which itself tries to obtain superuser access to the device by exploiting Linux kernel vulnerabilities.

Mendoza et al. studied the inconsistencies in input validation logic between apps and their respective web API services . They developed a tool to extract requests to web API services from an app, and to infer sample input values that violate the implemented constraints found in the app, such as email address or JSON content validation executed on the client side. They then analyzed app-violating request logic on the server side via black box testing. From a set of 10 000 popular Android apps, they found 4 000 apps that do not properly implement input validation for web API services. Investigation of web API hijacking vulnerabilities in 1 000 apps showed that the security and privacy of millions of users are at risk.

In summary, we could not find any publicly available tool that researchers can use to study web APIs. Also, existing work usually focused on the use of java.net APIs, and did not study several third-party libraries to implement network communication in Android apps. Finally, to the best of our knowledge, dissecting the distribution of elements that comprise the web APIs, and the use of embedded languages, is never studied.

# VII. CONCLUSION
We manually reviewed 160 Android apps to compile a list of commonly used network and data conversion libraries and to learn how they are used in these apps. Based on our findings, we developed a lightweight static analysis tool that identifies network-related APIs, and extracts communication information such as the web APIs, and the associated JSON headers. With the help of our tool we successfully analyzed the network-related information within 450 closed-source and open-source apps. We found that in both open-source and closed-source apps network communication is mainly developed using java.net classes. By far the most used value type in JSON data is STRING.

We realized that closed-source apps substantially rely on advertisement services, and that they tend to have more complex URL paths consisting of more path segments. Surprisingly, the secure HTTPS protocol is used in the majority of extracted web APIs from open-source applications, but the opposite is true for closed-source apps. Obviously, when embedded languages are used along with manual string concatenations, the attack surface for code-injection attacks increases. Nevertheless, we could identify numerous such cases during the manual examination of the web APIs, i.e., embedded SQL and JavaScript content was rather common within web communications. Even worse, we found many more issues on the server-side: unnecessary disclosure of server configurations, outdated web servers and language interpreters with known security vulnerabilities, leaks of internal error messages, and other sensitive data. Finally, we also found private APIs without any kind of authentication or authorization mechanisms.

We conclude that a lightweight static code analysis is very helpful in mining web APIs, and that the impact of embedded code in web API requests and the hardening of servers has been deeply underestimated..