IccTA implements static taint analysis approach that analyze inter-component communication (ICC). It is built on top of FlowDroid  and IC3 . IC3 is used to resolve targets in ICC, while FlowDroid is used to perform static taint analysis. In IccTA, we configured the ICC APIs (e.g., getIntent()) as sources and configured all the APIs that require special permission as sinks (listed in Pscout ). If there is a data flow from a source (i.e., data sent from another app or another component) to a sink (i.e., performing privileged action), it is a case of permission re-delegation. We configured IccTA to report such cases. We note that such permission re-delegation cases are not necessarily vulnerabilities. Some of these cases could be the intended features of the app and thus, safe cases. ICC is a feature of Android framework. On the other hand, this in fact motivates the need of an approach like ours, for more precise vulnerability detection.

In the following, we compare the results by discussing what cases are genuine vulnerabilities and what cases are safe cases.

We ran Covert and IccTA on the open source apps (595 open source apps that we used in Section 8 and the 20 mutated apps that we used in Section 8). We ran these tools on the closed source apps as well but we shall only discuss their results based on the analysis of open source apps. This is because these tools reported a large number of vulnerabilities in the closed source apps and it was difficult to verify them as we cannot inspect the source code and the tools do not generate proof-of-concept test cases. For each vulnerability report generated by these tools, we manually inspected the source code to establish the ground truth, i.e., classify the report as a real vulnerability or as a safe case.

# Empirical Software Engineering (2020) 25:5084–5136
Results of Covert: The results of Covert on the open source apps is shown in Table 6. The first column shows the apps reported as vulnerable by Covert. The second column shows whether the reported vulnerable app is actually vulnerable. The remaining columns show whether the report is a safe case categorized as “Intentional Behaviour”, “Intra-comp. Intent”, “Private Components” or “System Intent”. From our manual analyses, we observed that safe cases are cases of app’s intentional behaviour, cases that can be activated only with an intra-component intent, cases that involve only private components, or cases that can be activated only with system intent.

Covert reported hundreds of vulnerabilities in the open source apps. However, only 18 of them are related to permission re-delegation. Out of these 18 vulnerabilities, only one is a real vulnerability and the rest are all safe cases. We manually verified and determined the safe cases as follows:
- Intentional behavior: some reported apps receive data from other apps (components) and use privileged APIs. These are cases of permission re-delegations. However, our inspection found that those cases actually implement app features declared in app’s descriptions (intended features). For example, com.newsblur, com.mschlauch.comfortreader, com.duckduckgo.mobile.android and se.anyro.nfc reader are browser, NFC reader and news/document reader apps, respectively; and browsing and data reading features are clearly declared in their Play Store descriptions. Therefore, those reports are actually safe cases of permission re-delegation. Most reports fall under this category.

- Intra-component intent: for some reported apps, the intent can only come from a component within the same app (i.e., result of startActivityForResult call).

Empirical Software Engineering (2020) 25:5084–5136 5121
Hence, those reports are actually safe cases, because the intent originates from the same app.

- Private components: for the reported app *com.briankhuu.nfcmessageboard*, the components in question are not exported. Therefore, they are only accessible within the same app and thus, not exploitable.

- System intent: for the reported app *be.brunoparmentier.openbikesharing.app*, the intent returned from the system component, AccountManager, is reported to be potentially dangerous. Since the intent actually comes from the Android system, we consider this as safe.

Regarding the 20 mutated apps, Covert did not report any of them as vulnerable. Thus, it missed all the vulnerabilities.

# Results of IccTA
- User interaction: some reported apps such as *com.newsblur and com.ringdroid* require the user to interact. If a user is involved, it is either an intended behavior or an action that can be aborted by the user. Therefore, we do not consider this as a vulnerability (See Precondition P R1 in Section 3).

- Overtainting: for some reported apps such as *de.syss.MifareClassicTool*, the result of IccTA is affected by overtainting. For example, an activity instance containing an untrusted field is tainted. This instance is then used in a callback function but the
Empirical Software Engineering (2020) 25:5084–5136
field does not actually influence the invocation of any privileged API; hence this is a safe case.

As shown in Table 7, some reported cases correspond to more than one category of safe cases. Regarding the 20 mutated apps, IccTA did not report any of them as vulnerable. Thus, it missed all the vulnerabilities.

Considering these results we formulate the subsequent answer to RQ4:
PREV significantly outperforms Covert and IccTA in detecting permission re-delegation vulnerabilities because, according to our definition of permission re-delegation vulnerability, those tools missed the vulnerabilities detected by PREV, except the one vulnerability detected by Covert.

# 8 RQ 5 : Robustness
PREV detects vulnerable apps based on the permission re-delegation models that are learned on a large number of “safe” (benign and non-vulnerable) training apps. The detection accuracy might degrade when the quality of training apps degrades. Even though we carefully selected the “safe” apps (see Section 5), there is still a risk that some apps with security defects are included in the training set. In this case, our models may characterize these defects and PREV would not detect them as anomalies according to these models.

However, since PREV adopts a threshold-based algorithm, we made the assumption that it is robust against the inclusion of a small number of non-safe apps in the training set. Here we validate this assumption and quantify the robustness against the presence of non-safe apps in the training set.

Given vulnerability v, occurring in the app a that was assigned the cluster c, we define robustness(v) as the number of occurrences of vulnerability v that need to be included in the training set (in cluster c) to cause PREV not able to detect v.

To this aim, we gradually degrade the training set by replacing the safe apps with contaminated apps — apps that contain the same vulnerable permission re-delegation behaviors as those apps PREV correctly detected as vulnerable in Section 8. Learning is repeated.

# Empirical Software Engineering (2020) 25:5084–5136
# 5123
on this new, degraded training set and the same experiment as in Section 8 is repeated, to assess if PREV is still able to detect the same vulnerabilities despite the contaminated training set. If PREV can still detect the same vulnerabilities, more and more contaminated apps are added to the training set and the process is iterated, until PREV can no longer detect the vulnerabilities; the number of contaminated apps at the last iteration gives us a robustness measure with respect to vulnerability v and cluster c.

More specifically, we consider the API frequency matrix M that was originally constructed at model inference step for a given cluster (see Section 5). An example of this matrix is shown in Fig. 17a. Rows represent apps in the training set and columns represent privileged APIs; a cell contains the value 1 when the API in the column is exposed (reachable from a public entry point) and the value 0 if the API is not exposed/used in the app.

Camera.open() in Fig. 17 is a privileged API associated with a permission re-delegation vulnerability that PREV detected on the subject app com.appportunity.androidpreviewer. PREV detected the vulnerability based on the permission re-delegation model learnt on the training apps of the cluster to which the subject app belongs (cluster 20). Now, we degrade this training set by modifying the API Camera.open() as reachable in TrainingApp2, a training app from the same cluster as com.appportunity.androidpreviewer. This in fact corresponds to changing a value from 0 to 1 in the third column of the matrix. The change is highlighted in boldface in Fig. 17b. In this way, we contaminate the training set, by making the privileged but uncommon API Camera.open() more frequent and, thus, less likely anomalous.

In this experiment, PREV still detected the vulnerability due to the reachable API Camera.open() when the original training set is degraded with one contaminated app; but it was not able to detect the vulnerability anymore when it is degraded with two contaminated apps.