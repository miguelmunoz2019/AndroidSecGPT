# A Risk Estimation Study of Native Code Vulnerabilities in Android Applications
Davide Maiorca1[00001[0009−0002−8269−9777], Diego Soi1[0009−0009−0092−9067], Silvia Lucia Sanna1[0003−2640−4663], Giorgio Fumera1[0000−0001−5300−226X] and Giorgio Giacinto1[0000−0002−5759]
Department of Electrical and Electronic Engineering, University of Cagliari, Italy
# Abstract
Android is the most used Operating System worldwide for mobile devices, with hundreds of thousands of apps downloaded daily. Although these apps are primarily written in Java and Kotlin, advanced functionalities such as graphics or cryptography are provided through native C/C++ libraries. These libraries can be affected by common vulnerabilities in C/C++ code (e.g., memory errors such as buffer overflow), through which attackers can read/modify data or execute arbitrary code. The detection and assessment of vulnerabilities in Android native code have only been recently explored by previous research work. In this paper, we propose a fast risk-based approach that provides a risk score related to the native part of an Android application. In this way, before an app is released, the developer can check if the app may contain vulnerabilities in the Native Code and, if present, patch them to publish a more secure application. To this end, we first use fast regular expressions to detect library versions and possible vulnerable functions. Then, we apply scores extracted from a vulnerability database to the analyzed application, thus obtaining a risk score representative of the whole app. We demonstrate the validity of our approach by performing a large-scale analysis on more than 100,000 applications (but only 40% contained native code) and 15 popular libraries carrying known vulnerabilities. The attained results show that many applications contain well-known vulnerabilities that miscreants can potentially exploit, posing serious concerns about the security of the whole Android applications landscape.

# Keywords
Vulnerability Detection, Android App, Native Code
# 1 Introduction
The usage of mobile devices is increasingly growing due to their continuous advancements that allow people to carry out very different tasks, from surfing the internet to accessing banking or medical accounts. Smartphones are also extensively employed as multimedia devices (e.g., to watch movies or play games) and as aids for payment authentication and Public Administration services. Unfortunately, this variety of usage allows attackers to exploit vulnerabilities (by
F. Author et al.

resorting to, e.g., phishing emails and messages or by exploiting memory errors to take control of the target devices.

Among the various Operating Systems available for mobile devices, Android is the most used worldwide , and many of its applications can feature hundreds of millions of downloads. These apps often need to interact with native activities and components (e.g., camera and microphone) available through Native Code (typically C/C++) implementation, which may be written from scratch or taken from third-party libraries such as Libpng and OpenCV. For brevity, we refer to native third-party libraries as products. In most cases, developers use publicly available libraries such as Libpng (for image management) by importing them into their projects. As native libraries are written in memory-unsafe languages, they can suffer from typical vulnerabilities caused by wrong source code programming or design. Improperly managing pointers, arrays, and API calls can lead to overflow attacks or other vulnerabilities. A simple example of possible memory errors is buffer overflow, which allows an attacker to send an input whose size is larger than required, thus writing data outside bounds and causing unpredictable behaviours. Exploiting vulnerabilities in native libraries can affect the functionality of the whole application, leading to some data exposure or, in the worst cases, to the loss of control of the device. For this reason, it is essential to manage the security of the used libraries when developing an Android application. Previous research works have only recently pointed out the need for better native code safety and vulnerability analysis.

However, finding and analyzing vulnerabilities is a very time and resource-consuming task requiring in-depth static and dynamic analysis of the native layer and its interaction with the Java/Kotlin code . Recent works also showed several validation problems related to the effective reachability of vulnerable functions . These issues may discourage analyzing the native layer security in their apps, thus often overlooking even well-known issues of public products. We propose a probabilistic approach that vulnerability researchers can use to have a first basic idea of the vulnerability to be checked manually. Our vulnerability detection on Android Native Code can be included in the process of producing and maintaining the Software Bill Of Materials (SBOM), a detailed inventory of software components and their ingredients essential in software security and supply chain risk management (as described by the American Cybersecurity and Infrastructure Security Agency ). Different organizations worked on that, such as NIST , who released in February 2022 guidelines to be followed by developers and companies as a means of cyberattack prevention. In fact, SBOM has been introduced to provide guidance on the level of risk associated with the software, whether stand-alone or integrated into systems (such as in the case of Android Native Code). SBOM defines the most dangerous vulnerabilities and gives a global risk indication of the software vulnerabilities, stating the components with a greater likelihood of being affected (as in our methodology).

This paper proposes an alternative strategy for Native Code vulnerability identification that does not involve resource-heavy analyses but leverages on public knowledge of known issues. The idea is to yield a quick, lightweight approach.

# Risk Algorithm Native Code Vulnerabilities Android
that gives an idea of an application’s possible known risks to take immediate actions to address them. This is done through a a risk assessment algorithm that leverages a combination of quick code analysis and public domain knowledge to provide a score of possible dangerousness of the application based on the vulnerabilities found.

More specifically, our contributions can be summarised as follows: (i) we propose a minimal complexity Native Code analysis strategy oriented to the search for known vulnerabilities and issues by leveraging public domain knowledge; (ii) we define a risk assessment algorithm that provides a dangerousness score that can aid security researchers to take immediate actions to patch the analysed applications; (iii) we evaluate our methodology through a large scale analysis on 100, 000 APKs taken from the widespread application repository Androzoo, but results are focused on 38, 348 apks which are those using at least one native library. To the best of our knowledge, no risk assessment algorithm or methodology has been published for vulnerabilities in the Native Code. The results attained in this paper demonstrate that a risk-based approach can be strongly beneficial in swiftly assessing vulnerabilities in Android applications, thus addressing this problem by working on their early detection and prevention.

The remainder of this paper is structured as follows. Section 2 presents a technical background about Android applications structure and vulnerabilities. Previous research is illustrated in Section 3, while the applied methodology is presented in Section 4. Results are reported in Section 5. Finally, Section 6 discusses the limits and the future works that may be conducted to improve this work.

# 2 Technical Background
Before introducing our methodology, some concepts need a brief explanation to provide the reader with basic knowledge about the core elements of Android applications and Native Code.

# 2 ARM
ARM, the acronym for Advanced RISC Machine, is the hardware architecture on which Android OS and apps are executed. It is commonly implemented in embedded systems, where developers design and sell the processor’s architecture to vendors such as Samsung, Lenovo, and Oppo. ARM is based on RISC (i.e. Reduced Instruction Set Computer), an architecture with a smaller instruction set than x86/64 but with more general purpose registers and a load/store mechanism. As an example, to modify a value of a register, it is required to move the value to the register (with the instruction load), make the desired arithmetic operations, and save it back to memory (with the instruction store).

# 2 Android OS
The proprietary open-source Android OS , published by Google in the early 2000s, is the operating system running on ARM hardware and on which apps are built. Android mostly features six main layers :
1. Android System Apps, featuring apps for standard activities (e.g. SMS, calendar, emails);
2. Java API framework containing Android APIs to make different software components communicate with each other;
3. Native Libraries and core system services written in C/C++ to manage activities and interact with physical device components;
4. Android Runtime to manage runtime for executing Android apps since Android 5;
5. Hardware Abstraction Layer (HAL), which is a software-hardware interaction layer that employs specific hardware interface description language (HIDL), allowing detachment between OS and drivers (autonomous upgrade);
6. Linux kernel, based on an upgraded version of Linux kernel to such platform.

An interesting characteristic of Android OS is the permission level. In low-level mode, users and groups can access file systems and specific resources. Conversely, permissions are restricted in high-level mode, and apps are installed.