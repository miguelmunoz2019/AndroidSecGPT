Table I shows the list of all LibRARIAN features. The features include: (i) five Metadata Features based on exported and imported functions, exported and imported globals, and library dependencies; and (ii) one Data Feature which is applied as a second factor to either substitute the Metadata Features, in case the reported similarity score is low, or to confirm the reported score. These 6 features represent the code elements of a library that would be expected to change based on a versioning scheme that distinguishes major, minor, and patch versions of a library. Furthermore, these features are stable across platforms regardless of the underlying architecture or compilation environments. We did not include code features (e.g., control-flow and data-flow features) as they are extremely volatile and change between compilations and across architectures. Binary similarity matching is a hard open
# Feature Name
# Type
TABLE I: List of features LibRARIAN extracts from native binaries of Android apps along with their type and definition.

problem: While recent work has made progress regarding accuracy , , , , , , , , the majority of algorithms have exponential computation cost relative to the code size and are infeasible for large-scale studies. We built a dataset of heuristics by inspecting the binaries in our ground-truth dataset. We developed scripts to process the data in the .rodata sections extracted during feature processing and search for unique per-library strings that contain version information. For example, FFmpeg version info is found when applying the regex f f m p e g - ( [ 0 - 9 ] \ . ) * [ 0 - 9 ] or FFmpeg version ( [ 0 - 9 ] \ . ) * [ 0- 9]. Table II shows our list of extracted version heuristics. Each version heuristic can be produced automatically by constructing regular expressions from strings in .rodata sections of binaries in our ground-truth dataset. For example, if the string “libFoo-1” is found in version 1 of libFoo, LibRARIAN uses a regular expression replacing the numeric suffix of the string with an appropriate pattern (e.g., l i b F o o - [ 0 - 9 ] + ( \ . [ 0 - 9 ] ) * ).

The similarity score is a real number between 0 and 1, with a score of 1 indicating identical features, a score of 0 indicating no shared features between the two libraries, and a fractional value indicating a partial match. Due to the volatility of the similarity score, filtering noise such as platform-specific details as mentioned in the previous section is essential for the accuracy of our approach.

LibRARIAN counts an unknown library instance from Unknown Lib Versions as matching a known library version if its bin2sim is above 0. This threshold was determined experimentally and works effectively as our evaluation will demonstrate (see Section III). If bin2sim results in the same value above the threshold for multiple known binaries, LibRARIAN tries obtaining an exact match between one of the known binaries and the unknown binary by using their hash codes to determine the unknown binary’s version.

A low similarity score might result from modifications made by app developers to the original third-party library which results in the removal or addition of specific features. From our experience, removal of features from the original library is common among mobile developers and is likely driven by the need to reduce the size of the library and the app as much as possible. For example, we observed that the WebP video codec library is often deployed without encoding functionalities to reduce binary size. Some size optimization techniques require choosing needed modules from a library and leaving the rest, stripping the resulting binary, and modifying build flags. Another factor that reduces similarity as measured by the Jaccard coefficient is that certain architectures tend to export more features as compared to others. For instance, 32-bit architectures such as armeabi-v7a and x86 export more features compared to arm64-v8a and x86_64.

# B. Similarity Computation
LibRARIAN’s similarity computation, which we refer to as bin2sim, leverages the five Metadata Features when computing the similarity scores between an app binary and our.

# C. Version Identification Strings
For libraries where LibRARIAN reports low similarity scores (e.g., some libraries like RenderScript or Unity only...

# TABLE II: Heuristics used to search for unique per-library strings that contain version information
export a single function 1), these five features fail to provide sufficient information about the underlying components in a library. If libraries only export one or a few functions, the similarity metrics have a hard time distinguishing between different libraries. We therefore extend the features with strings that uniquely identify the library. Such strings are often version strings. Based on extracted flexible per-library heuristics from our ground-truth dataset (see Table II), we heuristically identify exact library versions and increase overall accuracy. For libraries with high similarity scores, we use these library heuristics to confirm the correct version.

To identify binaries with low similarity scores, we leverage Version Identification Strings, which is the set of extracted per-library version strings. For example, say a library version extracted from app a had a similarity score of 0 when compared with OpenCV-2 using Metadata Features. Given the low score, we search the Version Identification Strings feature for specific keywords such as General configuration for OpenCV *.*.* or opencv-* .*.*. Where the asterisk represents the versioning scheme of OpenCV library.

Our feature extraction process logs all strings (arrays of more than 3 ASCII printable characters ending with a 0 byte) from the .rodata section alongside the other features. As libraries commonly have large amounts of read-only string data that frequently changes, we cannot use this data directly as a feature (due to the low overlap resulting in low similarity). By processing the .rodata from our ground-truth dataset and clustering the data, we extract common version identifiers and version strings. We then translate them into regular expressions that allow us to match versions for different libraries.

# III. Evaluation
To assess the prevalence of vulnerable native libraries for Android, we answer the following three research questions:
RQ1: Accuracy and effectiveness of LibRARIAN. Can LibRARIAN accurately and effectively identify versions of native libraries? How does LibRARIAN compare against state-of-the-art native-library version identification? How effective are LibRARIAN’s feature types at identifying versions of native libraries?
RQ2: Prevalence of outdated libraries. How prevalent are vulnerabilities in native libraries of Android apps?
RQ3: Patch response time. After a vulnerability is reported for a third-party library, how quickly do developers apply patches?
To supplement the aforementioned RQs, we conducted a detailed case study on a vulnerable app (Section III-D), providing practical insight into vulnerabilities in third-party libraries and possible exploits.

To answer these research questions, we analyze the top 200 apps in Google Play over several years. We track the version history of these apps from AndroZoo , a large repository of over 11 million Android apps. Our repository contains app metadata including the app name, release dates, and native binaries. Note that Google Play unfortunately restricts lists to 200 apps. Overall, we collected 7,678 instances, where each instance is a version of the 200 top apps from Google Play.

We determined that 145 out of 200 (72%) of the distinct apps in our repository contain at least one native library, i.e., 5,852 out of 7,678 (76%) of the total apps in our database. There are a total of 66,684 libraries in the form of .so files, i.e., shared library files, in our repository with an average of 11 libraries per app and a maximum of 141 for one version of Instagram. In fact, Instagram—for which we collected 184 versions since Dec. 2013—contains a total of 6,677 .so files.

We run LibRARIAN on a machine with 2 AMD EPYC 7551 32-Core CPUs and 512GB of RAM running Ubuntu 18. The average number of features in the extracted feature vectors is 2,116 features. Some outliers such as libWaze and libTensorflow reach up to 79,581 features. This shows that the set of third-party native libraries in our repository is diverse, some of them are very complex and offer a large number of functionalities. Generating feature vectors is quick and generally takes a few seconds per library. The most complex library, libTensorflow takes 4 min and 38 sec to analyze. We found that, out of 7,253 binaries for which LibRARIAN inferred their versions, the average runtime for library version detection is 118 seconds—with a minimum of 97 seconds and a maximum of 224 seconds.

# RQ1: Accuracy and Effectiveness
# Finding 1: LibRARIAN achieves a 12% improvement in its accuracy compared to OSSPolice on the 67 unique binaries in OSSPolice’s dataset.