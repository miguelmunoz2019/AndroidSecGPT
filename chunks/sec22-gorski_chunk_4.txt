# 4 Data Flow Analysis
FRED performs a backwards inter-procedural data flow analysis to determine possible values for the file paths passed as arguments to file methods invoked by Java-based RPC entry points. The sink for this backwards data flow analysis is the file path argument. For many file methods, the sink is a string (i.e., java.lang.String). When a file method has multiple string arguments, it is difficult to know which argument is the file path. Fortunately, the regular expressions produced for non-file paths will not match any concrete files from the file system. Therefore FRED conservatively determines values for all string arguments. For file methods that are passed non-string file paths (e.g., java.io.File and java.nio.file.Path), FRED first performs use-def analysis from the argument to identify the location of the constructor.

which is passed a string. For this discussion, this constructor can be viewed as the sink for the data flow analysis.

At a high level, FRED determines the possible values of file paths by annotating instructions in the Inter-procedural Control Flow Graph (ICFG) of the Android framework with intermediate expressions. This process begins by annotating the data flow sink (i.e., file path argument) with a Place-Holder node. FRED then performs a inter-procedural use-def analysis to traverse the ICFG backwards, using CHA  where necessary. If the definition of the argument is a constant value, the PlaceHolder node is replaced with a Constant node that includes the value. However, there are various scenarios when the definition is not a constant. In these cases, FRED annotates the definition with a new PlaceHolder node and recursively1 attempts to determine the value for this new PlaceHolder node. Once the value for a PlaceHolder node is determined, the recursive call returns the resulting intermediate expression to the earlier invocation, populating its PlaceHolder node, and possibly combining multiple intermediate expressions with Append or Or branch nodes. We note that while FRED identifies the values for each sink sequentially, it retains the annotations on the ICFG to avoid resolving them multiple times.

As this recursive algorithm proceeds, there are frequently multiple PlaceHolder nodes annotated on the ICFG at any point in time. FRED leverages this fact to handle loops, ensuring that the value for a PlaceHolder node is only ever computed once. Specifically, FRED constructs a graph of PlaceHolder nodes where an edge between two PlaceHolder nodes occurs when one references the other in its computing expression. FRED then uses Johnson’s algorithm  for detecting elementary circuits to locate simple cycles in the graph. When this occurs, the PlaceHolder node referencing the head of the simple cycle is replaced with a Loop node. Empirically, we found that Loop nodes are little more than a source of noise in our analysis. Therefore, FRED currently removes Loop nodes when transforming intermediate expressions into regular expressions (Section 4).

There are various scenarios when the use-def analysis for a PlaceHolder node does not find a constant at the definition. FRED handles a variety of special cases including string builders, path builders, directory listings, and parent path and file name access methods. FRED also handles environment variables and system properties by identifying the string-based keys used to look up these values. Finally, FRED handles specific fields in Android framework classes by performing a def-use analysis to determine all possible assignment sites for the framework. This information is later used during the backwards data flow analysis to combine possible values. Appendix A details each of these cases.

1While we describe the algorithm as recursive to simplify discussion, it is in fact tail-recursive and our implementation is iterative.

# 4 Regular Expression Transformation
After FRED identifies intermediate expressions for the arguments to file methods, it transforms them into regular expressions. This transformation is performed as follows.

1. Step 1 (Remove Loops): FRED removes all Loop nodes from intermediate expressions and any empty Branch nodes that result. We empirically found that the loops captured by our data flow analysis did not actually influence the construction of the file paths within the code. As such, Loop nodes can be safely removed from intermediate expressions.

2. Step 2 (Resolve System and Environmental Variables): To resolve system properties, FRED uses the various .prop files of the Android system (e.g., /default.prop and /system-/build.prop) to lookup the value based on the key determined during data flow analysis. To resolve environmental variables, FRED uses adb shell echo ${VARIABLE} to get their values.

3. Step 3 (Resolve UserId Variables): Android supports multiple physical users. It is common for file paths to include the UserId of the current physical user to separate user specific files. To avoid unnecessary Any nodes, we replace UserId with the string “0”, which is the UserID for the primary user (and the only user on our test devices).

4. Step 4 (Resolve TVInputManagerService Regex): The TVInputManagerService contains two entry points that open file paths in the /dev directory based on a regular expression. For these entry points, FRED extracts the regular expression used to match files and replaces the Any node with the extracted expressions.

5. Step 5 (Convert to DNF): FRED transforms the AND and OR logic of Append and Or nodes into disjunctive normal form (DNF), maintaining the order of the append operations throughout the transformation. This process flattens the tree and simplifies file path dependent transformations (e.g., determining the parent or file name of a existing file path).

6. Step 6 (Resolve Parent and File Names): With the intermediate expression in DNF and the remaining constants resolved, FRED can evaluate the Parent and Name branch nodes. At this point, Parent and Name nodes typically have a single Append child that concatenates parts of a path. For this Append node, FRED locates the last occurrence of the ‘/’ path separator. Parent nodes are replaced with a new Append node containing all the children that occur before the last ‘/’ from the previous Append node. Any text after the ‘/’ within the node that contains the last occurrence of ‘/’ is removed. Name nodes are replaced with a new Append node containing all the children that occur after the last ‘/’ from the previous Append node. Any text before the ‘/’ within the node that contains the last occurrence of ‘/’ is removed. When the child of a Parent or Name node is an Any node, the Parent or Name node is simply replaced with the Any node.

7. Step 7 (Combine and Normalize): After the previous step, the intermediate expression only contains Constant, Any, Ap-
USENIX Association 31st USENIX Security Symposium 1531
# 4 Extracting File Paths Used in Native Code
Android’s Java-based RPC entry points often use the Java Native Interface to invoke code written in C/C++. Figure 3 shows two scenarios that are not covered by the Java analysis described in Section 4. Both scenarios occur when a JNI method that is not a generic file method calls a libc file method. The first scenario defines the file path string within C/C++ code (Figure 3a), whereas the second scenario passes the file path string from Java to C/C++ code (Figure 3b). FRED extracts these file paths from binary .so files using angr.

Identifying JNI Methods in Native Code: While the native keyword identifies JNI methods in Java code, the corresponding C/C++ function is not clearly annotated in either the source or binary code. The C/C++ name also does not always match the Java name (e.g., method overloading). For each .so file, we use angr to traverse the CFG from all exposed library functions to identify calls to jniRegisterNativeMethods. We then use angr’s symbolic execution engine to identify the array of JNINativeMethod structures passed as a parameter. This structure provides a mapping from the Java method signature to a function pointer in the .so file. We traverse the array to identify the function address of the C/C++ handler for each JNI method. In a small number of cases, we found function addresses to be NULL and used function name matching as a fallback. As the function name resolution was verified to be correct for all such NULL address cases, we leave additional address resolution techniques to future work.

Identifying File Paths: FRED first traverses the ICFG from the JNI method handler to identify any calls to libc file methods (Section 4). When a file method is found, FRED uses angr’s Reaching Definition Analysis (RDA) to determine the possible values for the relevant file path arguments. To reduce the search space, FRED only includes nodes in the variable’s backward slices as potential sources. For each variable definition source, FRED determines if the value originates within the C/C++ code or if it is passed from Java. If it originates in C/C++ code, FRED extracts the constant string. Note that angr correctly propagates strings through standard libc functions (e.g., strcpy) and therefore automatically handles string construction. We did not encounter the more complicated string construction methods found in the Java code.