# Android Source Code Vulnerability Detection: A Systematic Literature Review
# 5 Prevention Techniques
Preventing code vulnerabilities at the early stages of app development is more advantageous than detecting them once the app has been developed. Therefore, prevention techniques can be integrated as frameworks, tools, and plugins to the development environments as additional support to the app developers with automated vulnerability detection methods. The analysis of experimental results in Reference  identified the need for automated code vulnerability detection support when developing secure applications to perform well. Android developers had to play the role of participants, and they had to propose an appropriate fix to given vulnerable code samples, such as SQL injections, encryption issues, and hard-coded credentials. Moreover, the stitch-in-time mechanism proposed in Reference  described vulnerability detection methods in Android apps at the development time. Developers can enter source code and continue the development process while the model checks for known security-oriented issues. If there are such issues, then developers are informed accordingly. Therefore, developers get the benefit of developing less-vulnerable source code. However, this method uses only known vulnerabilities. Therefore, the ML/DL-based method could be applied to adapt to the changing nature of source code-related issues. The model could be modified further to learn from user mistakes and bugs.

ACM Computing Surveys, Vol. 55, No. 9, Article 187. Publication date: January 2023.

J. Senanayake et al.

It is always better to inform the app developer about the severity level of identified vulnerabilities in addition to raising an alert. Android Lint is a valuable method to discover vulnerabilities using static analysis in given Android source code . It can detect 339 security, performance, correctness, usability, internationalisation, and accessibility issues. Android Lint uses either an AST or an Universal AST generated through source code. There are other Linters also available such as Infer, PMD, FindBugs, CheckStyle, Detekt, and Ktlint, as discussed in Reference . The OASSIS study introduced a method to prioritise warnings generated from Android Lint with static analysis. This method used app user reviews and sentiment analysis to identify app issues. Because of the prioritised warnings, developers can take action accordingly to fix the vulnerability issues. A way to indicate this to the developer is using a similar approach like in Reference.

The model in Reference  proposed a mechanism to integrate static analysis with development environments named as MagpieBridge. Though it is possible to integrate this plugin with code editors such as Eclipse, IntelliJ, PyCharm, Jupyter, and Submile text, integrating with Android studio was not discussed. Meanwhile, the DevKnox plugin  for Android Studio can detect and resolve security issues while writing codes to develop Android applications. FixDroid  can be used to get security-oriented suggestions and fixes to overcome vulnerabilities when developing Android applications. It also can be integrated with Android studio, and it can be improved further by integrating ML to provide suggestions.

Another framework proposed in Reference  guided the app developers to detect, prioritise and mitigate vulnerabilities using secure development guidelines, and named as SOURCERER, and it used static analysis techniques. When the framework is applied, developers can get to know a concise list of vulnerabilities. It has a three-phase process: asset identification, vulnerability to asset mapping, and mitigation. The authors tested this framework with 36 Android financial apps, and there were three developers involved in this experiment. Based on the findings, when using this framework, developers spent an average of 15, 30, and 20 minutes for asset identification, vulnerability detection and prioritisation, and finding mitigations, respectively. This framework did not complicate the security testing process of Android apps. Issues such as the limited number of sample apps, limited developer involvement in the experiments, and developersâ€™ prior knowledge could affect the performance of this framework. Some of these limitations could be overcome by proposing an automated process.

The VuRLE tool  can be used to detect and repair vulnerabilities in source code automatically. It assists developers in dealing with various vulnerabilities. Initially, the model was trained and clustered similar edit blocks into groups using a training set of repair examples. Repair templates were generated for each group and used to identify vulnerable groups by applying transformative edits. Traversal of a generated AST was used in this together with 10-fold cross-validation. This model repaired 101 out of 183 detected vulnerabilities from 48 real-world apps (Android, web, word-processing, and multimedia apps) written in Java. However, some of the vulnerabilities were unable to repair due to unsuccessful placeholder resolution, lack of repair examples, and partial repairs. The low repair rate of this, which was 65%, can be increased by having a well-trained model with more vulnerable code samples.

# 5 Discussion on Vulnerability Detection Methods
Based on the reviewed studies, it is identified that 51% of studies used static analysis as the application analysis method, and 35% of studies used hybrid analysis. The rest of 14% used the dynamic analysis method. This is illustrated in Figure 3. The increased usage of static analysis may be due to its advantages for code-level analysis approaches, since they focus more on code features. Apart from that, the cost involved in static analysis is lower when compared with the other two methods. Dynamic analysis requires additional resources such as emulators or real devices to run the source.

ACM Computing Surveys, Vol. 55, No. 9, Article 187. Publication date: January 2023.

# Android Source Code Vulnerability Detection: A Systematic Literature Review
# 187:23
# Application/source code analysis techniques used in the reviewed studies
# Vulnerability detection methods
Code, and it will not be possible to uncover many vulnerabilities as in static analysis. Moreover, the need for APKs or compilable packages could be another reason for having fewer studies conducted for vulnerability detection with dynamic analysis. In terms of percentage, hybrid analysis is in the middle, since it has the characteristics of the other two analysis types.

Based on the reviewed studies, applying machine learning-based methods were higher than conventional methods. This is illustrated in Figure 4. Before 2016, conventional methods were popular among the research community compared to ML methods. However, with the boost in ML techniques, researchers tried to apply ML methods to solve problems . Therefore, due to this popularity, the ability to provide high accuracy results, ease of handling complex problems, and scalability are suspected as the reasons for the high usage of these ML/DL methods in studies on Android vulnerabilities detection in the considered period of the review.

Many code vulnerability detection studies used the code analysis method as the feature extraction method. The Manifest analysis and the system call analysis methods are the other widely used methods. Figure 5 illustrates those feature extraction methods used in the reviewed studies. It is possible to detect many vulnerabilities by analysing source codes rather than analysing permissions or other features. That may be the reason for the highest usage of code analysis. Using manifest analysis can also identify vulnerabilities to a certain extent, such as the type of permissions used in applications. The vulnerabilities can be detected based on the required permissions of the application, such as the requirement of the dangerous level permissions. That may be the reason for having a somewhat high number of studies conducted. A considerable number of studies use system call analysis, since it is possible to detect vulnerabilities to a certain level by analysing the system calls. Code instrumentation, system resources analysis, and network analysis were used in a limited number of studies, since it is not easy to detect vulnerabilities by analysing them.

ACM Computing Surveys, Vol. 55, No. 9, Article 187. Publication date: January 2023.

J. Senanayake et al.

# 5. Feature Extraction Methods
API calls were the most widely extracted feature for vulnerability analysis and detection in Android source code. Figure 6 illustrates that and the other extracted features in the reviewed studies. Many static and hybrid analysis methods extracted API calls as the feature to perform the analysis. A thorough understanding of vulnerabilities can be received by analysing API calls, which could explain the high usage of this as the extracted feature. Permission is the second prominent feature that was extracted in the reviewed studies. When conducting manifest analysis, permission is the main feature to be extracted. Since the manifest analysis was also widely used, it could be the reason for this high extraction rate. System calls are also a highly extracted feature in those studies, since they can detect many vulnerabilities by analysing them. Native code or opcodes, intents, network traffic, activities, and services were also extracted as features, but their usage is not highly visible.

It is identified that very few studies considered prevention mechanisms which are supported by the detection techniques as tools and plugins for Android source code vulnerability mitigation. Many of the studies considered only the detection as illustrated in Figure 7. It is valuable for the Android application developers if proper mechanisms are available that use various advanced techniques to prevent vulnerabilities. Therefore, as a finding of this review, the need to build such a prevention mechanism is recognised.