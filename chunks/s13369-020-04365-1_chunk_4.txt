3. It is evident from data presented in Table 1 that most authors performed experiments on a subset of smells related to OO and/or Android code smells and generalization of their results for these approaches are questionable. There is no single approach that focuses on all Android bad smells of Riemann et al.  for detection. This poses a serious threat to empirical studies that base their research on very low number of smells.

4. The detailed results of the presented approaches are not publically available for analysis and comparison of results. In such cases, researchers cannot compare the results of these approaches for evaluation of existing tools and for the development of new tools.

5. Most authors performed experiments on different open source projects/applications and undertake different code smells for the detection. In such cases, the analysis and comparison of results become arduous when tools are not publically available.

6. Most published papers on Android smells are from 2014 to 2019 and they are from conference proceedings. It indicates that filed of Android code smells detection is still at the stage of infancy and reaching maturity. It also indicates that due to rising number of mobile applications, the detection of refactoring of Android bad smells may be a promising area for researchers.

7. A few approaches measure the accuracy of detected code bad smells as depicted in Table 1. The accuracy is a key aspect for the application and adoption of approaches for researchers and practitioners.

8. The target language for most subject systems under experimentations is Java language.

8https://github.com/pgadient/AndroidLintSecurityChecks.

# Arabian Journal for Science and Engineering (2020) 45:3289–3315
# Arabian Journal for Science and Engineering (2020) 45:3289–3315
T Type, Co Count, HM HashMap, M_AC Method Acquire, M_RE Method Release, DBF Document Builder Factory, DB Document Builder, NL NodeList, M_Set Method Setter, M_Get Method Getter, R_O_C Reference of Outer Class, M_STA Method Thread Start, M_STO Method Thread Stop, FACC Field Access, MB Method Body, OLM onLowMemory, MWR MODE_WORLD_READABLE, MWW MODE_WORLD_WRITEABLE, SR setRepeating, TFL Traditional For Loop, MC Method Close, FM Field Modifier, F Field, FT Field Type, AC Any Collection like List, Map etc., CT Collection Type, AV Any View, AA Android:Attribute, ALW Android:LayoutWidth, ALH Android:layout_height, ANFD Android:Next Focus Down, ANFU android:nextFocusUp, ANFR Android:nextFocusRight, ANFL Android:NextFocusLeft, ALWT Android:layout_weight, ACD Android:Content Description, ACC Android:ConfigChanges, Ch Child, AL Any Layout, ACV Any Child View, BGC Background Color
# Specifications of Android Code Smells
correction. A catalog on definitions of 30 Android code smells is presented by Riemann et al. . We undertake the Android code smells presented by authors of this catalog for specification and detection. The definitions of some code
# Arabian Journal for Science and Engineering (2020) 45:3289–3315
smells presented in this catalog are at very abstract level. This catalog also does not have information about metrics and detection rules that may be used for the detection of these all smells. Due to these reasons, we selected most Android smells from this catalog for the specification. The rest of 5 Android code smells are selected from the state of the art and different blogs. The summarized information about selected smells is presented in Table 2. We uploaded detailed definitions and detection rules of Android code smells presented in Table 2 on the web.

The source code metrics are very important to measure the features of software processes and products . They are used to measure accuracy, flexibility, extensibility, complexity and other properties of software applications. They have been proven useful for measuring the quality of object-oriented and Android applications [139–144]. The source code metrics can be used to locate possible issues and propose improvements for the quality and efficiency of software applications. The dimensional, complexity, object-oriented and Android-oriented metrics are discussed by Mercaldo et al. . These different types of source code metrics are the key artifacts used for the detection of different code smells. Rehman et al.  presented 21 static source code metrics to predict security and privacy risks of Android applications. Authors extracted these metrics from third party tool SonarQube . They did not explain that which actual Android smells are detected using these metrics. It is realized that third-party libraries are widely used in Android applications. These libraries facilitate developers but they make analysis of source code and detection of smells challenging.

We elicited source code metrics related to Android code smells from different sources as shown in Table 3. We want to clarify that all source code metrics presented for the detection of object-oriented code smells are not capable to detect all Android code smells. Although, many source code metrics are common for accessing the quality of OO and Android mobile applications. However, there are very few source code metrics that have been proven to work for Android applications such as User Interface complexity, Broadcast Receivers, etc. The source code metrics for analysis of Android applications and detection of Android smells are discussed by different authors.

# 4 Detection Approach
Based on the intensive state of the art in the field of Android code smell detection discussed in Sect. 2, we present our approach in this section. Our approach is capable to detect 25 Android code smells and is flexible for the extension to detect other types of code smells. We used the concept of source code parsing for the implementation of our approach. The definitions of Android code smells, source code metrics and detection rules presented in Sect. 3 are the backbones for the presented approach. The architecture of the proposed approach is given in Fig. 1.

# 4 Source Code Parsing
The source code analysis is the key step for the detection of bad smells using our approach. For this purpose, we used an open source JavaParser for analyzing source code and creating a customized program data model. The program data model consists of the main elements and relations among these elements in the source code. The elements are software artifacts or constructs such as classes, interfaces, methods, fields and relationships. The relationships among these core components are structural or behavioral properties. JavaParser  provides a simple and lightweight set of tools for analysis of Java source code. JavaParser is implemented in Java programming Language.

JavaParser is used for preprocessing of Java source code with visitor methods to visit different components of source code. It is an open source tool available under the Apache License terms and conditions. It is an independent set of lightweight tools used to generate, analyze and process Java source code. JavaParser is the latest commit in the family of Java Parsers and being used in many open source and commercial projects.

JavaParser generates an AST that provides a structural representation of Java source code. It provides an abstract VoidVisitorAdapter with a set of visitor methods in order to visit different components of the source code. All visitor methods are overloaded methods with the difference in their parameters. The prototypes of two visitor methods in VoidVisitorAdapter are given below:
- public void visit (final MethodDeclaration n, final A arg)
- public void visit (final ConstructorDeclaration n, final A arg).

The first visitor method “visit” is used to visit all definitions of methods in a given class and the second visitor method “visit” is used to visit all Constructor declarations in the given class. Similarly, there are 90 visitor methods to visit different parts of source code such as classes, method declarations, field declarations, constructors, loops, conditions, comments, annotations and object creations. JavaParser also provides different individual compilation units used for the analysis of source code by parts given in a string format.

A directory handler named as Directory Explorer is used to iteratively visit all the folders of a given input path. The Directory Explorer filters all Java files from the input set of directories and passes them to Visitor Adapter to visit all.