# 4. Traffic analysis
In the MITM attack tool, we can only get all the traffic intercepted. However, we are not sure which app generates the traffic. In other words, we cannot judge whether the app is vulnerable according to the intercepted traffic only. Therefore, it is necessary to identify which app generates the traffic. We use Android’s VPNService (VPNService, 2020) interface to capture network packets on the client side. Its work flow is shown in Fig. 4. First, an app sends the data to Network Interface Card (NIC) with socket (step 1). Then, NIC sends all data packet to the Virtual NIC (step 2). Next, VPN opens the /dev/tun and reads data from it, and then the packet can be saved or changed (step 3). Finally, VPN sends data to NIC. Sockets used by VPN apps must be explicitly bound to NIC to avoid infinite loop of data packets (step 4). The method is to read /proc/net/tcp and /proc/net/tcp6 files to get the IP of PID and its URLs. The UsageStatsManager class  can get the currently running app’s PID. The PackageManager class  can get the corresponding relationship between PID and app. We thus can get the corresponding relationship between each HTTPS traffic and the app. By comparing the
# Y. Wang, G. Xu and X. Liu et al. / The Journal of Systems and Software 167 (2020) 110609
# 5. Experiments
# 5. Dataset
The dataset in the experiments comes from two app markets. One is 360app, a popular app market in China. We downloaded 1253 popular apps using crawlers in December 2018. These apps belong to 13 subcategories of the “software” category. Another market is Google Play. We downloaded 960 popular apps available in June 2016. The apps from Google Play belong to 18 subcategories of the “software” category. The number of apps under each subcategory is shown in Fig. 5. For each app, we get its apk file, size, developer information and description. In particular, we removed apps larger than 100M in size, because most of these apps are complex games which can cause frequent crashes in dynamic analysis.

# 5. Static analysis
We conduct static analysis on both two data sets. In the static analysis, we use apktool to disassemble apps into Smali file. Some apps cannot be disassembled successfully. In our experiments, 30 apps cannot be disassembled. It took 65 s to analyse per app on average. The results of static detection are summarized in Table 2, that shows that 30 (1%) of 2213 apps from 360app and Google Play cannot be disassembled. There are 457 (20%) apps that have potentially vulnerable code and these apps are considered to have potential certificate verification vulnerabilities. They need further dynamic detection to confirm whether they are really vulnerable. We compared the static detection results with AndroBugs , kingkong (kingkong, 2020) and app-scan (appscan, 2020). The results are shown in Table 3 and Fig. 6. AndroBugs is slightly better than DCDroid in terms of detection accuracy in static detection. However, it generates a big number of false positives without dynamic detection. As for kingkong and appscan, DCDroid is better in terms of detection accuracy in static detection. Besides, they cannot detect HostNameVerifier vulnerability. Both of these two tools also contain a number of false positives. As a result, DCDroid is not the best in static detection phase. However, the major advantage of DCDroid is that we can run the app dynamically and remove false positives. There are 1726 apps that do not have the vulnerabilities we defined. The app size is much larger than itself after disassembling. Therefore, in order to save space, we delete the Smali file after finishing static analysis.

# 5. Dynamic analysis
In dynamic analysis, we use AndroidViewClient to operate two Android smart phones and run apps. On average, each app spends 183 seconds. In the process of running, considering the network speed and other reasons, DCDroid waits 2 seconds for each window to finish loading. If DCDroid does not wait for loading, the detection can be finished faster. However, it’s probably easier to crash. The results of dynamic detection are shown in Table 1. It is seen that 245 apps from 360app and Google Play are identified as having certificate validation vulnerabilities, accounting for 53% of potential vulnerable codes and 11% of all apps. This indicates that 11% of apps in our dataset have certificate validation vulnerabilities. It is worth noting that 8 apps cannot be run dynamically and crashed due to version and other reasons. Because the number is pretty small, we simply consider that they have no certificate verification vulnerabilities. The number of vulnerable apps in each category is shown in Table 1 (including Google’s app and ...

# 8
Y. Wang, G. Xu and X. Liu et al. / The Journal of Systems and Software 167 (2020) 110609
The vulnerabilities detected with different tools.

Percentage of vulnerable app
# 5. Vulnerable apps
Because the app’s version of 360app is relatively new and easy to find all versions, we mainly analyze the vulnerable apps in 360app.

We analyze the vulnerabilities of different kinds of apps in 360app. The percentage of each category is shown in Fig. 7. Among them, News&Books, finance and Health&Medical categories take the biggest percentage. By analyzing these apps, we find that some apps have code vulnerabilities. Besides, many of these apps are vulnerable because they invoke the third-party SDKs that have vulnerabilities, such as pushSDK and the old version of weiboSDK (the new version has been fixed). Another notable finding is that apps developed by the same organization often have similar vulnerabilities, such as SohuNews and SohuVideo which are all vulnerable and developed by the same organization.

We randomly select 30 apps with certificate verification vulnerabilities, and analyze the evolution of 156 historical versions of them. For each application with different versions, we first try to obtain it from application markets. If some of these applications cannot be found, we will try to obtain them from the provider’s official website. If they still cannot be found, we consider they are missing. The results are shown in Fig. 8. The vertical axis is version number (we only select major version updated) and the horizontal axis is the app. The red dots represent vulnerable apps while the green dots represent non-vulnerable ones. The white dots indicate that the related versions do not exist or cannot be found.

We find that most of the apps with low versions tend to have vulnerabilities when a higher version exists. In addition, we find that the apps with lower versions have fewer or possibly no vulnerability comparing with high versions. Through manual analysis, we speculate that one reason is that the low version is released earlier and it may not use SSL/TLS at all, such as #1, #7 app, or early version may be simple and not easy to invoke vulnerabilities.

# Y. Wang, G. Xu and X. Liu et al. / The Journal of Systems and Software 167 (2020) 110609
# 6. Discussion and analysis
DCDroid implements automatic detection of digital certificate verification vulnerabilities with static detection and dynamic detection under the guidance of static detection. Although it has been demonstrated as effective, there are still limitations.

In static detection, we check the vulnerable code, such as the method that only has a simple instruction-return. However, some code may have complex implementation of the method and finally still does not conduct the verification. We cannot check this type of vulnerable code, which may lead to false negatives. Comparing with other tools like AndroBugs, kingkongand and appscan, DCDroid does not show a better result in the static detection phase. As far as we know, the reason is that our detection rules are different. However, DCDroid’s advantage is that we can reduce false positives with dynamic analysis.

In dynamic detection, in order to speed up the execution of dynamic operation, we delete some similar UI components. Although we prove that for most cases this operation will not change the detection results, we still cannot estimate the number of false negatives caused by the deletion. Besides, some dynamic analysis which needs specific trigger conditions (such as login) may lead to false negatives.

The static analysis can be used to detect other vulnerabilities if the detection rules are defined. The dynamic analysis can be used to run apps dynamically in other detection. Of course, it needs specific verification methods like setting proxy in detecting SSL/TLS vulnerabilities. Developers should be very careful during the development and should follow the specifications. In addition, developers should check the security carefully when referencing the third-party library. We use Android 6 as the test platform. However, the tools we use in the experiments are applicable to all Android versions.