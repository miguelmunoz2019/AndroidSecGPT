Similarly, Peng et al.  proposed using crawl models and statistical metrics to compute security risk scores basing on permissions requested by Android apps. The approach they proposed is to rank apps in a market similar to PlayStore based on their risk rate, which has encouraged users to select safer app among applications available with the same functionality with different levels of danger. Afterward, Gates et al.  had improved their previous solution by accurately describing many statistical scores risks using Android permissions to generate probabilities for Android apps. They also exploited all measurements obtained based on critical permissions, such as those allowing access to sensitive software and hardware resources and usually used by malware. Generally, Android malicious applications request critical permissions to exploit the API functions to perform malicious activity against the user. Correspondingly, Gates et al.  used the permissions requested by benign applications to calculate risk scores. However, both solutions have increased the facts of some critical permissions that influence the obtained risk rate values to improve their proposition performance. Indeed, Gates et al. manually selected a set of critical permission consisting of nine permissions that can be used by malware to perform dangerous actions. Similarly, Sarma et al.  proposed to use critical permissions requested by Android applications, but unlike Gates et al. , they choose to rely on the permissions that are rarely required by normal applications for the purpose of recognizing dangerous applications. As well, Grace et al.  implemented an automated system they called “RiskRanker” to check if an application has dangerous behavior or not. To develop this system, they exploited the malicious behaviors commonly used in malware belonging to the same time interval. RiskRanker was used as an initial step before putting the application on
# Security Risk Value Estimate Method
the official Android market “PlayStore”’; RiskRanker has the ability to detect malware by producing a list to classify the suspicious application priority based on their risk value gotten. Besides, Enck et al.  implemented a Java static analysis tool with an aim to decompile applications; due to this tool, they were able to evaluate a large set of applications and study their API usage. However, they only focused on studying applications that use an API call with an unimportant number of permissions. In another study, Felt et al.  manually sort a small collection of Android applications to check whether they are overprivileged or not. But, unfortunately, they were unable to separate between necessary and unnecessary permissions because of the limited documentation provided by Android. Moreover, Barrera et al.  collected 1100 free Android applications and analysed the requested permissions. They primarily focused on the permission system structure, and then they grouped applications together using a neural network and searched for patterns in these permissions. They noted that 62% of applications collected in December 2009 use the Internet permission.

Sharma and Gupta presented in  a novel approach they called RNPDroid for risk mitigation using the permissions analysis. Also, The article written by Razak et al.  has highlighted the significant findings of risk assessment and the risk zone for Android applications through their tool called EZADroid, which implements a permission-based application to determine the risk zone. In addition, Hammad et al.  have developed DelDroid, an automated system for determination of least privilege architecture in Android and its enforcement at runtime. A key contribution of DelDroid is the ability to limit the privileges granted to apps without modifying them. This tool utilizes static analysis techniques to extract the exact privileges each component needs.

Our proposed measure basically relied on Enck’s and Arp’s works. Enck et al.  introduced Kirin, a tool that relies on security rules to simultaneously prevent the installation of malware and allow legitimate app. These rules are developed by adapting requirements engineering techniques to mitigate malware from an analysis of applications, phone stakeholders and system interfaces. So, when a user wants to install an application, the Kirin-based software installer extracts the security configuration from the manifest file. Then, the Kirin security service evaluates this configuration. If it fails to pass all predefined security rules, the installer has two choices. The safest choice is to reject the request. The other choice is to use a user interface to replace the analysis results.

The risk rate identification of dangerous applications with Kirin included five steps:
1. Identification of the assets: in this step, Kirin extracts requested features. For example, if an application requests the permission RECORD_AUDIO, then the asset here is the microphone input.

2. Identification of functional requirements.

3. Determination of goals and threats for security.

4. Definition of security requirements of the asset.

5. Determination of the limits of the security mechanism.

Kirin studies in all those steps the permissions requested by an application in order to determine its nature. We also use the requested permissions in our proposed measure to attribute a risk value to an application. In addition to this criterion, we use other indicators such as API calls, intents, function calls, etc.; similar to Enck et al., we based on malware samples and similarity remoteness in our proposition.

Arp et al.  introduced a lightweight measure they called DREBIN, which can detect and identify malware directly on the device of the Android user. To extract the features of an application such as permissions, API calls and network addresses, DREBIN performs a broad static analysis. Then these features are integrated into a common vector space. The purpose of this geometric representation is to automatically identify combinations and characteristics indicative of malicious applications by exploiting machine learning techniques. DREBIN provides the user with an explanation for each detected application, as well as an overview of the samples of malicious applications already identified.

DREBIN is based on a complete and light representation of applications to determine the indications that characterize a malicious activity according to the following process:
1. Wide static analysis: In this step, DREBIN extracts the set of features included in manifest and dex files of the application.

2. Integration in a vector space: In this second step, DREBIN takes the extracted feature sets and integrates them into a common vector space to geometrically analyse the patterns and the combinations of features related to malicious activities.

3. Detection based on learning techniques: In this step, the learning techniques such as linear support vector machines embedding are exploited in the identification of malicious applications.

4. Explanation: In this last step, DREBIN provides the user with an explanation about the detected application and the list of functionalities responsible for this detection.

In brief, in our proposed measure, we relied on the similarity remoteness proposed by Enck et al. and on the idea of Arp et al. to use extract features from an application and compare them to those that belong to malicious activities, in order to attribute a risk value to unknown applications. Besides the static analysis used by Arp et al., we use a dynamic analysis in our measure to detect the application behavior.

# 3. ISSUE DESCRIPTION
Indicators such as Android permissions, function calls and exploit static and dynamic behaviors can be used in the risk
Section D: Security in Computer Systems and Networks The Computer Journal, Vol. 63 No. 4, 2020
E. Latifa et al.

This will provide the highest relative risk value for an unsecured application, as well as the potential for this malicious application. So, when the user wants to install or just use an application that seems to be suspicious, our proposed security measure employs warning signals to invert the user. In fact, this measure makes it possible to establish the application priorities based on the security risks value found. Therefore, our main goal of this work is to provide a reliable and effective security measure to protect Android users by assigning high-risk rates to malicious apps to easily distinguish them. So, finding a high detection rate for malicious applications from a set of unknown applications is strongly needed to ensure the effectiveness of a risk measure.

# 4. OUR PROPOSITION
Our proposed measure RVC is involved once a user wants to install a new application on his device; our system extracted the various features contained in its APK file in the preprocessing phase. The main concept behind our solution is quite simple, but it guarantees a very interesting results production. Our measure relies on a database that contains a set of Android application representation with their extracted features and their final risk rate. Based on that information, we can get a more accurate representation and a better risk estimate. In our own view, the security risk is directly related to its remoteness from malicious applications when it comes to an unreliable application. Thus, there is a high probability that an application is likely to be malicious, when it is close to all malicious applications samples, because this means that it has the same behavior.

There are two types of features extracted from an application:
- Static: This type of functionality includes permissions, intent filters, Java code, network address and hardware components.