- Broadcast Receiver. It responds to the system’s broadcast messages. The Receiver also operates as a gateway for other app components and sends messages to handle services or activities.

- Content Provider. It provides the ability to share data between Android applications.

# 2 Intercomponent communication
Android separates apps from each other and system resources using the sandbox mechanism as part of the protection mechanism. This separation requires interaction through a message passing system called ICC. Figure 2 illustrates this procedure and shows that the components of two Android apps, Maps and Facebook, can communicate with each other through the ICC mechanism. As depicted in this figure, app components can interact with each other inside the same app or among different apps.

Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License.

# NIRUMAND et al.

The ICC mechanism is done through Intent messages or Uniform Resource Identifiers (URIs). Intent objects provide an abstract description of the app’s capabilities. On the other hand, the component’s capabilities are determined by a set of intent filters specified in the Manifest file. An Intent message specifies an event to perform a specific action with data that supports that action. The components of Activity, Service, and Receiver can communicate with each other via Intent messages. URIs are used to communicate with Content Provider, as a database for an Android app. An Intent message can be addressed to a specific app component, which is called an explicit intent. However, an Intent message can be sent implicitly, which is called an implicit intent. In this type of intent, the component receiving the intent is not explicitly specified.

In the ICC mechanism, components can be invoked through Intent messages at two levels: intra-app (inside the same app) or inter-app (among different apps). As shown in Table 1, the Android framework provides several ICC methods that can be used for sending intent messages. In order to identify these ICC methods, the works of Chin et al., Ma et al., Samhi et al., and Android API reference documentations have been studied. App components can be activated by calling these intent-sending mechanisms like startActivity, startService, and sendBroadcast. Also, some methods are related to sending Intent through PendingIntent and IntentSender objects. PendingIntent, as a wrapper around the Intent, allows the Intent’s action to be performed in the future, even when the original sender app of intent is not active anymore.

# 2 Android access control model
Android access control model is implemented at the level of individual Android applications. In this access model, two types of privileges are considered for app components: 4 (1) ICC that allows a component to interact with other app components in the same or among different apps. (2) Resource access privilege that allows an app component to access resources of the mobile device. As explained in Section 2, ICC is done through Intent messages or URIs. Since the ICC mechanism is mainly done through Intent messages, this paper is focused on the message passing mechanism through intent.

While various mechanisms are considered in the Android access control model, including the Android permission model, this access model does not provide any mechanism to check the security status of the entire system and its applications Therefore, several malicious apps can combine their permissions or take advantage of benign apps’ vulnerabilities to perform activities beyond their privilege. This causes important security issues in inter-app communications, including Intent Spoofing and Unauthorized Intent Receipt attacks described in the following.

# 2 Intent spoofing
In this security attack, the malicious app component can communicate with a public (exported) app component while not expecting such communication. An app component is public if the exported attribute for this component is set to true or if it has at least one Intent Filter. If the victim (exported) app component blindly trusts the incoming (received) intent, the malicious app component can cause the victim component to perform malicious actions This security attack can be three types according to the type of victim app component as follows.

These three types are described:
- Malicious activity launch. This attack occurs when an exported activity of the victim app is initiated by a malicious app component that does not expect such communication. Since the activity component provides the GUI interface, this attack can be used to deceive the user. If this attack is successful, it can modify the background data according to the Intent’s data sent by the malicious component. Also, information leakage may occur via the victim Activity.

- Malicious Service launch: This attack occurs when a malicious app component can start an exported Service of the victim app. This type of attack is similar to a malicious activity launch attack, except that the interaction between the victim and the malicious components occurs in the background. If this attack is successful, the victim service may leak sensitive information or perform unauthorized tasks.

- Malicious broadcast injection. This attack occurs when a public (exported) receiver blindly trusts the intent sent by the malicious component. Since the Broadcast Receiver operates as a gateway for other app components and sends messages to handle services or activities, the malicious intent can propagate throughout the application. As a result, this attack can perform an inappropriate operation on the data from the intent or even run operations that the malicious component is not supposed to trigger.

# 2 Unauthorized intent receipt
In this security attack, the malicious app component can intercept an implicit intent by introducing a filter that matches the sent intent. Therefore, the malicious app component can access all the data on the intent This security attack can be three types according to the type of malicious component These three types are described as follows.

- Activity hijacking. This attack occurs when a malicious Activity component has received the intent. As a result, this Activity is launched instead of the legitimate Activity.

- Service hijacking. This attack occurs when a malicious Service is initiated instead of a legitimate Service. If this attack is successful, it may trigger a false response attack in which the malicious result is returned to the Intent sender.

- Broadcast theft. This attack occurs when the receiver app component can silently read the content of the broadcast intent without any interruption in the Receiver component.

# 2 Model-driven reverse engineering
As a paradigm for software engineering, model-driven engineering (MDE) focuses on creating, manipulating, and using models. These models can describe various complementary aspects of software systems. In MDE, models are considered as first-class entities in the design, development, deployment, maintenance, and evolution of software systems. Therefore, many benefits can be achieved by moving from code-based approaches to model-based ones, including increasing the level of abstraction, increasing problem understanding to better complexity management, and improving the overall efficiency of various software engineering tasks.

MDE is based on three main concepts: model, metamodel, and model transformation. The metamodel determines the possible element types and relationship types of the model that conform to it. Model transformation can be done as model-to-model transformation (e.g., Eclipse ATL) or model-to-text transformation (e.g., Eclipse Acceleo). The first type specifies a mapping from the source metamodel to the target metamodel. The second type, also called code generation, specifies a mapping from the source metamodel to the grammar of the target language.

MDRE takes advantage of the MDE principles and techniques in reverse engineering to develop more effective solutions that facilitate the understanding of software systems. MDRE obtains a set of models from the software system artifacts (e.g., configuration files and source code). MDRE uses models to reduce the structural complexity of software systems. The heterogeneity of the systems decreases with the use of homogeneous models. MDRE can also be directly exploited from MDE technologies and their capabilities, such as generality, extensibility, integration, and coverage. An MDRE process consists of three phases as follows:
- Model Discovery. High-level representations (models) are obtained from software artifacts.

- Model Understanding. The models obtained in the previous phase are understood.

- Model (Re)generation. The generated models in the previous phase can be used to produce new models or to migrate the software system into a new platform.

# 3 RELATED WORK
There exist extensive research work on Android security analysis in general and on security vulnerability detection in particular. In the following, an overview of the researches that are most closely related to our research is given. First, in Section 3, an overview of the studies related to performing program analysis of Android apps for security is provided. Then, in Section 3, the studies related to performing ICC analysis of Android apps for vulnerability detection are described.