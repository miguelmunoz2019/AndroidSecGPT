# 8. Dynamic Dataflow Analysis
Under this concept, privacy disclosure detection is transformed into a dataflow tracing problem: finding viable traces from predefined source APIs (the ones that read private data) to sink APIs (the ones that send private data out). Dynamic dataflow analysis is performed while the app is being executed on real devices or emulated environments, therefore, it is highly resistant to code polymorphism, for example, Java reflection and code encryption (see Section 6).

Past projects using dynamic dataflow analysis have demonstrated precise detection results. TaintDroid [Enck et al. 2010] is the first dynamic analysis engine for Android apps. It performs taint tracking to precisely analyze how private data is obtained and released at runtime. In achieving this, it pioneers an efficient and elegant way to handle taint storage. It also defines taint propagation rules on Dalvik instructions across API calls. As TaintDroid handles taint analysis of Dalvik instructions across API calls at runtime, it is resistant to Java reflection and code encryption. In addition, TaintDroid can be loaded into real devices, allowing for realtime monitoring of actual hardware and sensors. These advantages have pushed TaintDroid to be used widely in Android app behavior analysis. However, TaintDroid cannot support the latest Android ART.

Privacy disclosure means that private data is disclosed outside the device, which could be either legitimate or malicious; whereas privacy leak means private data is leaked for malicious purposes, which is a subset of privacy disclosure.

ACM Computing Surveys, Vol. 49, No. 2, Article 38, Publication date: August 2016.

# Toward Engineering a Secure Android Ecosystem: A Survey of Existing Techniques
# Table VI. Categorization of Proposed Algorithms for Detecting Privacy Disclosure of Apps
runtime, deployed since Android L. Complementing TaintDroid, ARTDroid [Costamagna and Zheng 2016] could be extended to implement the dynamic taint analysis in the ART runtime in the future. ARTDroid is a hooking framework on Android ART runtime without modifications to both the Android system and the app’s code.

It is worth noting that besides the execution engine, the effectiveness of dynamic dataflow analysis relies on two more important components: (1) data source and sink definition, and (2) input generation and test driving. Although both components can be complemented with manual effort, human involvement is certainly impractical for scalability reasons. In terms of automated source/sink discovery, VetDroid [Zhang et al. 2013] leverages the predefined Android permissions for automation. To be specific, it automatically marks the information returned by permission-backed function calls as tainted. SuSi [Rasthofer et al. 2014] uses machine learning techniques to automatically identify data source and sinks in Android APIs with a comprehensive feature set including API method name, return value type, class name, etc. We postpone the discussion on Android app automation tools to Section 8.

Several follow-up works are proposed on the dataflow analysis engine as well: NDroid [Qian et al. 2014] provides a complementary mechanism for taint-tracking information flows through JNI. It interfaces with TaintDroid’s tracking logic on the Dalvik VM side and, in the native context, maintains taint storage using shadow registers and memory maps. NDroid tracks taints by hooking functions through QEMU. To reduce the relatively high runtime overhead of TaintDroid, (32% measured by Enck et al. ), Capper [Zhang and Yin 2014] proposes to instrument the app instead of the Android system in incorporating taint-tracking logic. It employs a byte code rewriting approach to insert code into the original app codebase in order to keep track of private information and detect data leakage. Capper claims to have better runtime performance than TaintDroid.

ACM Computing Surveys, Vol. 49, No. 2, Article 38, Publication date: August 2016.

# 8. Static Dataflow Analysis.

Although modern static dataflow analysis systems have employed many techniques to improve their analysis precision on Java programs, we cannot directly port these static analysis systems to the Android platforms, as Android introduces many unique programming paradigms that need to be handled correspondingly, including:
- Event-driven system. Android is an event-driven system. The control flow of an app is determined by events, and there are many callbacks for system-event handling, for example, UI interaction and location update, which pose significant challenges in building a precise control flow graph.

- Runtime intercomponent communications. Since an app often consists of multiple components with various entry points, complex ICCs flows, including both intracomponent and intercomponent control and dataflows, should be considered. Statically building the control flow graph among components poses a challenge to static analysis techniques.

CHEX [Lu et al. 2012] proposes a static dataflow analysis system to detect component hijacking vulnerabilities in Android. To capture dataflows in multiple components, CHEX first finds all app-splits (an app-split consists of all code segments reachable from an entry point) and then permutes the identified app-splits to find intercomponent dataflows. However, Android OS defines an ordering of lifecycle events for all components in an app. For example, a component can only be stopped or paused if it is started, and may later be resumed. CHEX does not consider such lifecycle; instead, it enumerates all possible app-split orderings, which may introduce a severe imprecision. Epicc [Octeau et al. 2013] reduces the detection of ICC to an instance of the Interprocedural Distributive Environment (IDE) problem. But it also has the same limitation as CHEX. FlowDroid [Arzt et al. 2014] only performs intracomponent analysis and IccTA [Li et al. 2015] extends FlowDroid to analyze intercomponent dataflows. Both IccTA and Amandroid [Wei et al. 2014] focus on ICC privacy leaks and model Android-specific features such as component lifecycle, intent, and callbacks in a precise manner. Such a fine-grained modeling significantly reduces both false positives and false negatives. EdgeMiner [Cao et al. 2015] further improves the modeling of the Android framework with API summaries that describe implicit control flow transitions through the Android framework. DroidSafe [Gordon et al. 2015] represents the latest development in Android static dataflow analysis. It integrates many Android-specific features such as native methods, event callbacks, component lifecycles, etc., into its AOSP model and abstracts them with simplified “stubs” that are accurate enough for point-to and dataflow analysis. It also employs many heuristics to statically model ICC. One drawback, however, is its dependence on manual specifications, which can be error-prone and inflexible with system updates.

In general, static dataflow analysis techniques do not exhibit the low code coverage problem. However, they may run the risk of high false positives, as these techniques tend to conservatively overapproximate point-to targets or model program inputs. In addition, they cannot resist code encryption or Java reflection [Arzt et al. 2014; Lu et al. 2012]. Unfortunately, these features are popular in Android apps, either for self-protection or for performance improvements.

# 8. Hybrid Program Analysis.

Hybrid analysis is a natural direction to balance efficiency, scalability, and accuracy in identifying privacy disclosure. The basic idea is to use static analysis to narrow down the scope of code pieces to be examined at runtime, and then perform dynamic analysis on the identified code pieces.

AppIntent [Yang et al. 2013] uses static analysis to identify relevant code sections to execute. At runtime, AppIntent exhaustively run dynamic symbolic execution to fully
ACM Computing Surveys, Vol. 49, No. 2, Article 38, Publication date: August 2016.

# Toward Engineering a Secure Android Ecosystem: A Survey of Existing Techniques
# 8. Detecting Privacy Leakage
It is noteworthy that sensitive dataflows detected by the aforementioned works are not necessarily suspicious or malicious, as most of them are actually necessary to the apps’ functionalities and should be allowed. Judging the legitimacy of detected privacy disclosures usually requires domain knowledge, and thus is hard to be automated. To the best of our knowledge, only a few papers aim at differentiating suspicious privacy leaks from legitimate ones, and they can be categorized into two classes:
# 8. User Interaction Check
The intuition is that users’ interactions (e.g., users’ consent on the disclosure of location information) should present before private data is disclosed. Livshits and Jung  implements a graph algorithm to place mediation prompts to ask for users’ consent if no user interaction is found. Similarly, AppIntent [Yang et al. 2013] aims to match the sequence of Graphical User Interface (GUI) manipulations with the sequence of events that trigger the private data access and disclosure. AppIntent considers the detected privacy disclosure legitimate only when the user intention, for example, clicking of “send” button to send a Short Messaging Service (SMS) message, is found in the extracted event graph.