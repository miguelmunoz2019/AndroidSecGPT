# Discussion
As observed, from Table 5, nearly 56% of the apps make use of at least one outdated library. It should be pinpointed that around 34% of the apps demonstrate one or more issue with the OpenSSL library, while nearly 22% of them expose a SQLite issue. Even more, 6 apps make use of obsolete versions of both the aforementioned libraries. Overall, the great mass of the problems is with reference to these two key libraries, followed by the OpenCV, Python, and jQuery ones (in that order).

Focusing on each IoT category, the wireless IP cameras category gathers the greater number of issues, followed by the AP one. What seems important to be pointed out is that app vendors for the aforesaid two categories of apps were identified as the most susceptible to a range of CVEs due to reuse of outdated versions of the OpenSSL library. Library issues in the rest of the categories are rather scanty. Clearly, the less affected category is the Smart TV one, but this is to taken as an indication only, given that the number of apps in this category is limited.

# 4. Taint Analysis
Static taint analysis, namely, a form of information-flow analysis, has been also done with the aid of the Ostorlab tool. This type of scrutiny can divulge possible data leakages in the examined code. This refers to an assortment of user or other kind of input sanitization flaws, that may facilitate Intent injection, SQL injection, or Command injection. Taint analysis uses a script, which tags every private data of interest, known as the source. Next, by tracing each source throughout the code, the analyst may become aware of each piece of code that potentially has a leakage, the so-called sink.

Because of the large number of intent-based issues this analysis yielded, we grouped the relevant problems into 3 categories, namely Intent Spoofing, SQL Injection, and Command Injection. As already mentioned in Section 4, Intent spoofing is related to 3 key components of the Android OS, namely, broadcast receivers, services, and activities. By appropriately sanitizing these components in the manifest file, leads as a matter of course to fewer leaked intents. SQL and Command injections on the other hand are rooted in more specific and potentially perilous weaknesses that need to be deracinated in a more urgent way.

# Discussion
From an IoT category perspective, as distinctively shown in figure 6, the great mass of problems is with reference to Intent spoofing, as it was found to be applicable to more than 63% of the apps. Additionally, AP and Smart TV apps were the most affected to Intent spoofing, with 89% (or 8 apps) and 100% (or 2 apps), respectively. It should be noted, that the remainders of the identified issues pertaining to Intent spoofing represented no more than 50% of the examined apps per category. It should be pinpointed that SQL injection and Command injection potential vulnerabilities were scarce among the examined apps; only 5% (or 2 Smart assistant apps) and 3% (or 1 AP app) were found to be susceptible to these issues.

# Sensors 2022, 22, 513
The Y axis designates the amount of issues per app.

# 5. Dynamic Analysis
For the needs of dynamic analysis, we used a Genymotion rooted VM on top of an Oracle’s VirtualBox on Android v8. Currently, this is the latest version with an ARM translator (https://github.com/m9rco/Genymotion_ARM_Translation (accessed on 10 October 2021)). The latter is capable of installing Android apps without the need of Google Play Store; this avoids having all apps installed at the same time. After an app was analyzed, it was uninstalled, therefore, only a single app was installed in the VM each time. Moreover, MobSF was utilized as a dynamic instrumentation tool, which handled the dynamic analysis procedure. To achieve this, MobSF utilizes the well-known Frida server. It is to be noted that this section only concentrates on specific aspects of the apps, namely files containing sensitive information and network traffic. This means that we did not exhaustively exercise each app, say, through an app exerciser like Monkey, but we manually interacted only with the functionality an ordinary user will most probably utilize depending on the specific app type.

Another relevant issue has to do with Bluetooth connectivity, given that Genymotion (as with any similar VM) does not offer Bluetooth compatibility. Therefore, for the devices that required a Bluetooth pairing before being associated with the Android app, we paired the targeted IoT device with a user account, and then that account was used to obtain access to the device from the VM via a Wi-Fi connection. However, as shown in Table 1 some apps provide only Bluetooth connectivity. For these apps, we manually entered a set of representative measurements.

For connecting the VM to the Internet, the adb shell settings put global http_proxy :0 command must be used (https://github.com/MobSF/Mobile-Security-Framework-MobSF/issues/1239 (accessed on 10 October 2021)). It should be noted that each IoT device was paired only with one app. Overall, the dynamic analysis is quite different per each IoT category based on two factors. First, by having already the results of static analysis, it was easier to discern the set of apps that presumably will yield a significant number of issues in the context of dynamic analysis. Second, from a consumer’s viewpoint, we cherry-picked the most popular apps along with a set of IoT devices, from each category. Overall, 13 different IoT devices were utilized: 6 APs, 3 wireless IP cameras, 3 Smart assistants, and 1 Smart bulb.

# 5. Access Points
For this category of devices, we tested 6 apps, namely, ASUS Router, D-Link WiFi, Linksys, Mi Wi-Fi, Netgear Nighthawk, and TP-Link Tether. The respective contemporary AP models were ASUS RT-AX88U, DIR-X1860, MR7350, AX1800, RAX40, and AX10v1, respectively. Excluding legacy or common Wi-Fi vulnerabilities [36–38], for such devices, an essential concern is the protection of the Wi-Fi passphrase, i.e., the key(s) to connect to the Wi-Fi network. Another major concern is the safeguarding of the user credentials used to connect to the AP’s web-based management interface. Under this prism, the dynamic analysis of these apps concentrated on searching for files where such credentials may be kept by the app in cleartext form.

- ASUS Router—This app uses the Link Layer Discovery Protocol (LLDP) to learn about and subsequently communicate with new APs. Following the first successful user login through the AP’s web-based management interface, the app keeps in its cache the administrator’s credentials. That is, the cleartext credentials are stored in the datadatacom.asus.aihomedatabasesrouterprofile file. It is noteworthy that this app uses an HTTP connection to communicate with the AP.

- D-Link WiFi—This app uses an HTTPS connection to communicate with the router. It was perceived that the passphrase of the 2 GHz wireless interface is stored in plaintext form by the app in the datadatacom.dlink.dlinkwifishared_prefsROUTER_LIST.xml file.

- Linksys—For some imperceptible reason, this app was unable to discover the AP in the Wireless LAN network; note that the app uses the Internet Group Management Protocol (IGMP) to identify the AP. Therefore, to bind the AP with the app, we manually created an account. The communication between the app and the AP is done over HTTP. It was perceived that the datadatacom.cisco.connect.cloudapp_webviewLocal_Storageleveldb000005.ldb and datadatacom.cisco.connect.cloudapp_webviewLocal_Storageleveldb000026.ldb files contain in plaintext form both the 2 and 5 GHz Wi-Fi passphrases, with the former to also include the user’s email address. Another app file that stores the user’s email address in plaintext is the datadatacom.cisco.connect.cloudapp_webviewLocal_Storageleveldb000024.log. The auth token of the app (it is used to authenticate the user against the back-end) is stored in a JSON file; however, there is an expiration time of 7 days. No less important, the email address of the user can be also exposed through the Logcat command-line tool. Recall that Logcat can be executed either as an adb command or directly in a shell prompt of the emulator or connected device.

- Mi WiFi—It was observed that this app dumps sensitive information in the Logcat output. The exposed data include the session key the app uses to authenticate itself against the AP and the Wi-Fi passphrases for both the 2 and 5 GHz bands, all in plaintext form.

- Netgear Nighthawk—This app required the user to first create an account. Next, the app scans the wireless LAN network for a supported device; scanning is done over HTTP. After a device is found, the app prompts the user to enter their credentials for connecting to the AP’s web management interface. The analysis performed shows that the app holds in the datadatacom.netgear.netgearupshared_prefsDataModelLocalStorage.xml file the Wi-Fi passphrases for both bands in a plaintext form. Moreover, the datadatacom.netgear.netgearupshared_prefsLAST_SESSION_PREFERENCE.xml file includes the email address of the user. Through Logcat, the app exposes the Wi-Fi passphrases of both bands and the administrator’s username. Last but not least, the datadatacom.netgear.netgearupdatabasesnetgear_up_database.db database file stores the details of any device associated with the AP in the past. These pieces of data include MAC addresses in a plaintext form.