# Hindawi
# Security and Communication Networks
Volume 2022, Article ID 3923690, 12 pages
https://doi.org/10/2022/3923690
# Research Article
# A Secure Communication and Access Control Scheme for Native Libraries of Android Applications
Pengju Liu1, 2, Guojun Peng1, 2, and Jing Fang1, 2
1Key Laboratory of Aerospace Information Security and Trusted Computing of Ministry of Education, Wuhan University, Wuhan, Hubei 430072, China
2School of Cyber Science and Engineering, Wuhan University, Wuhan, Hubei 430072, China
Correspondence should be addressed to Guojun Peng; guojpeng@whu.edu.cn
Received 5 March 2022; Revised 22 March 2022; Accepted 29 March 2022; Published 8 April 2022
Academic Editor: Muhammad Arif
Copyright © 2022 Pengju Liu et al. This is an open access article distributed under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.

The Android system cannot perform fine-grained permission management for TPLs (third-party libraries) in applications. TPLs can use all permissions of the host application, which poses a threat to users and system security. In order to solve this problem, this paper studies the underlying principles of multiple modules in the framework and kernel layers of the Android system. We construct a fine-grained access control scheme for native libraries through technologies such as isolation environment creation, remote function call, and dynamic permission management. We also implement the prototype system. The experimental results show that our proposed scheme can effectively assist developers in managing the permissions of the native libraries in a fine-grained manner and curb the suspicious privileged behaviors of the native libraries. Meanwhile, our proposed scheme is adaptable for high-version Android systems with reasonable overhead, and it will not break the current Android security mechanisms.

# 1. Introduction
TPLs are essential in the field of mobile application development. Developers can save significant costs by using TPLs. According to statistics, an average of more than 60% of the codes of Android applications come from TPLs. And in the context of the IoT (Internet of Things), in addition to smartphones, many other IoT devices are also based on Android. Therefore, it is essential to ensure the security of TPLs of the Android system.

Many studies[2–5] show that TPLs can steal private user data or device information in the background. Among them,  states that more than 40% of TPLs pose a threat to user privacy. Although Android system offers lots of access control mechanisms such as sandbox, permission model, AppOps, and SELinux, the granularity of these mechanisms is at the application level, which cannot further manage TPLs within the application. There is no security boundary between TPLs and the host application, so all permissions of the host application can be used by TPLs directly. This is the core reason for the threat of TPLs.

The solutions to the problem mentioned above can be summarized into two categories. The first is to isolate the TPLs to run in an environment outside the host application. The TPLs can no longer share the permissions of the host application and thus can only access limited system resources or user data[10–15]. For example, CompARTist splits Android applications at compile-time into isolated, privilege-separated compartments for the host app and the included TPLs. Adcapsule aims at the advertising libraries, which can make Ad libraries run independently. The second approach is to design a more granular permission mechanism that restricts the interaction between TPLs and resources. For example, FLEXDROID, Zhan et al., LIB CAPSULE, and others enable the Android system to manage TPLs permissions directly by implementing library-level access control mechanisms.

There are many approaches to address the TPLs permission problem. However, none of these approaches have been applied in practice, and Android users still suffer from the aforementioned problems. This is mainly due to the following three reasons. First, TPLs are usually written in
# Security and Communication Networks
Java, the same language as the Android development. But due to Android’s support for JNI (Java Native Interface), TPLs can also be written in Native language, often called Shared Libraries or Native Libraries. In the past, Native Libraries were usually only used to implement some computationally intensive functions due to the performance limitations of mobile devices. However, as the performance of mobile devices improves, Native language is used significantly more frequently in TPLs. As Zhan et al.  state, most existing tools can only handle Java TPLs. Still, Native code has the same access rights as Java code, so many approaches can be bypassed by Native languages, which is no longer relevant today. Second, Google releases a new version of Android every year, and as of today, there are 12 major system versions of Android. These versions differ in many places, which results in that all approaches can only be deployed on specific versions. As far as we know, the highest supported system version among these approaches is Android 9. According to the latest statistics  of Android Studio, Android 10 and above system versions account for more than 50%. In other words, the current approaches can only run on a maximum of 49% of devices. Third, developers using third-party libraries intend to reduce their development costs. Still, many approaches require developers to modify their application bytecode and even the TPLs code. This runs counter to the developers’ intent of using TPLs. These three reasons combine to make the state-of-the-art approaches not very practical. Therefore, we need a practical solution to manage Native library permissions in a fine-grained way.

To solve the permission problem of the shared library, a security-enhanced mechanism for the Android system called SEBox (Security-Enhanced Box) is proposed in this paper, which can run application’s shared libraries in a low-permission isolated environment. Compared with the previous work, this mechanism does not require rewriting the code of applications or the shared library and can dynamically manage the permissions of the shared library. It is also compatible with the Android ART (Android Runtime) virtual machine. In this paper, the prototype system is implemented based on Android 10. Experiments are conducted to verify the functionality of SEBox and the reasonableness of the performance overhead. In the process of SEBox implementation, there is no need to modify the Android sandbox mechanism and the permission model. SEBox will not break the security mechanism of the stock Android system, so it is a security-enhanced mechanism for the Android system.

In summary, this paper makes the following contributions:
- (i) We propose a scheme called SEBox to restrict the behavior of Native libraries in Android applications. To the best of our knowledge, SEBox has the highest Android system version support compared to other work.

- (ii) We have implemented a prototype of SEBox, which focuses on restricting operations in Native libraries using techniques such as isolated environment creation, remote function calls, and dynamic permission management. Developers can conveniently deploy SEBox without any modifications to their application bytecode.

- (iii) We evaluated our scheme on real Android devices, including effectiveness and performance tests. The evaluation results show that our scheme can completely limit the privileged behavior of Native libraries in Android applications with a low-performance overhead.

This paper is organized as follows. Section 2 introduces the threat model and the overview of our scheme. Section 3 introduces the necessarily related technologies. Section 4 systematically describes the scheme design and implementation details. Section 5 provides an experimental evaluation of our scheme, including effectiveness testing, performance testing, and comparison of similar works. Section 6 discusses the limitations and possible improvements of our scheme. Section 7 concludes this paper.

# 2. Scheme Overview
# 2. Threat Model.

The threat model discussed in this paper is shown in Figure 1. The host application is trusted because any sensitive behavior requires the user’s consent before being performed. As shown in Figure 1, before the host application can access data such as photo albums, it must be authorized with the user’s consent. TPLs are untrusted due to the following reasons. First, TPLs have the necessary conditions to obtain sensitive data covertly. In the Android system, applications can access system services through APIs, and some sensitive information-related APIs are protected by permissions. However, the permissions are based on the application sandbox, and the TPLs run in the same sandbox as their host application. This means that the TPLs have the same permissions as the host application. Therefore, TPLs can directly use the permissions of the host application without any restrictions. Second, TPLs have the motivation to obtain sensitive data. Take the advertising library as an example. To push ads more accurately, they want to get as much information about the user as possible. Third, the codes of TPLs are usually not visible to the application developers, and most developers do not pay attention to the implementation of TPLs. Therefore, malicious code can be easily and covertly inserted into TPLs.

# 2. Architecture of SEBox.