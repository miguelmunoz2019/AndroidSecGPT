# 5 Static Analysis
To detect whether an app is vulnerable to proposed attacks, we construct a program dependence graph (PDG) of the app . The PDG consists of the control flow dependencies and the data flow dependencies of the app. To construct a PDG, we collect possible entry points in the app. As Android apps do not specify the entry points (e.g., main method for Java application) for execution, we collect the entry points of an app from two parts : (1) lifecycle methods in Android components (e.g., Activity). We focus on lifecycle methods of components as they are the standard entry points to the app. Through them, developers can manage the app’s components and their behaviors; and (2) UI callbacks. Android allows developers to register UI callbacks for monitoring certain events. For example, the method onClickListener is invoked once a button is clicked. In practice, we leverage EdgeMiner  to collect all possible entries for a given app. If the app employs obfuscations or packer to protect its bytecode, we will use deobfuscators (e.g., TIRO ) and unpackers (e.g., PackerGrind ) to recover the hidden bytecode for analysis.

Next, we build the app’s PDG by using FlowDroid , and further extend the PDG to a UI-oriented PDG named UPDG, which models the dependencies and transitions  through UI elements (e.g. TextView). A node in UPDG is defined as:
𝑛 = {𝑢𝑖𝑑, 𝑢𝑡𝑦𝑝𝑒, 𝑎, 𝑐, 𝑜},
in which the 𝑢𝑖𝑑 represents the UI element’s id. The UI id can be retrieved from the layout files. 𝑢𝑡𝑦𝑝𝑒 represents the type (e.g., TextView) of the UI element. 𝑎 represents the Activity context, which means the UI element 𝑢𝑖𝑑 is used in the Activity 𝑎. 𝑐 represents the callback method with the element. 𝑜 represents the node in PDG.

To construct the UPDG, we first parse all layout files and the manifest file in the app. From layout files, we extract all UI elements, including text content, name, id (𝑢𝑖𝑑), and type (𝑢𝑡𝑦𝑝𝑒). Then, we match the UI elements with the original PDG nodes. To realize this, we search the statements that are related to UI reference or initialization with findViewById. For example, the statement findViewById(R.id.btn) can be used to refer to the UI element with id btn. Next, we analyze the UI callbacks (e.g., onClickListener) that are associated with these UI elements. Then, we retrieve the Activity context (𝑎) and the corresponding callback (𝑐) for a node 𝑛 in UPDG. Last, we append data flows introduced by the inter-component communication (ICC) via implicit Intents  to the UPDG. To capture them, we leverage IC3  to locate the source and sink for all Intents in the app. IC3 transforms the ICC problem into a Multi-Valued Composite (MVC) constant propagation problem (i.e., finding all possible values of objects concerned at a particular program point). IC3 specifies the MVC constant propagating problem with the COnstant propAgation (COAL) language and then employs a COAL solver to solve the problem. IC3 infers the arguments in an Intent and then finds the target component. We append the data flows introduced by Intents to the UPDG.

# 5 Detecting Link Hijacking with STS
In practice, we leverage the workflow defined in Fig. 9 to check whether an app is vulnerable to this attack. To be exact,
- If an app contains EditTexts (the text can be edited in an EditText), we check the followings: 1) if the text is a password, phone number,
# ESEC/FSE ’20, November 8–13, 2020, Virtual Event, USA
# Yutian Tang, Yulei Sui, Haoyu Wang, Xiapu Luo, Hao Zhou, and Zhou Xu
time, or date, the text cannot be visible or cannot be a valid URL. For example, the text in an EditText whose input type is password can not be visible (all characters are presented by “•”); 2) some approaches can be used for preventing users from using STS (e.g., use setMovementMethod(null)). These approaches are introduced in §7 in detail. We exclude all these cases as they prohibit users from using STS.

• If an app contains TextViews (a.k.a labels), we check the followings: 1) whether the TextViews can be selected by tracking the setTextIsSelectable(true). If and only if the method setTextIsSelectable(true) is invoked, the text on a TextView can be selected. If the text on the TextView cannot be selected, the attack cannot be launched. It is worth mentioning that by default the text on a TextView cannot be selected; 2) if the content in a TextView is a URL, it can be hijacked with STS; and 3) if the content in a TextView can be changed to a URL, it can be hijacked with STS. For 3), we check all the onClickListeners on TextViews in the app to evaluate whether the content on TextViews can be changed to URLs. Besides, we also check all callbacks and onClickListeners in the app to evaluate whether the content on TextViews can be changed to URLs.

# Implementation
In practice, we transverse the UPDG to find whether any UPDG node that invokes the APIs mentioned above. For a node in the UPDG that is associated with a UI element, we track the node through the UPDG graph to collect all operations performed and allowed on the node. Then, we check whether the node satisfies the conditions in Fig. 9. For example, the expression writtentext=(EditText)findViewById(R.id.editText1); defines a EditText object writtentext. The writtentext is also associated with a UI element whose id is editText1. We track the usage of this node (i.e., writtentext for simplicity) on the UPDG to find other settings for this object. All settings and operations defined on writtentext are then collected. We leverage the workflow in Fig. 9 to evaluate whether attacks can be launched with this node. If so, the app is considered to be vulnerable.

# 5 Detecting Link Hijacking without STS
To determine whether an app is fragile to link hijacking without STS, we use the checking diagram in Fig. 10.

• First, we check whether the app uses any Intent in the code. • Second, if the app launches a URL with the Intent, we then check whether the app is a browser or contains an in-app browser. • Third, if the app is not a browser or does not implement any in-app browser, the app is vulnerable to the link hijacking attack without STS.

# Implementation
We first iterate the UPDG to check whether the app launches any Intent. First, we track and locate all Intent objects in an app. There are two types of Intents: explicit and implicit Intent. For explicit Intent, the target of the Intent is defined in the Intent object by specifying the package name. However, to launch a URL, the type of the Intent must be implicit. To launch a URL with an Intent, the data field is set to the target URL. Therefore, we first locate the Intent objects in the given app. Next, we leverage the taint analysis  to track the setting of the data field of these Intent objects. If the data field is set to a URI (by tracking the type), then we can confirm the app uses an Intent to open a URL.

The next step is to detect whether the app is a browser or contains an in-app browser. To do this, we traverse the UPDG to detect whether there is an instance of WebView or an instance of type A where A is a subclass of WebView. If an app is a browser or implements an in-app browser, the attack cannot be launched.

# 5 Detecting Instant App Hijacking
As presented in Sec. 4, the malicious instant app can hijack other instant apps that have larger package names in terms of dictionary comparison. Therefore, all instant apps are vulnerable to this attack, as long as the malicious instant app has a deliberately designed package name.

# 6 EVALUATION
# 6 Evaluation Overview
Apps & DALs To evaluate whether real-world apps are vulnerable to three types of attacks, we crawled 200,000 apps from Google Play and 200,000 apps from Tencent Myapp (the largest third-party app market in China).