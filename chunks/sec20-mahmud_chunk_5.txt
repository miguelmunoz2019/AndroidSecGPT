We ran Cardpliance on the 442 applications that request payment information. We performed the analysis on a virtual machine running Ubuntu 18 on the VMware ESXi 6 hypervisor with an Intel(R) Xeon(R) Gold 6130 2GHz machine with 320 GB RAM and 28 physical cores.

Keyword list: credit card number, card number, cardnumber, credit / debit card number, credit or debit card number, payment card number, credit card number on our order form, credit card number on our registration form, credit-card number, credit / debit card number, credit or debit card number, customer credit card number, credit card / debit card number, credit card account number, credit and debit card number, debit card number, valid credit / debit card number, digit card number, cc number, credit card, debit card, master card, mastercard
3
# Runtime in minutes
0
50
100
150
200
250
300
350
400
Cardpliance was configured to run 15 applications in parallel and set a 60-minute timeout per application component. If a timeout occurred when analyzing a component, we discard the results for the entire application to avoid partial results. In total, Cardpliance successfully analyzed 80% (358/442) of the triaged application dataset. Of the 19% (84/442) applications that failed analysis, 3% (17/442) applications contained components that exceeded the timeout and 15% (67/442) applications could not run due to errors in the underlying static analysis framework Amandroid.

# Finding 1
At least 2% of popular free Android applications on Google Play directly request payment information. As discussed above, we used a lightweight heuristic to identify which applications were mentioning credit card numbers and then used UiRef to resolve semantics. We found that 442 applications contain input widgets that directly request payment information from users (i.e., credit card numbers). This reduction in the scope of analysis makes deploying the deeper and more time-consuming static analysis checks provided by Cardpliance feasible at scale. Note that this is a conservative lower-bound estimate, as we could not analyze 917 applications due to errors in ApkTool and UiRef.

# Finding 2
Cardpliance can analyze an application with a mean and median runtime of 334 minutes and 179 minutes, respectively. Figure 2 plots the runtime versus the number of components within an application. Note that the x-axis consists of the 358 applications sorted in ascending order based on the number of components within the application. The component counts within applications ranged from 0 to 315 components where 54 was the average number of components per application. As shown in Figure 2, an increased number of components within an application generally resulted in a longer runtime. Further, it saturates after the 170th application where there were 40 components. The mean and median runtime for applications was 334 and 179 minutes per application, respectively.

Cardpliance’s runtime significantly increased over the stock version of Amandroid due to the inclusion of frequently used user input sources and sinks, such as Activity.findViewById(int) and View.setText(). For example, an application may only have the source TelephonyManager.getDeviceID() once within the application, but it may likely have the source Activity.findViewById(int) multiple times throughout the application, which significantly increases the number of sources that require tracking. Therefore, in order to scale Cardpliance to an entire market, a lightweight keyword-based filter is required. Note that if the filter is not comprehensive, non-compliant applications may not be discovered. We discuss this limitation further in Section 5.

Finally, as discussed above, Cardpliance successfully analyzed 358 applications. Those 358 applications spanned 32 application categories with the majority coming from the FOOD_AND_DRINK (51), SHOPPING (43), FINANCE (39), and MAPS_AND_NAVIGATION (37). The average download count for these applications was 1 million downloads and an average rating of 3 stars out of 5. The most popular application Wish - Shopping Made Fun (com.contextlogic.wish) in the group had over 100 million downloads. The dataset consisted of other widely used applications, such as Lyft (me.lyft.android), CVS Caremark (com.caremark.caremark), and the WWE application (com.wwe.universe).

# 5 Validation Methodology
We opt for manual code review instead of manually running the application due to complexities of reaching screens that request payments (e.g., creating accounts that require disclosure of sensitive data, requiring referral codes, or relying on an existing balance/debt). The manual code review for validation was performed by one student author of this paper, who has more than 6 years of academic and industrial experience programming Java and developing Android applications. For each candidate application flagged by Cardpliance, we begin by decompiling the application with the JEB decompiler to obtain the source code. We then group the data flows that were marked as potential PCI DSS violations by the PCI DSS requirement that it violated from Section 4).

The goal of validation is to verify that the data flow actually occurs within the code and was not a false alarm due to the imprecision of the underlying tooling. Note that for all of the validation checks, we stop verification if we discover that the result is a false alarm and begin validating the next data flow within the PCI DSS requirement group. If all of the data flows within the PCI DSS requirement group are erroneous, we mark the application as a false positive for that PCI DSS requirement group. However, if we successfully validate the data flow, we mark the application as containing a PCI DSS violation and start analysis on the next PCI DSS requirement group for that application.

We begin by validating whether the semantics linked to the input widget of the data flow was correctly resolved by UiRef. We start at the source of the data flow (e.g., Activity.findViewById(int) method) and resolve the integer parameter of the method invocation to the resource identifier in the R.java file.

USENIX Association 29th USENIX Security Symposium 1525
of the source code. We identify in the input widget referenced by the resource identifier within the source code and validate that UiRef made the correct resolution of semantics (i.e., credit card number, CVC). If UiRef was incorrect, we mark the data flow as erroneous and begin validating the next data flow for that requirement group. If UiRef resolved the correct semantics, we continue the following validation process.

Next, we trace through the source code from the source of the data flow to the sink to determine that the data flow exists within the source code. For example, if the data flow denotes that non-obfuscated credit card numbers are being stored, we verify that the data retrieved from the input widget accepting credit card numbers is actually written to disk without being encrypted or through some other obfuscation library. If the data flow does not occur within the source code due to imprecisions of static analysis, we mark it as an error and continue analysis as discussed above. For example, we found that the Context object of the Activity.findViewById(int,Context) method was frequently tainted and led to imprecision.

Finally, for validating potential SSL vulnerabilities that lead to insecure transmission, we searched for SSLSocket-Factory and TrustManager classes within the source code and manually checked whether the implementation was performing improper certificate validation. We then searched for the use of those classes throughout the source code and determined whether payment information was sent over connections using these vulnerable classes.

# 5 Compliance: The Good
In this section, we report the positive findings from our analysis of the 358 applications analyzed by Cardpliance. We believe that these findings provide significant value and insight to the community.

Finding 3: Around 98% of the 358 applications pass Cardpliance’s PCI DSS compliance tests. Out of the 358 applications, Cardpliance identified that 318 applications did not violate any of the PCI DSS compliance checks. After manual validation of Cardpliance’s findings, we found that 352 applications in total were not violating any PCI DSS check that we modeled. This result in itself is surprising due to the vast amount of prior research that highlights the poor state of Android application security . The fact that our tool reporting 98% of applications in our dataset handling payment information are maintaining these data security standards shows that the risk of financial loss due to insecure behaviors in mobile applications might not be as wide-spread. Further, as the majority of applications seem to be handling payment information correctly, it demonstrates that securely processing payment information and meeting PCI DSS requirements within a mobile application is largely an obtainable effort.