Android OS provides a built-in digital certificate verification method, which is not vulnerable. However, it also allows developers to implement their own certificate verification method (Android Developer Training ´ 2020; Elenkov, 2014; GnuTLS s, Transport Layer Security Library, 2020). The reasons that developers rewrite certificate verification methods include: using self-signed certificates, servers’ root certificate is not in Android’s CA list, correcting the unsafe implementation of some third-party libraries  and so on. However, in the process of implementation, vulnerable certificate verification methods are often introduced for various reasons, including :
- Trust all certificates with the X509TrustManager interface;
- Domain name is not checked by HostnameVerifier;
# 2. Android UI
Activity  is a visual interface used by Android to interact with users. An app may consist of one or more Activities. The Activity used by the app is defined in Android’s AndroidManifest.xml file. In particular, the Activity entered at the start of the app is called Main Activity. Activity manages Views with Windows. A View refers to editable components (such as text boxes), clickable components (such as buttons) and static components (such as labels). Service has no interface, and it will be executed in background. For example, Service can get data from the network or perform some computational tasks while users are dealing with other tasks. Intent is an object that holds the content of a message. It describes the operation that Activity wants to perform, and contains the data needed to start the next Activity. It is used to jump to another Activity from this Activity.

We regard the interface as a directed graph, in which the nodes represent Activity or Service, the edges represent intent. Running all activities means the traversal of the graph starting from Main Activity nodes. By incorporating the UI into a graph, the automation algorithm of UI can be implemented more conveniently.

# 2. Android network and MITM
Each app has a unique process ID called PID. PID and IP are saved in a file during the network connection. Besides, Android OS provides an interface called VPNService, from which URL and IP can be obtained. The corresponding relationship between PID and apps’ name can be obtained from Android OS, too.

In a MITM attack, the attacker is in the middle of client and server’s communication. The attacker can intercept the client’s message and send the intercepted message to the server. It can also intercept or modify the server’s message and impersonate the server to communicate with the client. Before communicating, it can send a certificate containing its host name to the client. If the client does not verify the certificate or verify the certificate without checking the host name of the certificate (because the certificate of the middle-man may also be signed by Certificate Authority (CA)), the middle-man can constantly intercept, eavesdrop on and even modify the message.

# 3. Problem statement
In this section, we introduce the main challenges in this work.

# 3. How to define potential vulnerable code and trigger them
Because it is time-consuming to run apps dynamically, we first need to determine which apps contain vulnerable SSL/TLS implementation. We eliminate some apps by static detection and provide guidance for dynamic detection. We need to pre-define vulnerable code. If the selected SSL/TLS vulnerable code is not representative, it will result in false negatives. The definitions of vulnerable code are limited in previous work, and the coverage of vulnerable apps is not comprehensive enough. Therefore, we need to analyze the typical vulnerable apps and extract the common features of all the vulnerable codes as the basis of static detection. On the one hand, the challenges are how to define the detection rules by analyzing vulnerable codes. On the other hand, the code we find may not be executed. The code may be test code only and is not really invoked in the process of running, or the code may be executed through system callbacks and will never be executed. In order to determine whether the code is actually executed, we need to trace back the vulnerable code to find which Activity executes it. However, if we start Activity that we find directly, the program may crash with high probability. Therefore, we need to find a path from the Main Activity to the entry Activity, and then execute it sequentially. Finally, it can be confirmed whether there is a real vulnerability through the MITM attack tool.

# 3. How to simulate human operations
To simulate human operations, DCDroid needs to understand the UI elements on the current screen and provides the necessary operation. For example, text boxes need to input content and radio boxes need to check. It then selects the special UI elements to click according to the results of static analysis. Existing tools are not suitable for our UI automation, such as MonkeyRunner  whose execution has no special purpose and mainly relies on random clicks. Therefore, it is difficult to trigger vulnerable code. Another automation framework Appium (appium, 2020) can use specific scripts to run UI elements precisely. However, it has no commonality and needs to be customized for each app. Some other automation tools, such as FlowDroid  and DroidScope (Yan and Yin, 2012), can track method call relationship. However, they cannot trigger dynamic vulnerabilities. Dynodroid  focuses on processing automatic input. In contrast, Smart Droid  and Brahmastra  cannot deal with Web UI.

DCDroid that we developed is an automatic tool for UI elements based on AndroidViewClient . It can get all UI elements on the screen and execute click events on a specified UI element, etc. It can also run UI elements with potential vulnerable code first.

# 3. How to run efficiently
If all the UI elements associated with vulnerable code are executed, the running time is very long. We find that similar UI elements tend to have the same implementation logic. The Activity always has many similar elements for which we can select a part of them to execute. However, some elements are similar in size but are not a collection of the same implementation, such as various tabs. For example, Fig. 3 shows an app of delicious food. The four different tabs (green box) above it represent different contents, while the sub-menus (red box) of each category tab represent the same contents. The difficulty is how to select elements by appropriate methods so that the execution speed can be accelerated without impacting the accuracy of detection results.

# 3. How to run effectively
While much existing work focused on how to run apps stably, there is no effective tool to identify the traffic generated by apps. As some apps are run in background and some apps start another app in the process of their running, the traffic collected is not always generated by current active apps. Although DCDroid will return to the app we are running when starting another app, some other app’s traffic will be mixed inevitably. Therefore, the traffic obtained by MITM attack tools may not be generated by current app. For instance, the traffic may be generated by other apps which are running in the background. How to precisely extract the traffic generated by each app from the mixed traffic is a challenge.

# 4. Our method
In this section, we first introduce the framework of our method, then describe the static detection process, and finally introduce the dynamic detection process.

# 4. System overview
An overview of DCDroid is presented in Fig. 1. Given an app, we first conduct static analysis. We disassemble the app to get the Smali file and then locate the vulnerable points according to the characteristics of the vulnerable code. By analyzing the method call relationships, we get the vulnerable entry Activity. We then start dynamic detection, install the app into the smart phone with the ADB management tool and start to run the app to trigger the potential vulnerable code. We intercept traffic with MITM attack tools and use VPNService to capture traffic on smart phones. Finally, we confirm those true vulnerable apps by comparing the traffic between the smart phone and the attack tool.

# 4. Static analysis
# 4. Disassembling apps
Android apps can be decompiled into Java code or disassembled into Smali code directly. We choose to disassemble an app into Smali code because we only need to analyze the call relationship of the code without knowing its design. Smali code can be disassembled faster and is less affected by confusion technology. It can be done with apktool (android apktool, 2020). Androguard  can analyze its call relationships.

# 4. Vulnerable code analysis
Based on existing related work  and disassembling 100 typical vulnerable apps manually, we propose 4 types of vulnerable code. The number of each type among 100 apps is shown in Table 1. A typical vulnerable code is shown in Fig. 2. As shown in the figure, the vulnerable method returns void directly without any check.