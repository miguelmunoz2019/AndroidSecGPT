For the communication between MA and MS, we only consider the situations of HTTP, insecure HTTPS (without certificate validation), and secure HTTPS. Our purpose is to find out the network connection of the exact step when MS returns orderp / TN to MA is secure. Since our result needs high accuracy, we manually trigger the MA to the step and monitor the network traffic.

Since Apple introduced “App Transport Security”, which defaults apps to requiring an HTTPS connection, our detection to this security flaw mainly focus on Android apps. The limitations of automated analysis methodology to detect insecure network communication for Android apps is so serious that lead to high inaccuracy. The key difficulty is that how to find the URL connection related to the step that MA and MS transmit the transaction information accurately. Among a variety of URL strings in apps, it’s quite impossible to decide which URL is responsible for transmitting the order/transaction information only by name. In addition, it is common for apps to join several substrings to the ultimate URL address, or even use code obfuscation to sensitive URL, which also raise the difficulty of automated detection. Previous work like MalloDroid only gave coarse detection result without identification of target URL’s logic function, and Reaves et al. even indicated the inaccuracy of such automated analysis, which further prove the difficulty of this work. Furthermore, finding the target URL with dynamic analysis involves deep human interaction, including registering and login account, clicking products, choosing in-app payment and paying for the order, which is also impossible to be automated and large scale. As a result, we can only do it manually to achieve accurate detection result.

# 4. Notified payment confirmation missing
As Security Rule 6 implies, MS needs to make an extra payment order query (e.g., Step 8 of Fig. 1) to confirm every details of the payment order, even if it receives the payment notification. Since this part of implementation is on MS, we can only apply an indirect detection approach to detect the violation. We try to tamper a payment order information which is different from the original payment order but with legal signature, and pay for it. If the MS accepts the payment order and ships the commodities, then we can conclude that the MS does not re-confirm the notified payment order. Note that the tampered order message should be with correct signature, which means the samples here need to be based on the result of KEY Leakage. We perform the dynamic detection on a small portion of the samples manually due to the ethical consideration. Also the process involves much human interaction such as placing orders and checking the payment’s status, which makes automated analysis almost impossible.

# 4. Signature validation missing
Security Rule 7 implies that MS is supposed to check the integrity of every received message (e.g., in Steps 3, 7, and 9 in...

# W. Yang, J. Li and Y. Zhang et al. / Journal of Information Security and Applications 48 (2019) 102358
# 5. Empirical study
To investigate the flawed in-app payment implementations, we first conduct our TP-SDK identification to the 7145 most popular Android apps from Myapp market and 10,000 popular iOS apps we downloaded from 25PP. As Table 1 shows, 2679 Android apps and 3972 iOS apps integrate at least one TP-SDK, and most of them contain more than one TP-SDK. The proportion of Android and iOS apps supporting in-app payment is as high as 37% and 39%, respectively, which proves the prevalence of third-party in-app payment.

Then we detect each security flaw we mentioned in Section 4. We classify these flaws into four categories involving MA, TP-SDK, MS, and network communication. We find that hundreds of the merchants violate at least one security rule and none of the four TP-SDKs strictly obey these security rules. Besides, we further investigate the official documents and analyze sample codes released by four cashiers in-depth and gain some interesting and unexpected findings, which may imply the root cause of these flaws. Then we choose representative vulnerable apps based on the result of detection and then exploit their security flaws to prove the validity of our analysis. We provide them as case studies to illustrate the complexity of conducting concrete attacks against real world transactions.

# 5. Flaws in MA
We first detect those flaws in the MAs of both Android and iOS. The detection result is shown in Table 2. We can see that hundreds of the merchants leak their KEYs in MAs. Nearly one hundred merchants (Android and iOS respectively) using WexPay generate and send payment order in MAs.

Note that our KEY Leakage result of WexPay has no false positive since it is based on the response messages from WexPay’s Web API as we mentioned in Section 4. The result of detecting WexPay destination URL is over 130 of Android and 110 of iOS.

Since TP-SDKs are provided by the cashiers and integrated by the MA, flaws in specific TP-SDK directly affect the host MA. We evaluate the four most popular TP-SDKs provided by AliPay, WexPay, UniPay, and BadPay respectively, including Android and iOS version. The result is shown in Table 3. We find out that one type of SDK in Android and iOS has the same result. Only WexPay verifies TN correctly. TN accepted by WexPay SDK includes parameters of merchant ID, transaction number, etc. WexPay SDK achieves the MA certificate through system API in Android, and checks the consistency of the APK certificate and merchant ID. It also checks whether the transaction number belongs to the merchant ID. In contrast, we succeed in invoking the other TP-SDKs (AliPay, UniPay, BadPay) integrated in the MA by the transaction order of another MA. Also, we find that both WexPay and AliPay require the registered merchants to submit their certificates of MA, while UniPay and BadPay do not. Obviously, only WexPay makes use of the certificate to verify TN.

For Incomplete Prompt, we manually check every element presented on the payment UI of every TP-SDK. We find out that all four TP-SDKs do not present the order’s owner in the UI, leading to the risk of phishing. BadPay only shows the total amount of the payment order, which is obviously insufficient. WexPay and AliPay both show the order description submitted by merchants. But they do not require the merchant to submit necessary information about the order such as the order ID, the order owner, etc. UniPay and WexPay show the merchant name of the order while AliPay and BadPay do not. Also for UniPay, order ID and payment time will be shown to users only if a spinner on the UI is clicked. In all, every TP-SDK lacks necessary information more or less on payment UI, which may lead users to be deceived.

We manually check the implementation of network communication of four TP-SDKs. We reverse-engineer the TP-SDK using IDA and JEB as well as sniff the network connection with Wireshark and Burp Suite. Besides, we locate the methods/functions of sending/receiving network message in TP-SDKs and hook them (using Frida and Xposed) to observe how.

# 10
W. Yang, J. Li and Y. Zhang et al. / Journal of Information Security and Applications 48 (2019) 102358
# Flaws in TP-SDKs.

# Flaws of MS and network communication.

a Notified Payment Confirmation Missing.

b Signature Validation Missing.

c Https without SSL certificate validation.

these TP-SDKs implement their network protocols. As a result, we find out that SDKs of AliPay and UniPay use HTTPS to connect to their servers and adopt certificate pinning. WexPay SDK uses a proprietary protocol to communicate with its server. After the reverse engineering, we find that it implements its key agreement algorithm based on ECDHE, and the ephemeral keys are authenticated with another public key of WexPay, which is hard-coded in the SDK. Thus, the protocol is secure enough to avoid an MITM attack. The SDK of BadPay validates the SSL certificate properly, thus, is secure. However, compared to the other three TP-SDKs, BadPay does not adopt SSL-pinning, which means it cannot be protected against a compromised CA.

# 5. Flaws in MS
We tampered the payment order of 15 Android and 10 iOS apps with correct signature using their leaking KEYs, and paid for it to see whether MS would accept them. The result is shown in Table 4. Since the action need really exploit the KEY Leakage vulnerability, involving a lot human interactions like MA account registration, placing a merchant order, tampering the payment order, and paying for it, it’s unrealistic to be automated and large-scale. So we did it manually and found that 9 of the 15 Android apps and 4 of the 10 iOS apps that finally accepted the tampered order, which means that their MSs miss the notified payment confirmation to CS. Among the 13 vulnerable apps, there are MA that use WexPay, AliPay or BadPay.