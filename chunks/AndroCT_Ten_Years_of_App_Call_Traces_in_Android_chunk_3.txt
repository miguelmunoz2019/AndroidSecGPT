# V. FUTURE USE OF AndroCT
Despite the multiple prior studies that have used AndroCT, the entire dataset has not been utilized as a whole. In particular, the real-device-based trace collection is largely untapped—only the traces of benign apps of years 2010 through 2017 were used in ; all of the other studies only used the emulator-based traces. More importantly, all the prior studies represented only one application of AndroCT in terms of dataset construction—they all just used the traces to build the single particular behavioral profile defined by the 122 metrics mentioned before, and none of them have used the traces directly or in other ways (e.g., constructing a different run-time profile of Android apps). Also, the traces of apps of years 2018 and 2019 have not yet been used in any fashion. These instances of underuse open a range of opportunities to leverage AndroCT for many more potentially significant research works in the future, as exemplified below.

First, the entire dataset of AndroCT can be used to extend the prior studies by examining the longer-span (eight- versus ten-year) evolution of app behaviors, while looking at the differences in app behaviors between virtual (emulator) and real execution environments. Thus, in terms of the same behavioral profile, we may answer questions like how do Android apps behave differently on an emulator versus on a real Android device?, how do benign apps behave differently from malware on a real device?, and how do these differences differ from those obtained on an emulator?. Each of these questions can be further studied under an evolutionary lens. We can also answer whether the evolutionary patterns sustain beyond a certain span, by comparing the patterns observed in our prior works with the patterns in the entire dataset.

Second, AndroCT can be used in ways other than enabling the computation of the 122 metrics used before. Many other different metrics and measures that represent/model app behaviors in terms of function calls can be proposed. For example, dynamic call graphs can be constructed from the call traces and traversing the graphs will lead to (function-level) execution paths; then known graph and sequence metrics/measures can be computed. For another example, particular kinds of app behaviors can be studied from the call traces by looking at special kinds of calls (e.g., characterizing reflective calls and exceptional handling calls). Various data mining techniques may also be applied immediately to the traces to mine general and special call patterns in Android apps. All in all, based on these novel behavioral profiles, questions similar to the above-mentioned ones can be answered to generate additional, novel insights into the run-time behaviors of Android apps.

Third, the differences between the two collections in AndroCT immediately enable studies of the potentially evasive nature of app behaviors in terms of function calls and ICCs. Since these two collections differ only in the underlying execution environments, the differences between the same apps intuitively reflect the existence and patterns of evasive apps that only exhibited malicious or suspicious behaviors on real devices but hid those behaviors in a virtual execution environment like emulators. Thus, AndroCT would help answer security defense related questions like what are the typical functional call and ICC patterns of evasive apps?, how have the evasion schemes adopted by such apps evolved in terms of function calls and ICCs?, and is malware significantly more evasive than benign apps, or are benign apps not evasive at all?. Using AndroCT, we can also develop learning-based detectors of anti-dynamic-analysis schemes adopted in Android apps and apps that adopt such schemes. Moreover, AndroCT can be immediately used in evaluating different kinds of such detectors. In particular, the longitudinal nature of AndroCT makes it especially suitable for assessing the sustainability  of learning-based detectors of evasive malware.

None of these above questions have been studied by ourselves, nor have they been addressed by others as we are aware of. Thus, we believe AndroCT has great potential and impact for future relevant research.

# VI. CHALLENGES, LIMITATIONS, AND IMPROVEMENT
We faced two major challenges when creating AndroCT. The first was the high overhead of profiling a sizable set of apps—tracing each app took 10 minutes. The second was the difficulty of reaching the size of nearly 36,000 while applying the selection criteria—a number of apps were discarded (e.g., as they cannot be instrumented, the instrumented versions did not run, or the 10-min executions did not cover 60% or more of the app’s code) before an app was selected.

As a result of these challenges, one limitation of AndroCT is that the call traces only represent a limited code coverage for each app hence may not reflect the typical run-time behaviors of the app. Another limitation is that the current dataset only represents one particular emulator and one real device with one Android platform version. When applied to empirical studies, especially those of an evolutionary view, an additional limitation concerns the representativeness of the apps of each year as opposed to the entire app population of that year.

There are several ways to expand and improve AndroCT. First, the function call traces can be much enriched by including run-time values of variables harvested during app executions, including the return values and function arguments. These values will enable more fine-grained modeling of app behaviors. Second, the representativeness of app behaviors by AndroCT can be improved by using higher-quality test inputs (e.g., as generated by state-of-the-art fuzzing tools applicable to Android apps). Finally, the dataset can be enlarged in size for each year and expanded to cover more years..