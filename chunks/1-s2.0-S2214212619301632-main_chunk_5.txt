# 4. Local Ordering
According to the Security Rule 1, MA is prohibited to generate payment orders for those adopting process model I. Local Ordering refers to the incorrect ordering behavior implemented by the MA rather than the MS. It allows the attackers to tamper the payment order. Note that this flaw only appears to apps with WexPay or UniPay, since in their regulations, placing the payment order must be enforced by the MS.

To detect this violation of Rule 1, we search the existence of a relevant destination URL used by the merchant to place a payment order. In detail, app will make request to specific URL6 for WexPay and UniPay, respectively. The request indicates the incorrect behavior of generating order locally. Therefore, we scan all strings in DEX file and resource file of an APK for Android to find whether the above two strings exist. For iOS apps, we search the strings in the .ASM file generated by IDA batch mode. Once the URLs exist, the app is then manually tested to confirm the security flaw.

# 4. KEY leakage
In the two payment process models, several messages transmitted need to be signed. According to our proposed Security Rule 2, sensitive information, especially the KEY is prohibited to appear in app. Otherwise, attackers can tamper or forge messages with legal signature and camouflage to be certain party and cheat others in the multi-party model.

We combine pattern matching and dynamic testing techniques to detect KEY leakage in apps.

- WexPay. A hash function with secret key to generate the message signature is adopted by WexPay. The secret key for message signing is a 32-byte string with arbitrary content shared with merchant and cashier. The MA uses this key to sign message so we would like to search such hard-coded key in app. However, simply searching 32 bytes length string in an MA often gives a huge amount of candidates. To effectively determine the potential key, we utilize a Web API provided by WexPay as an oracle to substantiate the key identity accurately. For Android apps, we make use of the Web API which allows merchant to download the history bill of one day with three necessary parameters: appid, mch_id, and sign (generated by secret key). Therefore, we could leverage the appid and the mch_id to help identify the secret key. Note that the features of these two parameters are apparent: the appid is a 18-byte string with a wx prefix, and the mch_id is a 10-byte string comprised of digits only, and both two parameters are uniquely allocated to merchant. We can first locate strings with similar features in DEX file and resource file (strings.xml), and query the Web API for the identity of the found parameters. If any of the input parameter is incorrect, the response of the query gives a corresponding notification. For instance, if the first appid parameter is incorrect, the Web API would directly return a “wrong appid” notification without considering the following parameters. Thus we could check each parameter individually until its correctness is identified, which significantly improve the efficiency. And if all three parameters are correct (which means we find a leaked key in app), the Web API responds either the merchant’s real bill data, or “no bill exists” if no transaction happened on that day. Using this testing approach, we can effectively find leaked WexPay key in an app.

- BadPay. Similar to WexPay, BadPay uses a shared secret key to sign its messages. However, no Web API is provided by BadPay for us to verify the potential key candidates. Considering that far fewer MAs use BadPay, we could confirm the key through manual reverse engineering.

- AliPay. For AliPay, merchant uses an RSA private key within a Based64-encoded standard ASN1 certificate to sign the order information. The certificate format contains remarkable feature (A string with ’MI’ as prefix and at least 300 bytes long) and can be easily located. However, the app may also contain such certificates to fulfill other functionalities. To confirm the application of found certificates, we adopt the following two heuristics for Android apps. We first check whether the variable name of the candidate certificate contains ali or alipay. Second, we make use of the cross reference searching to find the Java class that refers to the candidate certificate.

W. Yang, J. Li and Y. Zhang et al. / Journal of Information Security and Applications 48 (2019) 102358
A certificate is used to sign the order of AliPay, the order information is often generated in the same class that uses the private key. This generated order information contains specific feature strings (“&service=mobile.securitypay.pay” for example) and can be easily identified. If a certificate corresponds to one of the above properties, we regard it as the signing key of AliPay. For iOS apps, we build a tool based on IDA Pro similar to the heuristics used for Android apps. In addition, we also find a downloadbill Web API provided by AliPay, that could be used as an oracle like WexPay, to confirm the KEY accurately. However, it could only be applied to apps using the latest version of AliPay API, which is a very small portion of our samples.

• UniPay. Similar to AliPay, UniPay also uses RSA private key to sign its messages but the private key is encapsulated in a CER format. We also adopt similar detection methodology to UniPay.

# 4. Incomplete prompt
When an MA invokes the TP-SDK and shows the payment UI to users (e.g., between Steps 5 and 6 in Fig. 1), users need to confirm the order and decide whether to pay for it. As the Security Rule 3 implies, detailed order information should be prompted to user in the payment UI completely. Otherwise, user may suffer deception, resulting in an attack that what user pays is not what he/she really buys (Order Substituting Attack).

We detect this security flaw by checking whether TP-SDKs (for both Android and iOS) display enough information about the payment order to user during the payment. In detail, the following fields are checked: (1) payment order ID that represents the order uniquely in both merchant and cashier. (2) what commodity or service that users are going to pay. (3) user that the order belong to in merchant app. (4) merchant that the order belongs to. (5) total money of the payment.

# 4. Transaction verification missing
In a secure payment process, TP-SDK integrated in MA need ensure that the received payment order (Step 3 in Fig. 2) or TN (Step 5 in Fig. 1) actually belongs to the MA according to Security Rule 4. Otherwise, malicious merchant can expand the Order Substituting Attack and directly get money from users as we mentioned in Section 3.

We detect this security flaw on both Android and iOS platform, through testing whether the TP-SDK accepts a payment order that does not belong to the MA. First, we place an order using a normal MA. Then we intercept the orderp / TN message from the MS and substitute it with orderp / TN message generated from another MA. And we check whether the order belonging to another MA can be accepted successfully by the TP-SDK. If so, the violation of Rule 4 is confirmed.

# 4. Insecure communication
According to Security Rule 5, network communication between MS, CS, and MA (including its integrated TP-SDK) should adopt secure transmission (e.g., via TLS channel). Otherwise, attackers can intercept, eavesdrop or tamper what users want to buy (e.g., in Step 1 of Fig. 1), the payment order information (e.g., in Step 2 of Fig. 2), or the transaction information (e.g., in Step 4 of Fig. 1). It can also directly cause the Order Substituting Attack, as we mentioned in Section 3.

According to the adversary model, we mainly concern how to detect the insecure network communication employed between the MA (including TP-SDK) and the remote server. We set a proxy to conduct MITM attack against HTTP and HTTPS connection to detect the potential flaw. The insecure communication between TP-SDK and CS may cause wide and serious consequence. Since TP-SDK is integrated by a large number of Android and iOS apps, all the MAs with this kind of TP-SDK will suffer vulnerabilities (such as payment information leakage, transaction interception and tampering, etc.), if the network communication is insecure. So we adopt a refined policy to detect the flaw in TP-SDK. We try to sniff and attack the network communication during a manually conducted payment process. If the connection between TP-SDK and CS is an HTTP connection, we regard it as insecure. Furthermore, if the connection is HTTPS, we will check whether it verifies the SSL/TLS certificate properly, or implements the certificate pinning. If the TP-SDK uses private protocol communicating with its server, we further audit the security of this protocol (since there are only four TP-SDKs, we could audit it manually).