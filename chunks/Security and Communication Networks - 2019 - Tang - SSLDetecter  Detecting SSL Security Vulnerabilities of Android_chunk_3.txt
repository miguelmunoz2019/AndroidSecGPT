# 3. Android Application Security
In addition to analyzing SSL usage in Android applications, there are several studies that focus on other security issues in Android applications. Munivel and Kannammal  point out that phishing attacks are still very common on mobile smartphones today. A new authentication framework is proposed, which does not require password transmission but is based on zero-knowledge proof to identify communication entities. Li et al.  note that many of the repackaged Android apps have a lot of malicious piggybacking. This is a way for malicious code to spread. They analyzed the specific situation in depth and provided supports for further detection of the malicious code. Maier et al.  point out that many Android malicious applications currently separate malicious code from normal code and that malicious code runs more covertly and can easily bypass lots of checking methods. Enck et al.  propose a TaintDroid system that can dynamically track tag data in Android applications. Many other dynamic analysis systems are based on this. AppSpear  is a system for automatic analysis of packed Android applications. The system uses some unpacking strategies to effectively restore some hidden code and generate complete executable codes of the Android application.

In summary, SSL security issues still need to be taken seriously in Android applications. Some of exiting methods cannot effectively deal with the analysis of packed applications , and in many cases, it does not work. Some others also has disadvantages, such as time-consuming analysis and system modification, which make it difficult to effectively detect SSL security vulnerabilities. How to automate and effectively detect SSL security vulnerabilities in Android applications is still a challenging problem that has not been well solved. Based on our previous work , we have proposed a new automatic traversal method to detect SSL security vulnerabilities of Android applications. Our new method is described in detail below.

# 4. UI Traversal Strategy
Android applications realize user interaction through the component named Activity. Each Activity corresponds to one or more interfaces (views). The interface contains a number of widgets that are bound to listen to user events, and the user manipulates these widgets to perform program functions. In a directed graph that only knows the initial node, the interface jump is generated by simulating the user.

# 4. Our Traversal Model
The traversal model is a finite state machine to represent the interface (view) states and the transition process between them. We build our novel GUI traversal model for Android applications based on the widget level. We give specific definitions of our traversal model below.

Interface state consists of binary group &lt; interface widget tree, Activity name&gt;, and is used to identify different interfaces in the process of application running. The interface widget tree refers to a tree with widgets as its nodes, which is built according to the hierarchical relationship and the dependency relationship of widgets in the interface. Each node holds the widget’s structural information (parent widget, child widget, and widget path) and widget property information (such as widget type, text information, and clickable). The Activity name defined by its fully qualified type name represents the Activity to which the interface state belongs.

Actions are specific actions that cause changes in the state of the interface. They can be divided into simple actions and combined actions. Simple actions consist of a triple &lt; widget ID, event type, and additional information&gt;. Widget ID is used to identify the widget. The event type indicates the action performed by the widget. Additional information provides widget action assist information. Combined actions consist of two or more simple actions.

GUI node consists of a binary group &lt; interface state, task list&gt;. The interface state describes the basic information of the GUI node. The task list holds information about the tasks that the GUI node needs to perform.

Task represents by a binary group &lt; action, GUI node&gt;, indicating that the action is executed only under the GUI node.

GUI jump consists of a binary group &lt; task, GUI node&gt; which is used to describe the jump relationship of GUI nodes. The task is a task in the task list of precursor node, and the GUI node is the destination node to jump to after executing the task. GUI directed graph consists of a binary group &lt;GUI node set, GUI jump set&gt;. GUI node sets constitute all vertex information in GUI directed graph, and GUI jump sets constitute all edge information in GUI directed graph.

The process of building our GUI traversal model is the process of dynamically extending GUI directed graph. After entering the application, the first interface corresponds to the starting GUI node of the GUI directed graph, and the
# Security and Communication Networks
interface is analyzed to generate a task list. When an application executes a task in the task list, the GUI directed graph is updated according to the interface state after the task is executed. When the interface state remains unchanged, the GUI directed graph does not change. When the interface state is transformed into an existing interface state, the GUI jump occurs. The jump forms a new GUI node and adds the edge between the previous GUI node and the node corresponding to the current interface state, and updates the task list to the task list corresponding to the current GUI node. When the interface state is transformed into a new interface state, a GUI jump occurs too. A new GUI node is formed, and the edge from the previous GUI node to the new GUI node is added. Then analyze the new GUI nodes and build the task list. To dynamically expand the GUI directed graph, the tasks in the current GUI node task list are sequentially executed in a loop.

# 4. Interface Widget Tree Optimization
Each interface corresponds to a widget tree. If we exhaust the simulation of all the actionable widget events on the widget tree, not only will the traversal space swell, but also this is not allowed in the detection time. For example, when we traverse to a slidable page that contains a news list, it would take a lot of time to click on each piece of news. However, in reality, these widgets trigger the same network link only with different parameters. Second, improper handling of widgets can also cause the traversal aborts. For example, when a prompt box pops up on the interface, the prompt box will get the window focus, so that the interface widget behind cannot be clicked. At this time, if the pop-up box cannot be closed correctly, it will directly jump out of the interface to be tested and terminate the traversal. Finally, when there are many types of events on an interface, such as input box, selection box, button, and so on, it is especially important to establish the sequence of event triggers. To deal with the problems above and to trigger as many effective network request events as possible in our system, we propose an optimization strategy of the widget tree according to the interface categories.

After manually analyzing 200 runtime screenshots of applications, we have divided the interface into six categories: welcome interface, popup interface, list interface, detailed interface, input interface, and other interfaces from three aspects of interface area, widget tree structure, and specific widgets. Table 1 describes the feature information of each category of interfaces. During the application running process, the interface category is identified by feature matching and different widget tree optimization strategies are conducted to trigger as many effective network requests as possible to cover the suspected SSL vulnerability points. The following Strategies 1 to 6 correspond to the six categories of interfaces, respectively. At the same time, after each kind of interface is processed, all the actionable widget events in the optimized widget tree are cropped according to Strategy 7 and Strategy 9, and the action sequence is built according to the specified priority.

# Strategy 1
When the interface is identified as the input interface, widget nodes such as EditText, SearchView and CheckBox are searched in the widget tree to obtain information such as text, content-desc, and resource-ID of the widget, so as to identify the type of information that the node needs to input. The input library we built is just several XML configuration files, including various information such as mobile phone number, e-mail address, gender, and search keywords. The input library is then matched to generate input actions expressed as a triple &lt; widget ID, “input action,” “input contents” &gt;. Simultaneously search for the sibling node of the widget, the parent node, or the sibling node of the parent node of the widget, then match the corresponding button node according to the context information, generate &lt; widget ID, “click” &gt; button action, and encapsulate the two actions into combined action.