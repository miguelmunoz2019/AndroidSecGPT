public ValidatedirecttransferParser(JSonObject paramjsonobject)
try super(Paramjsonobject);
Object localobject paramjSonobject getJSonObject("resultadovalidaDestino");
this.a new Directtransfersummary(parseproduct(((JSORObject) localobject).getjSonobject("producto")));
ParamjSonobject get solobject(tresultadoDatosBeneficiario");
JSOnObject localjsonobject
paramjSonobject ((Jsonobject}localobject} optBcolean("requierevalidacion");
boolean bcol localjSonobject getstring("nombreneneficiario") =
this.a.setRequirevalidation(bool);
if (bool)
# Code 1 – ValidateDirectTransferParser class and the word found in the logs for an electronic transfer
# 8. Online/Offline authentication:
To analyze this point, it is used the logs generated by the application, while it is running on the virtual appliance. It is required to know if the application connects with any external server to carry out the authentication (online), or if this process is carried out locally (offline). In the case of an application that performs the online authentication process, URLs appear in the logs generated by the application to which it connects. As shown in Figure 4, this application makes use of the HTTPS protocol to connect to an external server during execution. If the application is authenticated offline, the application does not connect to any URLs to provide access. Figure 5 shows an extract of the logs generated by an application that is authenticated offline, showing that there is no connection to an external server.

372 RISTI, N.º E19, 04/2019
# RISTI - Revista Ibérica de Sistemas e Tecnologias de Informação
image.htm?id-XxXXXXX
84-23 28:36;43 Nijson 2452): https://www.aplicacion.com.ec/detectrd
24-23 28:33:56 W/json 2452): http://www.aplicacion.com/Files/Movil-Pp/Bancoxpp.jpg
# 9. Additional information to the User/Password:
Within the authentication process, applications use a username and password, at this point it will be asked to find out if the application uses additional information. For example, there are applications that use a device identifier, coordinates, etc.

cat-[android.intent category.LAUNCHER] flg-exlezeeeee {act-android.intent.action.MIN 24-26 22:89:55926 -/Activity ianager( 1838) : START Cmp-com.android music/.MusicBrowseractivity (has extras)} from Uid 18887 display
24-26 84-26 22:89:55 97222 55 Ellibprocessgroup( 3956) : failedAudiotrack( 1838) AUDIO_OUTPUT_FLAC_FAST denied by clientmake and chown /acct{uid_18833: Read 84-26 only file system22:89:55 978I/Activityrianager( 1838) : Start proc 3956 com android music/u8a33 for activity CCm. android Music/ .Musicero seractivity
24-26 22:89:56 I/ActivityManager( 1838) : STARTtypevnd.android cursor dir/artistalbum flg-8x4e22822{act-android.intent action.PICK dat= displaycmpecom.android.music/.Artist-lbumBrowserictivity (has extras)} from Uid 18833
# 10. Authentication methods:
The purpose of this point is to determine which methods the application uses to allow access. Generally, mobile applications use two authentication methods, to find the corresponding code, the results of point B are scanned in the JD-Gui tool. At this point it should be noted that the JD-GUI search will display results as written in the search box, case sensitive.

# 11. Blocking:
In case of anomalous behavior, for example, if a user enters invalid credentials into the application several times, the application must be blocked. At this point you will find the code that performs this action. To find it, you could enter invalid credentials when you authenticate in the application, and observe the logs generated.

# 12. Unique authentication:
At this point it is checked whether the application performs the authentication process each time it is opened, or whether this process is performed only the first time it is accessed. To determine this, it is used the logs generated by the application when it is opened. The applications use several methods that control the behavior of the same one, the method which is relevant for this point is the onResume. This method is the one that is executed when the application is opened. As shown in Figure 6, this application executes this method when the application is opened. Using the JD-Gui tool, the onResume block is searched to find the associated code.

84-26 22 I/*** 3486) : Aplicacionxctivity onResume
84-26 22 I/*** 3486) Aplicacionxctivity sho Restriction
RISTI, N.º E19, 04/2019
373
# Security Analysis Protocol for Android-Based Mobile Applications
For instance, the onResume method has been found as shown in Code 2, this method calls the showRestriction method, which calls the Login screen every time the application opens or returns to the foreground. Therefore, this application requires credentials to be entered each time it is opened.

# 13. Two step authentication
To allow access, an application must maintain an adequate level of security, one of the ways of achieving this is through two-step authentication.

public Void onResume ( )
RUMAPplicationrcok.OnxctivityResumed(this);
showRestriction()_
HF_NRAP_onResume()_
Activityrcoks.onactivityResumeEnd-cok(this);
protected boolean sho Restriction()
shoNLoginscreen();
Code 2 – onResume method and showRestriction Validate Direct Transfer Parser method
During a two-step authentication, in the first phase the user correctly enters his or her credentials in the application, while in the second phase a verification code is sent to the customer’s email or cell phone number, this code must be entered in the mobile application to access.

To identify this process, it is necessary to use the initial exploration of the application, carried out during the information gathering phase, and the logs generated by the application. It is useful to search for words such as code, activation, validate, etc. The words identified in the logs are then searched in the application code.

# 14. Automated static analysis
Finally, at this point, the .apk file of the application to be analyzed is dragged to the MobSF application web interface. MobSF performs automated analysis of Android applications and this results complement the information about the overall state of application security. Once the analysis is complete, the results are presented and can be saved in .pdf format.

The results obtained are separated into different sections and to export them as a .pdf file, the Download Report option is used and the file is automatically extracted for later analysis.

# 3 Dynamic Analysis
This section is called dynamic because it provides insight into the communication aspects. For each of the tasks which are part of the dynamic analysis, it describes how to use the tools, as well as the recommendations for obtaining the desired information. The tasks for this phase are: Communication protocols used, Existing scripts for vulnerability scanning, Content provider, and Data leakage.

374 RISTI, N.º E19, 04/2019
# RISTI - Revista Ibérica de Sistemas e Tecnologias de Informação
1. # Communication protocols used:
Since applications communicate with a web server for both authentication and transaction processing, it is necessary to verify that this communication is done using secure protocols. Two Network Connections and OWASP ZAP tools are used for this purpose.

2. # Existing scripts for vulnerability scanning:
There are scripts that help to perform the scanning process, such as Pidcat; or that provide information about vulnerabilities that the application may contain, such as Manitree. For the development of this point, the Pidcat and Manitree scripts have been considered according to what has been suggested in documents such as: How to Avoid Development Errors in Android  or Risk Analysis of Android Based Appliance , since these scripts have proven to be very useful and have obtained successful results.

3. # Content provider:
Drozer tool is used to develop this point. A content provider, when not properly configured, shares the information it handles, making it accessible to other tools installed on the same Android device. The procedure for testing this point is as follows.

From the Drozer console, the installed applications are listed with the following command. It uses the name of the application in order to obtain the name of the package, which begins with “com.” + the name of the application.

>run app.package.list –f aplication_name
Now that the name of the package is known, the following command is executed to know if there are exported content providers. In addition, the application also shows if there are activities, broadcast receivers, or services that are exported. Within the command syntax, the package_name is the one obtained in the previous step.

>run app.package.attacksurface package_name
Next, the information about the permissions that the content provider has is gotten with the following command:
>run app.provider.info -a package_name
In this way, it is confirmed whether or not the information managed by the content provider is accessible by other applications. For example, if a permission has the value of null, it means that it can be accessed by another application.

4. # Data leakage:
Finally, the .apk file contains the URIs with which the application communicates and, by means of the Drozer tool, tests are carried out to determine whether or not these addresses can be queried directly. To do this, proceed as follows:
From the Drozer console, the following command is executed to obtain the URIs with which the application communicates. At the same time, Drozer attempts to consult these addresses and reports the results.

>run scanner.provider.finduris –a package_name
RISTI, N.º E19, 04/2019 375
# Security Analysis Protocol for Android-Based Mobile Applications
If accessible URIs are found, the following command is used to obtain the information it contains.

&gt;run app.provider.query uri
Instead, the following command is used to check for SQL Injection vulnerabilities:
&gt;run scanner.provider.injection –a package_name
With this, it is known whether or not the application contains URIs that are vulnerable to this type of attack.

# 4. Discussion
The protocol was performed on a mobile banking application of Ecuador. A summary of its results is presented below.