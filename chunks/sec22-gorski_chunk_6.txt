API File Methods: While the semi-automated procedure for identifying API file methods (Section 4) may appear manually intensive, it is largely a one-time cost with minimal additional manual effort needed to transition to a new version or build. For AOSP 9, the process took approximately 96 hours to identify the API file methods from a total of 65,508 API methods. However, the process only took an additional 5 hours to consider the 7,565 API methods added in AOSP 10. As there was a minimal addition of 388 API methods for Google 10 compared to AOSP 10, the process only took an additional 30 minutes and no adjustments were made manually. However, the additional 10,273 API Methods for the Samsung S20 device took an additional 7 hours.

# 5 Characterizing Security Sensitive Files Paths
As discussed in Section 4, a file path is considered security sensitive if it has a UID or GID of system, or a GID corresponding to an Android permission. Table 2 illustrates the number of security sensitive files identified for each device. Both AOSP 9 and AOSP 10 devices contain over 130,000 security sensitive file paths, while both the Google and Samsung devices have around 56,000 security sensitive file paths. The difference results from the AOSP images being built with the user debug flag (providing root access). The user debug flag also provides a more permissive SELinux policy for adb, allowing it to view file paths that are normally restricted by production builds.

# 5 Reducing Candidate RPC Entry Points
For AOSP 10, the file path extraction procedure (Section 4) produced 7,331 unique intermediate expressions spanning 2,927 unique RPC entry points and reducing to 462 unique regular expressions. Table 3 shows there was only a minor change in these numbers for the Google device; however, the Samsung device saw a significant increase in all three. This difference is likely attributed to there being almost double the number of RPC entry points for the Samsung device compared to AOSP 10 (Table 2).

Finally, Table 3 shows the remaining RPC entry points requiring manual inspection after the re-delegation logic is.

applied. Note that while we discuss the results in terms of the number of unique RPC entry points, expressions, and files, a candidate RPC entry point may have multiple files that require separate manual inspections. For AOSP 10, FRED identified 23 candidate RPC entry points potentially re-delegating access to 51 files. Of these 23 deputies, 21 resulted from Java file accesses and 2 resulted from C/C++ file accesses. Each of the 2 candidate RPC entry points accessed a single file in C/C++ code that was not in the list of files being accessed by the other 21 candidate RPC entry points. Similar results were observed for the Google device, including the same candidate RPC and files from the C/C++ code analysis.

A manual review of the 23 candidate RPC entry points for AOSP 10 identified 10 deputies that both (a) are accessible by third-party applications and (b) improperly re-delegate access to one or more security-sensitive files. The remaining 13 deputies safely use the files, either using them in a way that is not accessible to a caller or in a way that the caller could only retrieve or modify a subset of the data in the file by design. The same vulnerable deputies were found in both the Google and Samsung devices.

For the Samsung device, FRED identified significantly more candidate RPC entry points (60) and files (143) compared to both the AOSP 10 and Google devices. This likely results from the Samsung device containing more RPC entry points accessing files. The Samsung device included the same candidate RPC entry points and files from the C/C++ code analysis as the AOSP 10 and Google devices.

# 5 Impact of SEAndroid
Our re-delegation analysis did not account for the impact of SEAndroid policy, which may restrict (a) the RPC entry point from accessing a file even if allowed by the Unix permissions and (b) a third-party application from accessing the service.

RPC entry points accessing files: The RPC entry points considered by our analysis are registered with Android’s Service Manager. We verified that most of the corresponding services execute with the system_server SEAndroid label by checking (1) whether a service gets started in system server’s source code, (2) whether the service is running as a thread of system server in ps -AZ, or (3) whether SEAndroid allows system server to add the service. One exception is entry points under com.android.internal.telephony which runs in the com.android.phone process with radio SEAndroid label.

For each concrete security-sensitive file, we used SETools  to determine if the binary policy bundled with the firmware allows the SEAndroid context (e.g., system_server) of the entry point’s corresponding service to access the SEAndroid context for that file in any way. Empirically, we found that SEAndroid does not affect our analysis with the AOSP or Google Pixel 3a firmware. However, for the Samsung device, the SEAndroid policy removes 3 RPC entry point to file mappings consisting of 2 RPC entry points and 3 files.

Apps accessing RPC entry points: We confirmed that the SELinux policy does not restrict third-party applications from calling the 10 vulnerable AOSP deputies discussed in Section 5. SELinux policy defines call, transfer, and find permissions for Binder service operations. The call and transfer permissions are generally granted to apps so that they can make binder calls into the system server and service manager. The find permission is commonly used to allow finding services via the service manager (though Android primarily gates access to services at the RPC entry point level via Android permissions, not at the service level). The AOSP policy allows the untrusted_app_all domain to find any Binder service with the app_api_service SELinux attribute. We confirmed that all four vulnerable AOSP system services in Table 6 have this attribute. For the additional BlockchainTZService service in the Samsung device, we did not observe the app_api_service attribute. However, due to the more complex nature of the Samsung SELinux policy,
USENIX Association 31st USENIX Security Symposium 1535
we notified Samsung of the potential vulnerabilities anyway. Interestingly, Samsung informed us that they fixed the two vulnerable deputies adding SELinux policy to prevent third-party applications from accessing BlockchainTZService.

# 5 Vulnerability Study
Responsible Disclosure: We verified all of the potential re-delegations in AOSP through manual inspection of source code. All identified vulnerabilities identified in AOSP have been submitted to Google via Android Security Rewards Program. Of those submitted, 3 received a “moderate” severity rating and have been assigned the common vulnerability and exposures (CVE) identifiers CVE-2020-0208, CVE-2020-0209, and CVE-2020-0210. All 3 CVE vulnerabilities were fixed in the June 2020 security update for Android 10. The two vulnerabilities identified in the Samsung device involved code paths in native code for which we could not inspect. We provided the names of the deputies and corresponding JNI calls to Samsung, who confirmed the vulnerabilities and assigned CVE identifiers CVE-2021-25460 and CVE-2021-25459. Fixes for the Samsung vulnerabilities were released to devices in September 2021.

# 5 VC1: Data Manipulation
FRED identified 5 vulnerabilities (1→5 in Table 6) that enable a third-party application to access or manipulate data in security sensitive files. Deputies 1→4 allow third-party applications to manipulate data in the multiple files managed by the AccountManagerService. For the purposes of this discussion, we focus only on the key database files of /data/system_de/0/accounts_de.db and /data/system_ce/0/accounts_ce.db as they are the main source of the vulnerabilities. Both database files have ownership system:system.

In a multi-user system, removeSharedAccountAsUser and renameSharedAccountAsUser (CVE-2020-0208 and CVE-2020-0209) both allow any application running on the current user to remove or rename the shared accounts (e.g., Facebook) of that user. Account manipulation is typically restricted to the application that manages the account. However, through these deputies, any application can modify the shared account data in the two database files, data which requires the caller to have the system level permissions MANAGE_USERS and CREATE_USERS to create. Similarly, invalidateAuthToken and updateCredentials both manipulate data in these databases, allowing any application to affect portions of the databases.

Deputy 5, add in the DropBoxManagerService, allows any caller to clear system logging information which may hide evidence of an attack. A call to add allows the caller to write a data packet of any form to a temporary log file in the /data/system/dropbox with ownership system:system. However, continuous calls to add cause the deputy to clear older logging files when the device is low on space or the number of files exceeds 1000. As such, an attacker could hide evidence of their attacks by manipulating this deputy.