# 2 Install-Time Permission System
Traditionally, up to version 5 (i.e., Android API level 22), Android makes use of an install-time permission system to regulate the access to sensible APIs of the platform. Developers have to declare upfront if their apps require access to security- and privacy-relevant parts of the platform. Very little control is in the hands of the end user, who can only decide to grant or reject all permissions to access such parts of the Android APIs before app installation, and can only rely on warning dialogs to assess possible risks (often using extremely broad wording). If the user only agrees with a subset of the permissions, she has to abort the app installation. This amounts to force the end user to either grant all permissions or not install the app. It has been observed that users routinely decide to not install an app because of the permissions it requires. Moreover, usability studies show that only a minority of users have a reasonable comprehension of warning dialogs. Dialogs have been found to be vague and devoid of context, as users have no way to know what app features the install-time permissions correspond to.

# 2 Usage-Time Permissions System
Starting with Android 6 (i.e., Android API level 23), access to privacy- and security-relevant parts of the platform can be enforced by a usage-time permission system. While the app is running, the system checks whether the app functionality that is going to be used for the first time has the required permissions or not. Users are prompted for confirmation when the functionality attempts to access a restricted part of the platform.

While runtime permissions provide more detail over the specific functionalities of the app affected by the permissions, hence helping users in making their decision, permissions are still granted on a whole-app basis, i.e., once granted the permission is valid for the entire app, further reducing control on how and when private data is accessed. Users can potentially revoke permissions already granted to an app but this requires exiting the app, accessing their device system settings and manually changing the permission settings of the app. The whole process is unwieldy, and users are unlikely to do so.

In addition, in the Android platform, permissions are grouped into permission groups. A permission group is a set of two or more permissions that reference the same.

# IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 47, NO. 10, OCTOBER 2021
resource. For instance, the permissions READ_CONTACTS and WRITE_CONTACTS both belong to the CONTACTS permission group. Whenever an app tries to access a protected resource, users are prompted for confirmation only if no other permission in the belonging permission group is already granted. This is done in order to minimize a phenomenon known as warning fatigue, which has been observed in the past in other usage-time permissions systems , ,  – i.e., users may become insensitive to warning messages after being exposed to an excessive amount. While the concept of permission group can be effective in reducing warning fatigue, it also makes the permissions more coarse grained. Multiple permissions are in fact granted with a single confirmation, further reducing the user control on the resources that will be accessed with respect to the granted permissions.

# 3 THE AFP APPROACH
Android Flexible Permissions (AFP) grants permissions on a per-feature basis by (i) keeping track of user privacy preferences, and (ii) automatically enacting and enforcing them at runtime. AFP is composed of the following main components:
- AFP App, an app from which users can manage their own flexible permissions;
- AFP Library, a library for access control at runtime;
- AFP Server, a web app that allows developers to automatically retrofit an existing app in order to enable AFP in it. It also offers mechanisms for signing and verifying AFP-enabled apps.

With reference to Fig. 1, in the following we describe the workflow of AFP. Section 3 describes the steps to be followed by developers before publication, in order to make their apps compatible with AFP. Section 3 describes the...

Authorized licensed use limited to: Pontificia Universidad Javeriana. Downloaded on August 13, 2024 at 04:26:33 UTC from IEEE Xplore. Restrictions apply.

# SCOCCIA ET AL.: ENHANCING TRUSTABILITY OF ANDROID APPLICATIONS VIA USER-CENTRIC FLEXIBLE PERMISSIONS
steps to be followed by users upon the first app execution, in order to specify the desired permissions.

# 3 App Developer Perspective
The developer workflow is designed to minimize the effort needed to create apps compatible with the flexible permission system.

Developers create their mobile apps as usual, without using any additional library or tool. When an app X is ready to be published (right-hand side of Fig. 1), the developer can send the APK archive of X to the AFP Server so to enable AFP (1). As detailed in Section 3, the Android Components Extractor extracts all the Android components of X, i.e., its constituent activities, services, broadcast receivers, and content providers (2). Then, the developer uses a web-based editor for (i) defining the features of X in terms of their name and description (later used by end users), and (ii) mapping each one of them to (a subset of) the extracted Android components implementing it (3). Step 3 is the only additional effort we request to developers, and it is greatly facilitated by the web-based editor together with the automatic extraction of Android components. The output of this phase is the feature-component mapping model, specifying the mapping between app features and Android components.

The AFP Instrumenter statically analyzes and automatically retrofits app X to enable AFP on it (4). The instrumenter performs the following operations (that are totally transparent to the developer): (i) automatically includes our AFP Library in the app; (ii) instruments X so that all calls to sensitive Android APIs are proxified and redirected to the AFP Library; (iii) injects the code in the main activity of X for allowing the end user to switch to the AFP App when launching X for the first time; (iv) assigns a unique secret key to the app X, which will be used at runtime by the AFP App Checker (12); (v) creates a new record into the repository of registered apps; (vi) rebuilds and re-sign X as a new APK archive. Finally, the instrumented APK of X is made available to the developer (5), who can then proceed with the publication of the APK in the Google Play Store (6).

their reviews in the Google Play store . Indeed, by explicitly asking end users to define the permission levels on a per-feature basis allows users to (i) read the description of each feature provided by the developer and (ii) better understand why certain permissions are being requested in the context of each specific feature of the app, rather than within the app as a whole. By using AFP, end users have a more transparent view of the features provided by their apps, and a better knowledge about the context in which (sensitive) permissions are requested by the app.

While the end user is setting her desired permissions, in background, the AFP App also interacts with the AFP Server (11). The AFP App and the AFP Server communicate via the HTTPS protocol. The server also uses an internally generated secret key (4) to check the app installation and verify the developer’s identity, hence certifying that nobody tampered with the AFP Library. Moreover, it verifies that the APK downloaded from the Google Play Store is exactly the one produced by our approach (12). When the results of the checks are ready (13), and the configuration phase finishes, the user will be redirected to the newly installed app, together with the configured flexible permissions configuration (14). The permissions configuration is then associated with the AFP-enabled app and the user can continue with app usage, in a completely transparent way, i.e., no further user interaction or dialogs are required.

The access to private or sensitive resources will be granted by the AFP Library according to the specified permissions configuration (15). The AFP Library proxifies each call of the app to sensitive Android APIs (e.g., call to the Android geolocation manager), hence wrapping the access to sensitive resources.

The AFP App allows to specify default levels for the permissions (e.g., geolocation is allowed only at the city-level, independently of the app requesting it), that will be used as a basis during the configuration of the flexible permissions for any newly installed AFP-compliant app. This characteristic permits to speed up the configuration of the permissions for each newly installed AFP-enabled app.