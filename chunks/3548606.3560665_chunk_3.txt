# 3 Data flow inspector
This module detects privacy/security issues in non-standard and covert channels in the collected network traffic. We also leverage the collected parameters (i.e., ciphertext, plaintext, algorithm, key, IV) of encryption/decryption functions by hooking cryptographic API methods. Then we search the logged ciphertext from the captured content, and map/store the ciphertext with their corresponding plaintext. We also check files stored on the device, including images, audio and video files. We categorize the captured content into HTTP, HTTPS, non-HTTP, and file.

For privacy issues, we extract Personal Identifiable Information (PII) and personal data (e.g., contacts, messages, images, audio, video) stored on the device to identify privacy exposures. We create copies of this data in different encoding formats (e.g., Base64, hex), and search these copies (exact and partial matches) within the network traffic, and magic headers (i.e., file signatures used to determine the content of a file) of transmitted media content (image, audio, video) originated from the device (i.e., outgoing). Finally, we store the results of the search content in a database.

For security issues, we check for situations where traffic sent over secure network channels are subsequently sent over insecure channels using HTTP/non-HTTP — e.g., an authentication token sent over HTTPS, is subsequently sent over HTTP. We also look for fixed/hard-coded keys in the app/library code, and the use of weak encryption algorithms (e.g., RC4) to encrypt data that is passed through insecure channels.

For covert channels, we check for files on shared storage that are opened by different apps. If we find files with common paths reused in multiple apps, we flag those as possible covert channels.

# 4 IMPLEMENTATION
We use Python to implement ThirdEye, and leverage the use of other Android command line utilities (e.g., ADB) to manage the orchestration of app executions. In addition, we use tcpdump and mitmproxy to capture network traffic and decrypt HTTPS communication. We use Frida to instrument API methods, implement the UI interactor component by extending AndroidViewClient. We discuss our implementation details below.

# 4 Pre-execution steps
To prepare an Android device for instrumentation, we first manually set the Android built-in WiFi proxy on the target device and import initial data on the device, including sample media files, contacts, and SMS messages. We also remove the device lock and increase display sleep timeout to avoid deadlocks in the UI interactor module.

We then use the app manager component to handle downloading, installing and executing the latest and most compatible version (for our device hardware and OS) of a target app from Google Play. The app manager utilizes the UI interactor module to open and interact with Google Play, which is used to install apps; see Sec. 4. The apkpure.com and apktada.com marketplaces are also checked if a target app is unavailable in Google Play (apps may fail to install from Google Play due to e.g., region locking). During the first install of an app, we store all APK and OBB files, to avoid downloading them again for subsequent testing.

The available permissions on a target device and the runtime permissions required to launch an app on the given device are extracted using the package manager (pm list permissions)  and dumpsys package   commands, respectively. We grant all the requested runtime permissions using the pm grant   command. Apps may also request special permissions (e.g., Accessibility, Notification Listener), which are only set via Android settings. We use the dumpsys package  command to fetch services that request special permissions, and then execute the settings put or cmd  command (depending on the type of the requested permission) to grant the special permissions.

2448
# Hidden in Plain Sight: Exploring Encrypted Channels in Android Apps
# 4 In-execution controller
We make sure that only our target app is installed on the device. Package names of all installed apps on the target device are extracted from cmd package list packages command. These package names are matched with that of the target app and allowed system apps (i.e., dependencies). Any apps with unmatched package names (i.e., non-system apps) are removed. Then, prior to an app execution, we also ensure that all opened unwanted apps (e.g., Camera, Contact) are closed using the pm clear command . We also verify that the ADB connection between the test desktop and devices, and the Internet connection from the devices are successful. We detect apps running in the background and foreground using the dumpsys activity activities command . The output of this command returns structures showing foreground activity (mResumedActivity) and background activity (mLastPausedActivity) information. We make sure that the test app is always running in the foreground.

Apps with certain permissions (e.g., CHANGE_WIFI_STATE) can perform disruptive operations (e.g., change WiFi connectivity state, screen rotation), which can affect our app analysis. If an app disables WiFi, the Internet connection is lost, and if the screen rotates, a click event may trigger at the wrong position of the screen; to avoid such situations, svc wifi enable , and content insert , commands are used, respectively. Furthermore, because of the variation in the strength of the GPS signals received by a device, searching for the exact GPS location in the saved network traffic is problematic. The received GPS coordinates from satellites may vary slightly even when the device position is fixed. Therefore, to return a fixed GPS value, we use our own GPS mocking app.

During UI interactions, it is possible to have accidental app closures or crashes. Crashed or frozen apps are identified by inspecting the mCurrentFocus structure that contains the current foreground window activity details. This structure is returned from the dumpsys activity activities command. Therefore, mCurrentFocus structure is inspected prior to UI interactions to detect crashes/freezes. The timestamp of the crash/freeze (if any) is also recorded. For crashed apps, we extract error logs using logcat  (frozen apps do not produce any error logs). If an app crashes at startup, we try to rerun the app up to five times before skipping it. If the app crashes during execution, information collected so far is saved. When the app analysis completes, we save the analysis data on the device, if any (i.e., pcap file, and files created by the apps).

# 4 User interface interaction
We implement this module by extending the AndroidViewClient library that is designed to automate test scripts. AndroidViewClient provides UI based device interaction APIs (e.g., find, click, fill). To find UI elements, it requires matching (exact/partial) keywords in a predefined list with UI element labels. Therefore, proper knowledge of the app view is required to determine what keyword list to use.

# 4 UI element finder
We use the dump function in AndroidViewClient to get the foreground window content that contains all the window elements. If the element text in the UI window is non-English, the specific language is automatically detected and translated by googletrans . To speed up the translation process, we store the translation result (i.e., original text and its English translation) in a database. We check this database before using googletrans for determining the translation of non-English text in the foreground window of the next app.

# 4 UI element selection
We create two separate lists for clickable and fillable elements. The priority of selecting an element from these lists depends on the order of the elements in them (e.g., the keyword not now has a higher priority than click). The priority of an element depends on the order of appearance in the UI, e.g., accept/submit elements will appear after clicking agree (detailed in ). We create the priority order list based on our observations from manually exploring several apps. We then match the elements in the keyword list (based on the priority order) with the elements of app UI in foreground.

The clickable list contains the popularly used keywords in terms of clickability, with an optional exclude keyword list for each keyword to prevent interacting with similar words — e.g., keyword agree has an exclude list that contains agreement and disagree. While agree and agreement are similar words, if an element with agree is clicked, then clicking on a disagree element (an opposite action) is not possible. The fillable list contains common keywords along with fillable values — e.g., keyword email with my-mail@email.com value.

To select clickable elements, we consider UI elements with the checkable/clickable property enabled, and have at least one of the following values in class attributes: android.widget.checkedtextview, android.view.view, android.widget.button, android.widget.textview, android.widget.imageview and android.widget.imagebutton. To select fillable elements, we consider UI elements with the android.widget.edittext value in class attributes.