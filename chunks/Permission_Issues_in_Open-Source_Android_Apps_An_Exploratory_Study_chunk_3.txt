After the detection of PRIs, we detect the commits that introduced and fixed each of them. This is a non-trivial task as identifying these issues involves much more analysis than merely examining each committed version with the static analysis tools. The following statuses define each PRI event:
- New. When a PRI is found, we check if it exists in the app at the time of the previous commit. If it does not, starting from the version containing the issue we examine each version of the app in a commit-by-commit fashion to determine the commit that introduced the PRI. Identifying this commit allows us to determine the committer responsible for introducing the PRI.

- Exist. If the detected PRI is also found to exist in the previous and subsequent versions of the app, then we record it as ‘Exist’ since the commit does not modify the state of the issue. These are expectedly observed quite frequently as developers often make a variety of changes to apps that are not permission-related.

- Fix. For every detected PRI, we check if the PRI exists in the subsequent committed version of the app. If it does not exist, we determine the commit that fixed the issue. This is accomplished by starting with the immediately subsequent commit after the version of the app exhibiting the detected PRI and examining its source code using the analysis tools. If the issue is not found, then we mark the current commit as the commit that fixed the issue. If the issue persists, we perform the same process on each subsequent commit until we find the commit that fixed the issue. This enables us to identify the committer responsible for fixing the permission issue. If we reach the last commit of the repository and no PRI fixing commit is found, then the PRI is marked as unresolved.

Demographics information about the detected PRIs and their related commits contextually to the discussion of the results of this study are provided in Section V-A.

# oSARA Tool and Replication Package
We leveraged the open Source Android Repository Analyzer (oSARA) tool  to perform the necessary data collection and analysis for our study. oSARA performs the following tasks: (I) Collects all relevant Android repository information from F-Droid; (II) Extracts all relevant permission information and versions from these repositories; (III) Analyzes each extracted version for PRIs using M-Perm and P-Lint; (IV) When PRIs are discovered, oSARA analyzes previous and subsequently committed files to determine the commit that either added or removed the PRI. Using this commit information, we are able to discern information about the developer performing the commit. Our project website  contains all code developed for the study, the raw dataset (> 6 GB), the schema details of our collected data, and the oracle Apps used to verify P-Lint and M-perm.

# C. Data Analysis
We will next describe the data analysis processes used to answer our research questions.

# RQ1.

We account for all occurrences of each type of PRI and provide an indication regarding their distributions by means of summary statistics. We employ the Fisher’s exact test  to assess independence of observations among occurrences of the four PRIs types. We adopt the Fisher’s test over alternatives (e.g., χ2-test ) due to its robustness when dealing with sparse, unbalanced data . We employ the same test to perform post-hoc analysis, performing all tests for all pairs of populations and adjusting resulting p-values for inflation due to multiple comparisons via the Holm correction procedure . The omnibus Friedman test  is then used to statistically determine if the four types of PRIs exhibit a significant difference. The Friedman test is a non-parametric test for one-way repeated measures analysis of variance by ranks. We use the Friedman test because (i) RQ1 is designed as a 1 factor – 4 treatments experiment, (ii) the collected data is not adhering to the assumptions of the ANOVA statistical test, and (iii) the Friedman test is a non-parametric alternative to ANOVA that does not assume independence of observations . We apply the Conover’s all-pairs comparison test as post-hoc analysis for performing pairwise comparisons among each pair of PRI types . Since we are applying multiple statistical tests, we correct the obtained p-values via the Holm correction procedure . We additionally compute the effect-size of the differences among PRIs distributions using the Cliff’s delta (d) non-parametric effect size measure , which measures how often values in a distribution are larger than the values in a second distribution. Cliff’s d ranges in the interval [−1, 1] and is considered negligible for d < 0, small for 0 ≤ d < 0, medium for 0 ≤ d < 0, and large for d ≥ 0.

# RQ2.

In this phase of the study, we collect the decay time of each occurrence of PRI. The decay time of a PRI represents the number of days in which a PRI is present in the source code of an app. We compute the decay time of a PRI as the difference (in days) between the timestamp of the commit in which the PRI has been fixed and the timestamp of the commit in which it has been introduced in the GitHub repository of the app. In this phase of the study we exclusively consider the PRIs which have been fixed along the lifetime of the app, so that their decay time is meaningful (i.e., the last commit of a PRI includes the actual fix of the PRI and it does not correspond to the last commit within the whole repository).

Summary statistics are used for providing an indication about how decay times vary across the four types of PRIs. The same statistical tests as in RQ1 (i.e., Friedman, Conover, Holm correction and Cliff’s delta) are used for statistically assessing the differences of decay times across PRIs.

# RQ3 – RQ4.

Both research questions RQ3 and RQ4 are based on the concept of a developer’s status. In existing literature, several repository-based metrics for proxying developer’s status (or experience) have been proposed, such as (i) Developer’s Commit Ratio (DCR), defined as the number of contributions made by a given developer for a repository divided by the number of all commits done by all repository’s contributors , (ii) maintainers and contributors defined as those contributors with more than 30% and less than 10% of all repository’s commits, respectively , and (iii) project newcomers defined as those contributors with less than 3 commits in a repository . In this study we use the latter metric, as it has been defined in the literature , , , . Specifically, the status of a developer d at a given commit c in a repository r as:
status(d, c, r) = {
Newcomer,        if nCommits(d, c, r) ≤ 3
Regular,         otherwise
}
where c is the specific commit in r for which we want to calculate d’s status and nCommits(d, c, r) is the number of commits authored by developer d in repository r at the time in which commit c is performed. Intuitively, at a given time, a developer is a newcomer in the context of a given project if she performed no more than 3 commits in the repository, otherwise the developer is identified as a regular contributor. We opted for the status(d, c, r) metric since it is (i) computationally lightweight, (ii) used in the literature, and (iii) independent from the size of the repository r.

To avoid the well-known aliasing problem, i.e., the same developer having multiple identities in GitHub repositories , we apply the heuristic proposed by Kouters et al. for resolving developers using multiple identities when committing on the same repository . This heuristic merges committers with the same email prefix, i.e., the part before the @ symbol. We chose the heuristic proposed by Kouters et al. because, despite its apparent simplicity, there is empirical evidence that it provides a good enough trade-off between performance and simplicity of implementation w.r.t. other heuristics when considering long time frames as in our study. We refer the reader to  for a detailed evaluation of various heuristics for solving the aliasing problem.

To account for project contributors authoring more commits in potentially introducing and/or fix more PRIs, we com-
pute two additional metrics: issuesPerCommit(d, t, r) and issuesPerCommitf(d, t, r) . Both metrics are defined for each type of issue. The first metric is defined as:
issuesPerCommit(d, t, r) = |prisi(d, r)| / nCommits(d, lastCommit(d, r), r), where prisi(d, r) is the set of PRIs introduced by developer d in all commits they authored in r, and lastCommit(d, r) is the last commit authored by d in r. Intuitively, issuesPerCommit(d, t, r) represents the ratio between the total number of PRIs introduced by a developer in a repository and the total number of commits they authored in that repository. The issuesPerCommitf(d, t, r) metric is similar to issuesPerCommit(d, t, r), but it focuses on the number of fixed PRIs.