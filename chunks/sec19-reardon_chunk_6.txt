Android protects access to the device’s MAC address with the ACCESS_NETWORK_STATE permission. Despite this, we observed apps transmitting the device’s MAC address without having permission to access it. The apps and SDKs gain access to this information using C++ native code to invoke a number of unguarded UNIX system calls.

# Unity and IOCTLs
Unity is a cross-platform game engine developed by Unity Technologies and heavily used by Android mobile games . Our traffic analysis identified several Unity-based games sending the MD5 hash of the MAC address to Unity’s servers and referring to it as a uuid in the transmission (e.g., as an HTTP GET parameter key name). In this case, the access was happening inside of Unity’s C++ native library. We reverse engineered libunity.so to determine how it was obtaining the MAC address.

Reversing Unity’s 18 MiB compiled C++ library is more involved than Android’s bytecode. Nevertheless, we were able to isolate where the data was being processed precisely because it hashes the MAC address with MD5. Unity provided its own unlabelled MD5 implementation that we found by searching for the constant numbers associated with MD5; in this case, the initial state constants.

Unity opens a network socket and uses an ioctl (UNIX “input-output control”) to obtain the MAC address of the WiFi network interface. In effect, ioctls create a large suite of “numbered” API calls that are technically no different than well-named system calls like bind or close but used for infrequently used features. The behaviour of an ioctl depends on the specific “request” number. Specifically, Unity uses the SIOCGIFCONF2 ioctl to get the network interfaces, and then uses the SIOCGIFHWADDR3 ioctl to get the corresponding MAC address.

We observed that 42 apps were obtaining and sending to Unity servers the MAC address of the network card without holding the ACCESS_NETWORK_STATE permission. To quantify the prevalence of this technique in our corpus of Android apps, we fingerprinted this behaviour through an error string that references the ioctl code having just failed. This allowed us to find a total of 12,408 apps containing this error string, of which 748 apps do not hold the ACCESS_NETWORK_STATE permission.

# 2Socket ioctl get interface configuration
# 3Socket ioctl get interface hardware address
# 4 Router MAC Address
Access to the WiFi router MAC address (BSSID) is protected by the ACCESS_WIFI_STATE permission. In Section 2, we exemplified side channels with router MAC addresses being ersatz location data, and discussed the FTC enacting millions of dollars in fines for those engaged in the practice of using this data to deceptively infer users’ locations. Android Nougat added a requirement that apps hold an additional location permission to scan for nearby WiFi networks ; Android Oreo further required a location permission to get the SSID and MAC address of the connected WiFi network. Additionally, knowing the MAC address of a router allows one to link different devices that share Internet access, which may reveal personal relations by their respective owners, or enable cross-device tracking.

Our analysis revealed two side channels to access the connected WiFi router information: reading the ARP cache and asking the router directly. We found no side channels that allowed for scanning of other WiFi networks. Note that this issue affects all apps running on recent Android versions, not just those without the ACCESS_WIFI_STATE permission. This is because it affects apps without a location permission, and it affects apps with a location permission that the user has not granted using the ask-on-first-use controls.

# Reading the ARP Table
The Address Resolution Protocol (ARP) is a network protocol that allows discovering and mapping the MAC layer address associated with a given IP address. To improve network performance, the ARP protocol uses a cache that contains a historical list of ARP entries, i.e., a historical list of IP addresses resolved to MAC address, including the IP address and the MAC address of the wireless router to which the device is connected (i.e., its BSSID).

Reading the ARP cache is done by opening the pseudo file /proc/net/arp and processing its content. This file is not protected by any security mechanism, so any app can access and parse it to gain access to router-based geolocation information without holding a location permission. We built a working proof-of-concept app and tested it for Android Pie using an app that requests no permissions. We also demonstrated that when running an app that requests both the ACCESS_WIFI_STATE and ACCESS_COARSE_LOCATION permissions, when those permissions are denied, the app will access the data anyway. We responsibly disclosed our findings to Google in September, 2018.

We discovered this technique during dynamic analysis, when we observed one library using this method in practice: OpenX , a company that according to their website “creates programmatic marketplaces where premium publishers and app developers can best monetize their content by connecting with leading advertisers that value their audiences.” OpenX’s SDK code was not obfuscated and so we observed that they had named the responsible function.

612 28th USENIX Security Symposium USENIX Association
For reference, we report the number of apps and a lower bound of the total number of installations of those apps. We do this for all apps containing the SDK; those apps that do not have ACCESS_WIFI_STATE, which means that the side channel circumvents the permissions system; and those apps which do have a location permission, which means that the side channel circumvents location revocation.

getDeviceMacAddressFromArp. Furthermore, a close analysis of the code indicated that it would first try to get the data legitimately using the permission-protected Android API; this vulnerability is only used after the app has been explicitly denied access to this data.

OpenX did not directly send the MAC address, but rather the MD5 hash of it. Nevertheless, it is still trivial to compute a MAC address from its corresponding hash: they are vulnerable to a brute-force attack on hash functions because of the small number of MAC addresses (i.e., an upper bound of 48 bits of entropy). Moreover, insofar as the router’s MAC address is used to resolve an app user’s geolocation using a MAC-address-to-location mapping, one need only to hash the MAC addresses in this mapping (or store the hashes in the table) and match it to the received value to perform the lookup.

While OpenX was the only SDK that we observed exploiting this side channel, we searched our entire app corpus for the string /proc/net/arp, and found multiple third-party libraries that included it. In the case of one of them, igexin, there are existing reports of their predatory behaviour. In our case, log files indicated that after igexin was denied permission to scan for WiFi, it read /system/xbin/ip, ran /system/bin/ifconfig, and then ran cat /proc/net/arp. Table 2 shows the prevalence of third-party libraries with code to access the ARP cache.

# Router UPnP
One SDK in Table 2 includes another technique to get the MAC address of the WiFi access point: it uses UPnP/SSDP discovery protocols. Three of Peel’s smart remote control apps (tv.peel.samsung.app, tv.peel.smartremote, and tv.peel.mobile.app) connected to 192, the IP address of the router that was their gateway to the Internet. The router in this configuration was a commodity home router that supports universal plug-and-play; the app requested the igd.xml (Internet gateway device configuration) file through port 1900 on the router. The router replied with, among other manufacturing details, its MAC address as part of its UUID. These apps also sent WiFi MAC addresses to their own servers and a domain hosted by Amazon Web Services.

The fact that the router is providing this information to devices hosted in the home network is not a flaw with Android per se. Rather it is a consequence of considering every app on every phone connected to a WiFi network to be on the trusted side of the firewall.

# Geolocation
So far our analysis has showed how apps circumvent the permission system to gain access to persistent identifiers and data that can be used to infer geolocation, but we also found suspicious behaviour surrounding a more sensitive data source, i.e., the actual GPS coordinates of the device.

We identified 70 different apps sending location data to 45 different domains without having any of the location permissions. Most of these location transmissions were not caused by circumvention of the permissions system, however, but rather the location data was provided within incoming packets: ad mediation services provided the location data embedded within the ad link. When we retested the apps in a different location, however, the returned location was no longer as precise, and so we suspect that these ad mediators were using IP-based geolocation, though with a much higher degree of precision than is normally expected. One app explicitly used www.googleapis.com’s IP-based geolocation and we found that the returned location was accurate to within a few meters; again, however, this accuracy did not replicate when we retested elsewhere. We did, however, discover one genuine side channel through photo EXIF data.