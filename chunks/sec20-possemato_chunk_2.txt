# 2 HTTPS and Certificate Pinning
By adopting the “secure” version of HTTP, HTTPS, it is possible to perform network operations over a secure and encrypted channel. Exchanging data using HTTPS (SSL/TLS) ensures integrity, confidentiality, and authenticity over the connection between the application and the remote server. This mechanism works as follows. First, when an application tries to contact a remote server using SSL/TLS, a “handshake” is performed. During this phase, the server first sends its certificate to the client. This certificate contains multiple pieces of information including its domain name and a cryptographic signature by a so-called Certificate Authority (CA). To determine whether the client should trust this CA, the system consults a set of hardcoded public keys of the most important (and trusted) CAs: If the certificate is signed (directly or indirectly) by one of these CAs, the certificate is then considered trusted and the (now secure) connection can proceed; otherwise, the connection is interrupted.

While SSL/TLS is a powerful mechanism, it can be compromised by an attacker within the following threat model:
Threat Model 2. An attacker that can obtain a rogue certificate can perform MITM over HTTPS connections. We consider a certificate to be “rogue” when it is correctly signed by a (compromised) trusted CA without an attacker owning the target domain name.

Attacks within this threat model can be mitigated by implementing Certificate Pinning. Certificate pinning consists in “hardcoding” (or, pinning) which is the expected certificate(s) when performing a TLS handshake with a given server. From the technical standpoint, this “expectation” is hardcoded within the application itself, and the app can thus verify, during the handshake, that the certificate sent from the server matches with the expected one. Even though pinning is a powerful security mechanism, previous works have shown how it is very challenging to properly implement it. In fact, to implement pinning, developers are tasked to rely on a wide variety of libraries, each of which exposes a distinct set of APIs. Handling diverse implementations of pinning may push developers to take some shortcuts: It was shown how it is not uncommon for developers to rely on “ready-to-use,” but broken, implementations of certificate pinning copied from websites like StackOverflow.

These broken implementations might lead to accepting arbitrary certificates without even verifying which CA signed them, or whether the certificate was issued for the given domain. Moreover, it has also been shown how even popular network libraries themselves may fail to properly implement pinning.

# 2 User Certificates
The Android system comes with a set of pre-installed CAs to trust and uses them to determine whether a given certificate should be trusted. These CAs reside in a component named KeyStore. The system also allows the user to specify a UserKeyStore and to install custom CAs. There might be situations where the custom CAs allow to perform a MITM over SSL/TLS connections (see Section 4). However, performing MITM over a secure connection should not always be considered a malicious activity. For example, proxies used to debug network issues rely on the same technique. Self-signed certificates generated by these tools do not have a valid trust chain and thus cannot be verified, and the app would terminate the connection. By adding a custom CA, apps can successfully establish a network connection.

Unfortunately, User KeyStore and self-signed certificates can also be abused by malware. Of particular importance is the emerging threat of “stalkware” (also known as “spouseware”) . In short, this scenario can be exploited by an attacker within the following threat model:
# Threat Model 3
An attacker that has physical access to the device can silently install a new custom certificate to the User KeyStore, and mount MITM (including on HTTPS connections) to spy the user’s activities.

# 3 Network Security Policy
To make the adoption and implementation of “secure connections” easier for a developer, Google recently introduced several modifications and improvements, which we discuss in this section.

The first problem that Google tried to address relates to the installation of self-signed certificates. In very early versions of Android, it was possible to silently install one of these certificates, thus allowing anyone who controls it to perform MITM on SSL/TLS connections. In Android 4, however, Google introduced the following change: if a self-signed certificate is added to the device, the system would display a warning message informing the user about the risks and consequences of MITM on SSL traffic . However, since there might be scenarios where trusting a (benign) self-signed certificate is necessary (e.g., to perform network debugging), Google decided to split the KeyStore into two entities. The first one, named System KeyStore, is populated with pre-installed CAs, while the second one, named User KeyStore, allows the user to install self-signed certificates without altering the System KeyStore.

The second problem Google tried to mitigate is the adoption of cleartext protocols . Starting from Android 6, Google introduced a new security mechanism to help apps preventing cleartext communication, named Network Security Policy . With this new policy, an app can specify the usesCleartext-Traffic boolean attribute in its manifest file and, by setting it to false, the app can completely opt-out from using cleartext protocols, such as HTTP, FTP, IMAP, SMTP, WebSockets or XMPP . Moreover, from Android 7, the new default is that apps do not trust CAs added to the UserKeyStore . It is possible to override this default, but the developer needs to explicitly specify the intention of using the User CAs within the policy.

Note that, from an implementation point of view, the policy is not enforced by the operating system (as it would be impractical), but it is up to the various network libraries to actually honor it (e.g., by interrupting an outbound HTTP connection if cleartext traffic should not be allowed). Note also that, to address backward compatibility concerns, for an app targeting an API level from 23 to 27 (i.e., from Android 6 to Android 8), the default value of the usesCleartextTraffic attribute is true. However, if an app targets API level 28 or higher (i.e., Android 9+), then the default for that attribute is false, forcing developers to explicitly opt-out from this new policy in case their apps require HTTP traffic.

While this policy is a significant improvement, for some apps it may currently be impractical to completely opt-out from cleartext communications. In fact, this policy follows an “all-or-nothing” approach, which might be too coarse-grained. This is especially true when a developer is not in complete control of its codebase, such as when embedding closed-source third-party libraries. In fact, these third-party libraries may reach out to remote servers using cleartext protocols or to some domain names that are not even supporting HTTPS. To allow for a more granular specification, with the release of Android 7, Google introduced an extended version of the NSP, which we discuss next.

# 3 Policy Specification
The new version of the NSP, introduced by Google in Android 7, has undergone a complete redesign . The policy now resides on an external XML file and it is not mixed anymore with the AndroidManifest. The most interesting feature introduced in this new version is the possibility to specify additional network security settings other than allowing or blocking cleartext protocols. Moreover, to overcome the lack of granularity of the previous version, the policy now allows for more customizations through the introduction of the new base-config and domain-config XML nodes. The semantics of these two nodes is the following: all the security settings defined within the base-config node are applied to the entire application (i.e., it acts as a sort of default); the domain-config node, instead, allows a developer to explicitly specify a list of domains for which she can specify a different policy. Cleartext. Allowing or blocking cleartext protocols can now be easily achieved with the cleartextTrafficPermitted attribute. Moreover, the developer can decide “where” to apply.

# 3 Towards HTTPS Everywhere
Starting from Android 7, at apps’ installation time, the system checks whether the developer did define a policy: if yes, it loads the policy; otherwise, it applies a default one. Note also that if a policy is defined but it does not specify a node or an attribute, the system fills the missing values by inheriting them from a similar node, or, when none are available, from the default configuration. The default values applied by the system do change over time depending on the target API level and are becoming stricter—and by forcing app developers to target high API levels to be admitted on the official Play Store, Google is leading a push towards HTTPS everywhere. We now discuss how these default values change depending on the target API level.