- Open to Piggybacking
Android apps are often easy to repackage. Issue: Adversaries could add their malicious code to a benign app before repackaging it. Consequently, depending on the original app’s popularity, users can be infected when installing a seemingly benign app that has evaded the analyses of leading app markets. Symptom: No technique (e.g., watermarking, signature checking) is applied to hardening repackaging. Mitigation: Leverage obfuscation to make retro-engineering of apps harder. Also, verify the app’s authenticity before any sensitive operation.

- Unnecessary Permissions
The use of protected features on Android devices requires explicit permissions, and developers occasionally ask for more permissions than necessary. Issue: The more permission-protected features an app can access, the more sensitive data it can reach. Consequently, a more permission-hungry app may expose users to additional security risks. Symptom: The manifest file contains permissions for APIs that are not used. Mitigation: Utilize tools like PScout6 to exclude from the manifest file any permission whose corresponding API calls are absent in the app.

6 http://pscout.csl.toronto.edu
# B. Security Invalidation
- Weak Crypto Algorithm
The fundamental set of cryptographic algorithms can be categorized into symmetric, asymmetric, and hash functions. Issue: Each category includes several algorithms, each of which may have various features and attack resilience. Consequently, incautious adoption of an algorithm could subject to security issues. Symptom: The use of weak cryptographic hash functions like SHA1 or MD5, insecure modes e.g., ECB for block ciphers. Mitigation: Consult the state of the art guidelines to choose an appropriate cryptography, and utilize expert systems.

- Weak Crypto Configuration
The majority of security breaches come from exploiting developer’s mistakes. Issue: Cryptography APIs are widely perceived as being complex with many confusing options . Consequently, a strong but poorly configured algorithm could jeopardise the in-place security. Symptom: Each algorithm has different parameters, and cryptographic parameters in each library could have different defaults. PBE (password-based encryption) with fewer than 1000 iterations, short keys and salts, or none random seeds and initialisation vectors are common mistakes. Mitigation: Use libraries that provide strong documentation and working code examples, and rely on simplified APIs with secure defaults.

- Unpinned Certificate
Digital certificates are needed to ensure secure communication. Unpinned certificates are easy to maintain and are frequently used in the appified world . Issue: Ensuring the authenticity of a certificate is non-trivial, if it is not pinned. Consequently, an app may inadvertently end up trusting a certificate issued by an adversary who has intercepted network communication. Symptom: The app uses unpinned certificates. Mitigation: Pinning certificates are always recommended to increase the security.

- Improper Certificate Validation
Android provides a built-in process for validating the certificates signed by the trusted Certificate Authorities (CA). Issue: In other cases, e.g., when a certificate is self-signed, the OS devolves this validation process to the app itself. However, developers often fail to implement it properly . Consequently, this leaves the communication channel over SSL/TLS insecure and susceptible to man-in-the-middle attacks . Symptom: The presence of a X509TrustManager or a HostNameVerifier that does not perform any validity check. The TrustManager may only use checkValidity to assess the expiration of a certificate without any further check, e.g., verifying the certificate’s signature or asking the user consent to trust a self-signed certificate. Overridden onReceiveSslError in Web-View which ignores any certification errors. Mitigation: Ensure the certificate chain is valid i.e., the root certificate of the chain is issued by a trusted authority, none of the certificates in the chain are expired, and each certificate in the chain is signed by its immediate successor in the chain. Moreover, the certificate should match its designated destination, i.e., the “Common Name” field or the “Subject Alternative Name” in the certificate should match the domain name of the server being connected to. Finally, utilize network security testing tools like “Nogotofail” to examine your communication.

- Unacknowledged Distribution
Google Play, Google’s official marketplace for Android, strives to identify potential security enhancements when an app is uploaded to it. However, developers may distribute their packages via other channels to circumvent out-of-order updates, bypassing the slow release cycles and security restrictions of this market place. Issue: The protection provided by Google, including code and signature checks, is neglected. Consequently, the risk of distributing a vulnerable app increases especially when the app utilises uncertified libraries, or in a worse case, an attacker can replace installation packages with malicious ones . Symptom: The android.permission.INSTALL_PACKAGES permission exists in the manifest. Mitigation: Distribute your apps and updates exclusively through official app stores that perform security checks.

# C. Broken Access Control
- Unauthorised Intent Receipt
An intent is an abstract specification of an operation that apps can use to utilise the actions provided by other apps. An explicit intent guarantees communication with the specified recipient, but it is the Android system that determines the recipient(s) of an implicit intent among available apps. Issue: Any app that declares itself able to serve the requested operation is potentially eligible to fulfill the intent. Consequently, if such an app is malicious, a threat called intent hijacking could arise in which user information carried by the intent could be manipulated or leaked . Symptom: The existence of an intent with private data, but without a particular component name (the fully-qualified class name). Mitigation: Only use explicit intents for sending sensitive data. In addition, always validate the results returned from other components to ensure they comply with your expectation.

- Unconstrained Inter-Component Communication
One app can reuse components (e.g., activities, services, content provider, and broadcast receivers) of other apps, provided those apps permit it. Issue: Android apps are independently restricted in accessing resources. Consequently, a threat called component hijacking arises when a malicious app escalates its privilege for originally prohibited operations through other apps that access those.

# Current Page Content
# 1. Operations
Symptom: The existence of the intent-filter element or android:exported = true attribute in the manifest file without any permission check to ensure that a client app is originally permitted to receive that service. Mitigation: Exclusively export components that are meant to be accessed from other apps and avoid placing any critical state changing actions within such components. Enforce custom permissions with the android:permission attribute to prohibit access from apps with lower privileges. Finally, use tools like IccTA, which detects flaws in inter-component communication.

# 2. Unprotected Unix Domain Socket
Android IPCs do not support cross-layer IPC, i.e., communication between an app’s Java and native processes/threads. To circumvent this limitation developers resort to using Unix domain sockets. Moreover, developers may reuse Linux code that already utilizes such sockets. Issue: Developers are barely guided to protect Unix domain sockets with appropriate authentication. Consequently, adversaries are capable of abusing these exposed IPC channels to exploit vulnerabilities within privileged system daemons and the kernel. Symptom: The server socket channel accepts clients without performing any authentication or similarly a client connects to a server without properly authenticating the server. Mitigation: Enforce proper security checks when using the sockets.

# 3. Exposed adb-level Capabilities
Android Debug Bridge (adb) is a versatile tool that provides communication with a connected Android device. Many developers opt for adb-level capabilities to legitimately access a subset of signature-level resources. Issue: For this purpose, an app communicates locally with an adb-level proxy through the TCP sockets opened on the same device, which exposes the adb server to any app with the INTERNET permission. Consequently, a malign app with ordinary permissions can command the adb and establish serious attacks. Symptom: The existence of adb-specific commands or TCP connection to local host in the code. Mitigation: Avoid using adb-level capabilities in your app, as it is also prohibited since Android 6.

# 4. Debuggable Release
During app development there exist two major build configurations, debug and release. The first is meant for active development, while the latter is for signed in-market releases. However, developers may forget to switch to release mode before publishing an app. Issue: Apps shipped with debugging enabled always try to connect to a local Unix socket opened by the Android Debug Bridge (adb). While adb is not running on every consumer device, a malign app could disguise itself as an adb service and connect to random debuggable apps. Consequently, a malicious app is able to gain full access to the Java process and can execute arbitrary code in the context of the debuggable app. Symptom: The manifest file contains the attribute android:debuggable = true. Mitigation: The debug mode should be disabled in the signed release version i.e., either the debuggable attribute should not exist in the manifest file, or its value should be false. More recent build environments already perform this task automatically.