# Third-Party Library Detection
To investigate the security risks associated with using advertising libraries in mobile apps, early studies rely on a whitelist-based approach. Li et al. extend this concept to cover a general set of libraries. After manually collecting directory and package names of known libraries in a list, it is used to find matches in apps at a large scale. As such approaches fail if obfuscation techniques are used, more elaborate solutions based on machine learning and clustering have been proposed. PEDAL trains a classifier to detect libraries using features extracted from code. AdDetect, AnDarwin and WuKong build on the assumption that a library consists of only one package and segregate package hierarchies into distinct clusters. LibRadar augments the result by assigning each cluster a unique profile representing a library. However, the lack of ground truth and the use of heuristics comes at the cost of precision and does not consider partial library inclusions, e.g., as a consequence of code optimizations. Considering potentially obfuscated package names and deviating package hierarchies, LibD extracts features from code based on method invocations and inheritance relations within classes. Compared to them, our solution also relies on opcode sequences to find and match similar code fragments. However, in contrast to their approach, we can also match partial library occurrences as our fingerprints are composed independently of class inheritance or method overloading.

Tackling the prevalence of code obfuscation, LibScout comes closest to this work. Backes et al. leverage both method signatures and the package hierarchy structure to build profiles per library. An algorithm transforms method signatures into obfuscation-invariant fuzzy descriptors by removing identifiers and class types. These descriptors are then hashed and fed into a Merkle tree, representing the package hierarchy. Although their solution exhibits similar premises and requirements as ours, the differences are in how the overall problem has been approached. Besides obfuscation-invariant method signatures and symbolic package hierarchies, we also add features from the code implementation. While LibScout cannot handle libraries where more than 40% of the original code has been removed, fingerprints built on elements in the Abstract Syntax Tree enable us to recognize not only full libraries but also individual code snippets and library parts. At the same time, our approach helps to improve recognition rates if a shrinking code transformation has been applied. Consequently, our solution does not necessarily need large amounts of ground truth for matching and also works if at least a certain amount of code is available. Nonetheless, LibScout is expected to scale better as its approach to compare packages involves a smaller feature set than ours.

# Obfuscation-Resilient Code Recognition in Android Apps
ARES ’19, August 26–29, 2019, Canterbury, United Kingdom
# Code Clone Detection
Malicious Android applications are often distributed by repackaging legitimate apps . The problem of uncovering small differences between two program versions is commonly referred to as clone or plagiarism detection and conceptually exhibits requirements similar to code recognition. Techniques for clone detection work on semantic and syntactic features of programs and measure the similarity of code based on tokens , parsing trees , or dependency graphs . Similar to our method, they coalesce code attributes to form a fingerprint that can then be pair-wise tested for equivalence with other candidates.

In a study, Potharaju et al.  investigate how attackers can leverage social engineering techniques and app repackaging to distribute malware in the Android market stores. They propose to compute fingerprints based on features extracted from the AST of methods. Therefore, the Android app archive is first transformed into a custom assembly language, followed by pruning the code of each method body, keeping only references to method calls and replacing all variable identifiers with the placeholder local for local variables or param otherwise. Of all method signatures, only the number of used arguments is preserved. The remaining instructions are then arranged as AST and used to derive a fingerprint vector. The algorithm leans on the hypothesis that two apps are similar if their fingerprints are located within a small neighborhood.

In our work, we adopt the concept as it yields a high detection rate with only 0% false positives and solves a problem that is close to ours. One advantage of working with feature vectors instead of full ASTs is the fact that comparing method becomes substantially cheaper than detecting graph isomorphism or computing the tree editing distance between ASTs . As their algorithm creates an app fingerprint as a sum of all method fingerprints, it requires that all code is present during matching. In our case, however, this requirement is not satisfiable as we assume that libraries and code parts may be incomplete or could have been removed during compilation. We, thus, design our own similarity metric that is resilient to common code transformations.

# App Code Obfuscation
In a survey from 2018, Wermke et al.  analyzed 1 million Android apps regarding the use of obfuscation techniques. According to the authors, 24% of apps are obfuscated, whereas the most prevalent obfuscation system is ProGuard. While the authors confirm that identifier renaming of classes, methods, and fields is among the most popular features, they make no statements about minified or shrunken apps. Nonetheless, in our solution, we address all variants of code obfuscation and optimizations that ProGuard offers to developers.

Most research of obfuscation in Android apps concentrated on reversing  and analyzing applications in spite of obfuscation . More recent studies specifically focus on obfuscated malware, such as a study by Hammad et al. , who assessed the impact of obfuscation on Android anti-malware products by inspecting 7 obfuscation strategies and 29 techniques. Also in this context, the work of Garcia et al.  inspects obfuscation-resilient properties to uncover malware using machine learning.

# 3 SYSTEM DESIGN
We design a static analysis framework to recognize code in Android app archives. The primary functionality can be split into two parts: In the learning phase, our tool is trained with code fragments or libraries. In the matching phase, we automatically analyze a given app and try to recognize code parts using previously learned data. The objectives of our solution can be summarized as follows:
1. If an app includes a library or code fragment, the tool should identify it both by name and version, if known.

2. The tool should work equally with obfuscated code.

3. After analyzing an app, the tool should list packages that resemble previously learned libraries or code fragments with a score indicating how much code has been matched.

# 3 Overcoming Obfuscation
In regular apps, code fragments and libraries can be recognized with reasonable certainty by matching the names of packages, classes, and methods. If code transformation techniques are applied, these identifiers become inconclusive. For a reliable identification nonetheless, we rely on features that (1) are suited to identify a code segment and remain the same for semantically similar sections of code, and (2) are invariant to common code transformations.

With these two properties in mind, our fingerprinting approach, as detailed in Section 4, is based on AST Vectors and Sanitized Signatures. AST vectors are vectors obtained by extracting structural dependencies of a method’s AST. Sanitized signatures result from removing all identifiers from a method signature. These identifiers include the method’s name and the class identifiers in all parameter types and the return type. We combine an AST vector and a sanitized signature to a fingerprint. Consequently, a grouped set of fingerprints can represent a package hierarchy. In the following, we explain how we overcome code transformation techniques.

# 3 Identifier Renaming
In this transformation, the obfuscator replaces debug symbols with meaningless character sequences. If activated during compilation, package names in the app archive will not disclose hints on included libraries. As our solution does not rely on identifiers at all, it is invariant to identifier renaming.

# 3 Shrinking
In this step, an obfuscator removes unused code from an app. In the learning phase, we cannot tell which parts of a library will be removed during app compilation. In preliminary tests, we identified cases where more than 90% of code was pruned. Shrinking does not only decide if an entire package gets in- or excluded; it can also remove unused methods and classes. As all methods in a class and classes in a package can be subject to dead code elimination, we consider this in the fingerprinting process.

# 3 Optimizations
Code optimizations involve adding, replacing, rearranging and removing code fragments. Although some of them can affect our features in theory, we can show in our evaluation all of these modifications have a minor impact on detection rates. Basically, a slight change in the AST vector does not necessarily inhibit a correct mapping, since the similarity between AST vectors is based on their distance. However, a sanitized signature that has been altered cannot lead back to the original method, since we check for strict equality when comparing signatures.