# An Empirical Study of SMS One-Time Password Authentication in Android Apps
Siqi Ma, Runhan Feng, Juanru Li, Yang Liu
CSIRO, Shanghai Jiao Tong University, Xidian University
siqi.ma@csiro.au, {fengrunhan,jarod}@sjtu.edu.cn, xdly9491@gmail.com
Surya Nepal, Diethelm Ostry, Elisa Bertino, Robert H. Deng
CSIRO, Purdue University, Singapore Management University
bertino@purdue.edu, robertdeng@smu.edu.sg, {surya.nepal,diet.ostry}@csiro.au
Zhuo Ma
Xidian University
mazhuo@mail.xidian.edu.cn
# ABSTRACT
A great quantity of user passwords nowadays has been leaked through security breaches of user accounts. To enhance the security of the Password Authentication Protocol (PAP) in such circumstance, Android app developers often implement a complementary One-Time Password (OTP) authentication by utilizing the short message service (SMS). Unfortunately, SMS is not specially designed as a secure service and thus an SMS One-Time Password is vulnerable to many attacks. To check whether a wide variety of currently used SMS OTP authentication protocols in Android apps are properly implemented, this paper presents an empirical study against them. We first derive a set of rules from RFC documents as the guide to implement secure SMS OTP authentication protocol. Then we implement an automated analysis system, AUTH-EYE, to check whether a real-world OTP authentication scheme violates any of these rules. Without accessing server source code, AUTH-EYE executes Android apps to trigger the OTP-relevant functionalities and then analyzes the OTP implementations including those proprietary ones. By only analyzing SMS responses, AUTH-EYE is able to assess the conformance of those implementations to our recommended rules and identify the potentially insecure apps. In our empirical study, AUTH-EYE analyzed 3,303 popular Android apps and found that 544 of them adopt SMS OTP authentication. The further analysis of AUTH-EYE demonstrated a far-from-optimistic status: the implementations of 536 (98%) out of the 544 apps violate at least one of our defined rules. The results indicate that Android app developers should seriously consider our discussed security rules and violations so as to implement SMS OTP properly.

# CCS CONCEPTS
• Security and privacy → Software security engineering; Multi-factor authentication; Software reverse engineering;
# KEYWORDS
Authentication Protocol; Mobile Application Security; One-Time Password Authentication; Vulnerability Detection
# ACM Reference Format:
Siqi Ma, Runhan Feng, Juanru Li, Yang Liu, Surya Nepal, Diethelm Ostry, Elisa Bertino, Robert H. Deng, Zhuo Ma, and Sanjay Jha. 2019. An Empirical Study of SMS One-Time Password Authentication in Android Apps. In 2019 Annual Computer Security Applications Conference (ACSAC ’19), December 9–13, 2019, San Juan, PR, USA. ACM, New York, NY, USA, 16 pages. https://doi.org/10/3359789
# 1 INTRODUCTION
Many Android apps commonly use password authentication protocols to verify user identity (i.e., authenticating the user with the combination of the username and a static password ). However, in recent years, many security breaches
led to large-scale password leakage1. Moreover, users usually choose weak passwords (e.g., the infamous “123456”) because a secure password is often too complex to remember. Because of such issues, a single password authentication becomes vulnerable to attacks such as brute force or dictionary based search, and thus is not suitable for user login protection.

To address the above security issues, one-time password (OTP, also known as dynamic password) authentication is used. Referred to as two-factor authentication, the enhanced validation requires the user to provide both a static password and a dynamic OTP. The OTP here is used to protect validation systems against typical attacks because attackers must determine and consume each OTP before the legitimate user can do so for each authentication session. Typically, an OTP is generated through a security token or retrieved from the server via a secure channel. For example, Google and Apple use both static passwords set by users and dynamic passwords generated by mobile authenticators (e.g., the Google Authenticator). Another case is the CITI Bank app, which requires both the static password and an additional dynamic password generated by a portable security token.

Designing a secure OTP authentication protocol is, however, challenging and error-prone. The security of OTP authentication is regulated by a number of RFC documents and a secure OTP authentication must satisfy several security requirements. A crucial requirement is how to generate and deliver the OTP securely. For an Android app, it is often too heavyweight and inconvenient to deploy a portable security token or a mobile authenticator. Therefore, generating and transferring OTP through the short message service (SMS) becomes the most prevalent implementation2.

We observed that although several techniques have been proposed to analyze designs and implementations of traditional password authentication in Android apps, seldom studies considered SMS OTP authentications and barely analyzed the implementation security of them. In this paper, we focus on security requirements of the SMS OTP authentication protocol (hereinafter, we refer it as OTP authentication protocol) and conduct an empirical evaluation of the security of user validation systems which implement OTP authentication protocols. The purpose of our study is two-fold: (1) investigating the OTP authentication protocol in the Android ecosystem, and (2) identifying apps which implement vulnerable OTP authentication. We focus on Android apps because Android is the most widely used mobile operating system and a large number of Android apps adopt OTP authentications.

Our goal is to check how well an OTP implementation (including the server side and the app side) complies with a set of OTP authentication protocol rules (hereinafter, it is referred to as OTP rules), which we derive from the best practices outlined in a number of RFCs3. Since these rules are recommended as the best practices for implement secure OTP protocols, we propose a novel analysis system, AUTH-EYE, which determines whether OTP implementations violate our defined OTP rules. AUTH-EYE locates and executes login via an app to trigger the relevant functionalities in server’s validation system and then examines server behaviours (i.e., server requests and responses). Unlike previous code-based approaches using semantic executions and code dependencies, AUTH-EYE only relies on limited app code information (i.e., class names and function names). Moreover, since source code of remote servers is often not available, AUTH-EYE treats each remote server as a black box and thus only checks its authentication system by analyzing the server responses.

We applied AUTH-EYE to assess 3,303 popular Android apps, collected from the top 2 Android app markets: Google Play and Tencent marketplaces. We observed that there are three types of login schemes, only password authentication, only OTP authentication, and two-factor authentication with both password authentication and OTP authentication. Since we only focus on OTP authentication in this paper, AUTH-EYE found 544 apps implemented OTP authentication protocols in total. For the apps with two-factor authentication, we manually registered an account and filled in the corresponding username and password in each app. Surprisingly, AUTH-EYE detected that OTP authentication protocols in 536 (98%) out of the 544 apps violate at least one of our defined OTP rules, and only eight (1%) apps implement their OTP authentication protocols with all OTP rules satisfied. This indicates that developers may not be aware of the OTP security recommendations outlined in the RFCs, and AUTH-EYE can be used to help them implement more secure OTP authentication protocols.

# Contributions:
- We derived a set of OTP rules that developers should follow to implement secure OTP authentication protocol. Those rules are summarized from RFC documents and then used to check implementations of OTP authentication protocols in remote servers.

- We proposed a novel analysis system, AUTH-EYE, to automatically evaluate protocol implementations. In particular, AUTH-EYE conducts an efficient code analysis to locate login Activities in apps, requiring only
Protocols defined in RFC: RFC 4226, RFC 2289, RFC 6238, RFC 1750 and RFC 4086
limited semantic information. It also examines the re-
mote validation system by only analyzing the network (and SMS) requests and responses rather than source code on server sides.

- We tested 3,303 real-world Android apps with AUTH-EYE and found 544 apps adopt OTP authentication, and AUTH-EYE reported that a large notion of those apps violates at least one of our defined OTP rules.

# 2 DEFINITIONS AND OTP RULES
In this section, we introduce the OTP authentication protocols, and explain OTP rules for designing and implementing OTP authentication protocols properly.

# 2 One-Time Password Authentication Protocol
When a user account is created in OTP authentication protocols, the account is bound to the user by the possession of some information specific to the user, such as a mobile phone number or an email address. At login, an OTP is created for the user who must correctly return it. Android apps often use SMS OTP authentication, where the server generates a pseudo-random value as an OTP and sends it via SMS to the mobile phone number in the user’s profile. Such a pseudo-random value is shared only between the server and the user owning the mobile phone. The user then submits the received value to the server for authentication. The unpredictable and unique nature of the pseudo-random value prevents password replay attacks. Two algorithms (namely HMAC-based OTP and time-based OTP) are widely used to generate the one-time password.