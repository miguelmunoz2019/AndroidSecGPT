From the feedback related to the False positive category, we learned that for a small number (2) of cases, the problem of transitive dependency would prevent developers from keeping their project’s dependencies up-to-date because of incompatibility. However, the current dependency management system of Gradle makes it hard for developers to be informed about what are the transitive dependencies of the manually declared dependencies as it automatically downloads sub-dependencies of a given dependency without developers easily noticing it. Developers can check the log console to see what sub-dependencies are downloaded together with the current dependency, yet this is only available in the log console with hundreds of log events. The problem becomes more serious if a transitive dependency has (well known) security problems. Those are totally hidden from developers because they are usually automatically downloaded following the main dependency unless developers specifically exclude them . Thus, even if developers would vet a dependency manually, insecure sub-dependencies that are automatically, non-obviously pulled in when installing the dependency can undermine the app’s security again. This highlights the need for tooling support, as such Up2Dep.

Transitive dependency analysis: Given the crucial information regarding security problems of transitive dependencies, we
# Up2Dep: Android Tool Support to Fix Insecure Code Dependencies
# ACSAC 2020, December 7–11, 2020, Austin, USA
developed an additional feature that thoroughly checks all transitive dependencies of all declared dependencies to: (1) analyze compatibility when suggesting developers to update the declared dependencies, and more importantly, (2) to check and notify developers if any transitive dependencies contain security problems. When Up2Dep detects a declared dependency in a build.gradle file of a project, it checks all transitive dependencies (all sub levels) of the current dependency and queries security related information of these transitive dependencies. If any transitive dependency contains security problems, developers are notified similar to how security problems of the main dependency are communicated (see Section 3).

Analysis Results: Our results reveal that there are 1,209 library versions (belonging to 112 unique dependencies) that have security problems. These dependencies are currently (transitively) used by 9,787 library versions (233 unique libraries) in our data-set. Especially, among 1,209 transitive dependency versions with security problems, 16 contain a publicly disclosed vulnerability. This means even if developers are aware of such libraries with security problems they have no way to find out if their projects are including such insecure dependencies as they are not visible to developers. The latest version of Up2Dep now informs developers about such security problems of both the main dependency and transitive dependencies so that developers can also avoid insecure transitively included library (versions).

# 5 Comparison with Existing Work
In our work, we significantly increased the database of LibScout by a factor of 7x. Furthermore, our database covers the top 100 most popular libraries on Maven repository  which was not considered by LibScout. Most importantly, we provided an effortless synchronization (end-to-end) process that automatically scans for new libraries (versions), analyzes for cryptographic API misuse, then the information on security and updatability of new libraries (versions) are delivered to developers right in their development environment without them having to use extra tools.

Besides, as we extended the rule set of Cognicrypt to include the check for use of http protocol, we have found 20 libraries (8% of all identified insecure libraries), spanning across 93 versions using such insecure protocol. With the original rule-set of Cognicrypt we would have missed the insecure network connection in these libraries.

# 6 DISCUSSION
# 6 Threats to Validity and Future Work
Our work leverages LibScout and Cognicrypt and inherits their limitations. For LibScout the ability to provide suggestions for API changes relies solely on API heuristics, such as name, parameter types, or return types, which do not necessarily guarantee that the suggested API will work as expected. If the semantics or side-effects of a library method change between versions, this could break the functionality of the developer’s app although the app code was compatible at the method signature level with the new library version. Further detecting semantic changes is an open problem that requires effort from different domains, especially software engineering, and is not in the scope of our work. Yet in this work, we show that relying on API changes to derive compatibility among library versions does help developers to keep their project’s dependencies up-to-date, yet it needs further improvement to cover more cases.

While Cognicrypt provides the flexibility to create new rules to detect cryptographic misuse, it is not free of false positives. We found cases where calls to cryptographic APIs are wrapped in custom Java utility classes by the library developer. Cognicrypt cannot completely link the control flow graph of those custom classes to detect if a cryptographic misuse occurs in those cases. This results in Cognicrypt over-approximating the misuse and reporting false positives. In particular, misuse of MessageDigest depends on call sequences and this shortcoming of Cognicrypt in classifying misuse of that class when being wrapped in custom classes might be a contributing factor to the high number of misuses detected for MessageDigest (see Figure 2). However, it is not easily possible to verify such misuse using static analysis and exclude false positives from our results. Once Cognicrypt addresses this limitation, also Up2Dep will provide more accurate warnings to app developers.

Additionally, we currently manually look for publicly disclosed vulnerabilities, which is a tedious task. In future, this could be generally done with a central library repository, e.g., when a vulnerability of a library is disclosed, central library repositories can incorporate and mark the vulnerable versions in their database so that tools like Up2Dep or Lint can automatically retrieve and provide developers feedback in their IDE. However, for the cryptographic API misuse, Up2Dep’s pre-analyzer component automatically crawls newer versions of third-party libraries and runs Cognicrypt to obtain up-to-date results.

Further, the population size of the developers in our evaluation might be perceived as small since we only have 56 developers, of which 23 shared with us their experience in our online survey, and 22 developers provided us feedback in their Android Studio. Our demographic data shows that our evaluation indeed has a population of experienced developers (e.g., 18 of them have developed at least 2 Android apps). However, developer studies  had in the past notoriously a low number of participants as it is not easy to recruit real developers. Besides, most of them were conducted with students as proxies using handcrafted, toy projects which do not necessarily represent the day-to-day real situation that developers often face. In our work, on the other hand, we tried to avoid students as proxies and toy projects as much as possible and gain insights from developing real app projects (external validity). We think the fact that we could recruit this number of developers and keep them using Up2Dep is in part due to the interest and need for such a tool by the developer community. Furthermore, with our feedback in-context option, we obtain valuable feedback from developers on whether Up2Dep works. Given the only small percentage of false positives reported (6%) and 80% of the suggested quick-fixes working as expected, we believe that we have delivered a novel and expedient tool, and can show the impact of such tooling support on real world situations.

Lastly, we abstained from collecting telemetric information on whether developers ignored the quick-fix, since this might be considered too intrusive. Unfortunately, this also precludes us from modeling whether a known security vulnerability or cryptographic misuse warning is a significant predictor for applying quick-fixes and library updates in our evaluation.

# ACSAC 2020, December 7–11, 2020, Austin, USA
# 6 Transitive Dependencies and App Security
While during our evaluation, we did not consider transitive dependencies, we also have seen that the problems of transitive dependency with regards to library updatability is a corner case, e.g., only 2 instances of the false positives. Also existing research  on the updatability of third-party libraries shows that only 1% of the library API could be affected by this problem (referred to as entangled dependencies). Still we see a potential threat to the security of Android apps due to transitive dependencies. We found that (known) security problems of a library could be hidden from developers when the library is included as a transitive dependency of another dependency and this transitive dependency is not communicated as obvious to app developers as needed. While the community is trying its best to find security related problems of third-party libraries, it is also important to keep developers informed on all potential risks associated with a (declared) dependency. We are to the best of our knowledge the first to study the security problems of transitive dependencies and subsequently developed a solution to tackle this problem by alerting developers when they include libraries that have transitive dependencies with security problems.