Library API database: The last version (2) of LibScout contains a dataset of around 250 libraries. In this work, we build on and extend the library database of LibScout. In particular, a library on a third-party repository would usually come with a descriptive file, e.g., pom.xml, and we analyze those files to discover transitive dependencies of the libraries in the LibScout database. A transitive dependency is another library on which the library included by the app developer depends. For instance, the Facebook Login Android Sdk library version 4 declares three transitive dependencies in its pom.xml file: Android AppCompat Library V7, Facebook Core Android SDK, Facebook Common Android SDK. To obtain a list of popular third-party libraries that developers commonly include in their projects, we crawl the F-Droid repository  to extract libraries included in open source apps. In the end, we have a dataset of 1,878 libraries with their version history. We also extend LibScout’s list of publicly disclosed vulnerabilities of third-party libraries. As of July 2019, our list contains 10 libraries with a total of 97 vulnerable library versions.

Determining API Compatibility: To determine the API compatibility between any consecutive library versions, we use the API diff algorithm of LibScout that operates on two sets of public APIs apiold and apinew, where apiold is the API set of the immediate predecessor version of apinew. An API is presented by its signature that consists of package and class name as well as the list of argument and return type, e.g. example.com.ClassB.foobar()java.lang.String. If apiold = apinew two versions are considered compatible. If apiold ⊈ apinew, the newer version has added new APIs but did not remove or change any existing ones. This is also considered as compatible (backwards). Whenever apiold includes APIs that are not included in apinew, a type analysis is conducted to check for compatible counterparts in apinew. Compatible changes also include generalization of argument types, e.g., an argument with type String is replaced by its super type Object. Generalization on return types is normally not compatible and depends on the actual app code that uses the return value. If any of the apiold is not found in the set of apinew, we consider 2 versions incompatible.

# 3 CogniCrypt
We employ the static analysis component of Cognicrypt, namely CogniCrypt_sast, to discover insecure uses of cryptographic APIs within the libraries in our dataset. CogniCrypt_sast takes rules written in the CRYSL language, which define best-practice for secure use of cryptographic APIs, and analyzes Java applications to find any potential violations of the predefined rules.

We choose Cognicrypt instead of other tools, such as , because Cognicrypt and CRYSL are publicly available and provide the flexibility in defining cryptographic rules while other tools mostly provide hard-coded rules, which are not easy to extend. Besides, Cognicrypt provides more comprehensive rules that result in three times more identified cryptographic violations in comparison to previous work , and the analysis finishes on average in under three minutes per application. More importantly, Cognicrypt leverages several extensions  of the program analysis framework Soot , which performs intra- and inter-procedural static analysis that gives Cognicrypt and CRYSL a high precision (88%) and recall (93%).

Cognicrypt’s rule set  includes 23 rules covering Java classes involving cryptographic key handling as well as digital signing. All rules are available on Github . Beside these rules, we have also written an additional rule for http (to check whether a library uses http instead of https to communicate with a server).

# Cryptographic API misuse dataset
We apply Cognicrypt to our dataset consisting of 1,878 libraries. We are able to analyze 1,725 (91%) libraries. It took Cognicrypt more than 3 hours to
0 2000 4000 6000 8000
Number of misuse
# Up2Dep: Android Tool Support to Fix Insecure Code Dependencies
# ACSAC 2020, December 7–11, 2020, Austin, USA
analyze the remaining 153 libraries and we terminated Cognicrypt when processing a library exceeded 3 hours2. Among the 1,725 libraries, 238 (13%) contain at least one cryptographic API misuse, and 70 of those affected libraries (29%) have fixed/removed the cryptographic misuse in their later versions. This means that, developers could easily avoid such (vulnerable) cryptographic API misuse by upgrading their project’s dependencies to the latest version. Figure 2 lists the distribution of the cryptographic API misuse of the libraries in our dataset. The list is headed by MessageDigest (35% of the top 10 misuses). One of the reasons why MessageDigest has a significantly higher number of misuse is that to use it securely, developers (suggested by the Java Cryptography Architecture Standard) must apply a sequence of method calls, e.g, MessageDigest.getInstance(algorithmName) followed by MessageDigest.update(input), followed by MessageDigest.digest(), etc., combined with minimum required length for the offset of the update method. This does not seem trivial to follow. In general, for Java classes such as MessageDigest, SSLContext, and Cipher, developers need to specify an algorithm or a protocol to work with and library developers often use an algorithm or mode of encryption that is considered insecure, such as ECB mode for encryption, or MD5 or SHA-1 for hashing. This puts these classes of misuse among the most common cryptographic API misuses in third-party libraries. Further, we have found 20 cases where the libraries (spanning across 93 library versions) use http to communicate with remote servers.

# 3 Remote Dependency Inspector
Android Studio is built on Jetbrain’s IntelliJ IDEA software. However, the major challenge is the implementation of an Android Studio extension for Up2Dep as it is not well supported and very few documentation is available. To learn how the internal system of Android Studio works, we have to manually read Android Studio source code and examine its APIs (e.g., dynamically run and test them) as well as use reflection to access its internal (private) API to enable the crucial functionality of Up2Dep. To effectively inspect an Android project’s dependency, we need to implement a custom code inspection. With the gradle build system, Android developers need to declare their project’s or module’s dependencies (libraries) in a gradle build file (see Appendix B). This file is written in the Groovy language. This means we need to write an inspection that is able to analyze Groovy code. IntelliJ IDEA provides an abstract class called GroovyElementVisitor that offers plugin authors the options to analyze varieties of Groovy code fragments. For every Groovy-CodeBlock, Up2Dep looks for a dependencies tag and iterates over all declared dependencies to extract group_id, artifact_id, and version string of each dependency (see Section B). Up2Dep then checks if the current dependency is available in our dataset (i.e., it checks if we have pre-analyzed this dependency and if the information about its APIs is available in our database). In case the dependency is available in our dataset, Up2Dep gathers all information about the current version up to the latest version, including information on whether a version has security vulnerabilities. The reason we do this is to not only detect the latest version, but also the latest compatible version in case an incompatibility with the app code occurs while helping developers avoid versions with known security vulnerabilities. At this point, Up2Dep knows if a dependency is outdated and which version is the latest one.

Database maintenance: To allow continuous maintenance of Up2Dep’s database we set a crawler up to run periodically to get new versions of the libraries in our database and subsequently apply Cognicrypt to analyze them for cryptographic API misuse, and LibScout to identify API compatibility between library versions. The updated database is retrieved automatically inside Android Studio to timingly provide developers with updatability and security information about their included third-party libraries. For publicly disclosed vulnerabilities, we update our database manually.