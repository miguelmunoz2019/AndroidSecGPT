# Security-based code smell definition, detection, and impact quantification in Android
Yi Zhong1,2,3 &nbsp; Mengyu Shi1,2,3 &nbsp; Jiawei He1,2,3 &nbsp; Chunrong Fang1,2,3 &nbsp; Zhenyu Chen1,2,3
1State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China
2Shanghai Key Laboratory of Computer Software Evaluating and Testing, Shanghai, China
3Shenzhen Research Institute of Nanjing University, Shenzhen, China
Correspondence: Chunrong Fang and Zhenyu Chen, State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China.

Email: fangchunrong@nju.edu.cn and zychen@nju.edu.cn
Funding information: National Natural Science Foundation of China, Grant/Award Numbers: 61932012, 62141215, 61832009; Science, Technology and Innovation Commission of Shenzhen Municipality, Grant/Award Number: CJGJZD20200617103001003; Shenzhen Fundamental Research Program, Grant/Award Number: 2021Szvup057
Received: 23 October 2022 &nbsp; Revised: 9 July 2023 &nbsp; Accepted: 5 August 2023
DOI: 10/spe
# Abstract
Android’s high market share and extensive functionality make its security a significant concern. Research reveals that many security issues are caused by insecure coding practices. As a poor design indicator, code smell threatens the safety and quality assurance of Android applications (apps). Although previous works revealed specific problems associated with code smells, the field still lacks research reflecting Android features. Moreover, the cost and time limit developers to repairing numerous smells timely. We conducted a study, including Definition, Detection, and Impact Quantification for Android code smell (DefDIQ): (1) define 15 novel code smells in Android from a security programming perspective and provide suggestions on how to eliminate or mitigate them; (2) implement DACS (Detect Android Code Smell) to automatically detect the custom code smells based on ASTs; (3) investigate the correlation between individual smells with DACS detection results, select suitable code smells to construct fault counting models, then quantify their impact on quality, and thereby generating code smell repair priorities. We conducted experiments on 4575 open-source apps, and the findings are: (i) Lin’s CCC between DACS and manual detection results reaches 0, verifying the validity; (ii) the fault counting model constructed by zero-inflated negative binomial is superior to negative binomial (AIC = 517, BIC = 522); some smells do indicate fault-proneness, and we identify such avoidable poor designs; (iii) different code smells have different levels of importance and the repair priorities constructed provide a practical guideline for researchers and inexperienced developers.

# K E Y W O R D S
Android code smell, quality assurance, repair priority, security
# 1 INTRODUCTION
The widespread popularity of Android smartphones and other mobile devices makes the app market dynamic and challenging. Go-anywhere applications support a wide range of financial, social, and enterprise services for any user with a
Abbreviations: AST, abstract syntax tree; Lin’s CCC, Lin’s concordance correlation coefficient; NB, negative binomial; ZINB, zero-inflated negative binomial.

Yi Zhong and Mengyu Shi contributed equally to this study.

© 2023 John Wiley & Sons, Ltd. wileyonlinelibrary.com/journal/spe Softw: Pract Exper. 2023;53:2296–2321.

1097024x, 2023, 11, Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [11/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
ZHONG et al. 2297
cellular data plan. However, as Android evolved, security and quality concerns surrounding various software patterns and poor coding practices have increased. Any security issues in the apps can put the privacy and security of countless users at risk. Insecure code can corrupt data structures, generate or expose security vulnerabilities. For example, unencrypted or weakly encrypted data can be easily stolen by attackers, and some components may have default open permissions that will result in the abuse of some sensitive functions. The security and quality assurance of Android apps become crucial and vital to keep appealing and adapting to new devices. As a metric indicating the suboptimal design, smells are the main culprit. By statistics, Android holds 71% of the market share, about 2 times greater than IOS. The high market share makes Android more vulnerable to attacks by external sources, and security risks from poor programming selections within the code will expose users, and the platform, to varying levels of risk. In this context, code smell emerged as a research hit to identify potentially poor design. Although many works revealed the specific issues related to code smell, research on the definition and identification of Android remains scarce. Unlike traditional software, code smells are distributed differently in Android, and the smells that truly reflect Android characteristics have not been widely studied. Most researchers following the definitions of Fowler et al., and Brown et al., there is an absence of new literature that identifies and defines Android code smells. Simply defining these code smells without detection is often insufficient to help researchers capture actual problems. Constructing code smell detection can better research these irregularities and reduce the associated security risks by code cleaning. Consequently, it becomes challenging and necessary to define and detect more code smells related to security and quality assurance.

In practical software development, massive code smells occur attributed to lousy coding habits and poor design patterns. Some developers prefer to refactor the code when performance issues arise rather than anticipate and repair smells in advance. The costs and time hinder developers from repairing all code smells before they threaten the app’s security, quality, and hardware performance. Research finds that some code smells do indicate fault-prone code, different smells may potentially affect the apps differently, and arbitrary refactoring some smells may increase fault-proneness in some cases. Unfortunately, refactoring code smells without guidance may be a waste of time as repairing the ones with lower importance first. The maintenance cost of apps will increase exponentially with the detection and repair time of smells. Especially after release, with Android’s increasing complexity and scale, labor and costs are expected to rise substantially.

Motivated by these observations, we researched the definition, detection, and static analysis of the importance level for Androids code smell. Specifically, we defined 15 novel Android code smells, marked the parts of the code vulnerable to security risks, and provided suggestions for elimination or mitigation. No existing tool can identify the 15 smells, so we developed our own detection tool–DACS (Detect Android Code Smell) based on AST to identify code smells occurring in a Method body. Besides, we established a dataset of 4575 open-source apps and collected fault information from Github by version control and keywords match. According to what we informed, there is no work to (i) a large-scale survey to collect faults in Android apps, (ii) analyze the impact of Android code smells on the fault occurrence, and (iii) quantify the code smells impact degree and generate repair priority. To obtain the code smell importance level, we investigated the distribution of code smells and fault data in the apps. We constructed fault counting models based on negative binomial (NB) and zero-inflated negative binomial (ZINB), where the arguments are the occurrence of code smells, and the dependent variable is the fault counts in apps. We analyzed the impact of code smells on the magnitude of faults by regression models. Then we filtered smells with low-quality impact by a two-sided hypothesis test to determine the final arguments. By the regression coefficient of the model, we generate the repair priorities for the code smells.

# Definition, Detection, and Impact Quantification for Android code smell (DefDIQ)
is dedicated to reducing security risks, lowering technical debt, and enhancing code cleanliness. The fault-centric code smell repair priority provides insight into the quality and security assurance of Android apps. This work helps guide developers to identify common security structure issues and promulgate the impact of programming choices in creating secure apps. The main contributions are as follows.

- Definition. We defined 15 novel Android code smells from the perspective of coding specifications, programming practices, and code features related to Android security and found the relationship between smells and faults, which will assist developers in discovering more poor designs and obtaining high-quality, low-risk apps.

- Tool. We developed DACS to automatically identify targeted code representing the custom-defined smells by establishing smells rule library. The Lin’s concordance correlation coefficient (Lin’s CCC) between DACS and manual detection results reached 0, verifying its effectiveness.

1097024x, 2023, 11, Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [11/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
2298 ZHONG et al.

# Repair priority
We constructed fault counting models to quantify the importance of code smells by taking faults as a carrier with NB and ZINB. First, we find ZINB is a better modeling technique for investigating the relationship between faults data and code smells (compared to NB). Third, we quantify 15 code smells and generate repair priority, which provides a practical guideline for inexperienced developers to remediate smells timely and enhance the benefits.