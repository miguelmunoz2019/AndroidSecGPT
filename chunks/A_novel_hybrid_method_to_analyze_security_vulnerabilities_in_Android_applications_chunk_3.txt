# 3 Dynamic vulnerability analysis
# 3 Dynamic executable script
# (1) Script generation
We implement an automated test method to drive the target application to execute a customized test path. Two kinds of approaches are used for Android automated testing. One is based on the UIAutomator, and can only simulate and trigger corresponding events to operate on the target application but cannot directly obtain the attributes of each element of the target application to operate. The other kind of approach is based on the instrumentation framework, in which the process being tested and the target application are run as two threads in the same process. Without triggering any events, the individual elements can be accessed internally and the corresponding data can be modified. We select
# Dynamic Vulnerability Analysis and Script Generation
The second method and extend our system based on Robotium, which is an open source automated testing framework using instrumentation. Cafe is based on Robotium with more features and supports real-time recording of user actions in target applications. We perform a secondary encapsulation on the Cafe to further simplify its complex operations and generate custom executable scripts.

We can create rich test cases with instances of the solo object in Robotium. The core difficulty of the dynamic vulnerability analysis is how to reduce the manual operation but achieve a more intelligent and automated generation of executable scripts and drive the target application to run the corresponding program logic. By extending the Cafe framework, we have completed the automatic generation of manual operation script and accurately recorded the manual operations. In this way, we not only avoid the tediousness and mistakes of writing scripts manually but also expand our analysis system on the basis of such scripts. The basic script can be modified based on different vulnerability analysis requirements to complete a more efficient dynamic analysis. The main idea of the automatic recording and generating script is to continuously listen to various operations (including clicking, sliding, and input, etc.) on the view of the target application, and then automatically generate corresponding codes based on the API representation provided by Robotium according to the types of each operation and widget. The view represents an area of the interface that the current user inspects, and it can contain multiple widgets that can interact with the user. For cases where the widget is not recognized, we can use coordinates-based click operation instead. The scripts based on coordinate may not be accurate enough, thus causing failure of operations.

We design new executable scripts to be expressed in the XML format. As shown in Fig. 2, a script mainly contains the main activity and package name information of the target application and the test case information based on the individual operation events of Robotium. These operational events can be clicks, inputs, swipes, waits, screenshots, and so on. The tag TestCases can contain multiple TestCase tags. The attributes in a TestCase tag contain the name of the TestCase, whereas the contents of the tag contain various action events, which are generated automatically by our script generation module. We can extend and modify these generated basic scripts in accordance with the corresponding requirements of security vulnerability analysis. For example, these changes could include the addition of clicks, swiping actions, modification of the input, inclusion of a delay interval of two steps, looping actions, and so on.

# Script Execution
The process of script execution enables the target application to reproduce the various operations written in our scripts. The main principles are instrumentation and the Android test project (Android developer documentation now recommends AndroidJUnitRunner instead of the Android test project). The test application connects the target applications with the instrumentation tags in its manifest.xml file. The targetPackage attribute determines the package name of the target application. The test and target applications interact through InstrumentationTestRunner and run in the same process. In general, applications with different signatures run in their own independent Dalvik process. Thus, using the same signature to re-sign the test application, the target application is necessary.

In general, the life cycle of components is controlled by the Android system. Functions, such as onCreate, onResume, and onStop in the activity life cycle, are all called by the system itself, and the Android application framework provides no APIs with the permissions for users to call directly. However, by using instrumentation, we can create instrumentation of system objects, such as context, before the target application is formally started. We can control the life cycle of the components in the target application, generate and send simulated user and
# Junwei Tang et al.: A Novel Hybrid Method to Analyze Security Vulnerabilities in Android Applications
system events to the target application, and monitor the running states at the same time. Our script execution module automatically generates the corresponding Android test project based on instrumentation and extracts the corresponding content of the script. Then, the corresponding Java code of the Android test project is generated. After automatically compiling the project with the command line compilation tool, we generate the test APK file. After installing both the test and target APK files and passing the information of the main activity of the target application when launching the test application, the script drives the target application to perform the corresponding operations. Figure 3 shows the principle of dynamic executable scripts.

# 3 Hook and analyze related methods
To document important information about security vulnerabilities at runtime, we use the Xposed framework to hook related important methods to record information about these vulnerabilities. For example, we hook the findClass method in BaseDexClassLoader and record the call of this function, and then verify the existence of the vulnerability in accordance with our vulnerability patterns. Through our dynamic script, the target application is automatically driven, and several running state information is recorded during the execution process to comprehensively verify the existence of the vulnerability. The hook APIs, call records, and other information to be recorded can be defined based on a specific vulnerability pattern. These information can be easily expanded on the basis of the requirements of verification vulnerabilities.

# 3 Result analysis
The results of our vulnerability detection system based on the hybrid analysis approach are obtained by synthesizing the information of the above analysis process. Among the analysis approaches, the static analysis will give a considerable part of the vulnerability analysis results. Meanwhile, the dynamic analysis plays two roles: It not only performs further dynamic validation of partial results of static analysis but also analyzes several types of vulnerabilities that are hard to be detected directly by static analysis.

Static analysis cannot detect certain types of vulnerabilities, and it faces problems such as failure to verify the existence of vulnerabilities. However, the dynamic analysis is not only expensive but also difficult to detect certain types of security vulnerabilities. Our hybrid method can avoid these shortcomings. Avoidance of such issues is the difference between our hybrid method and running two independent analyses. The whole process makes our hybrid approach more comprehensive and effective than individual analysis methods.

# 4 Evaluation
# 4 Dataset and success rate of decompilation
# 4 Vulnerability detection
To evaluate the vulnerability detection effect of our system, we have designed several experiments to test the static and dynamic analyses of the whole system, and point out two application scenarios of our dynamic executable scripts, including further verification of results of static analysis and detection of vulnerabilities that are hard to be detected by static analysis alone. Finally, by combining with all the results, we give the overall analysis situation of our system.

# 4 Static analysis results of our system
In this section, we will separately analyze our static vulnerability detection results on the malicious application dataset Drebin and our collection of real-world application datasets. Our static analysis can detect eight types of vulnerabilities.

# (1) Static analysis results on Drebin
Among 5560 malicious applications on the Drebin dataset, our system successfully analyzes 5547 malwares. Through metadata and data flow analyses, we separately obtain the number of malicious applications under each category of vulnerability. Figure 4 shows the distribution of these numbers. The statistical results show that most malicious applications have potential vulnerabilities contain one type of vulnerability; 40%, two types of vulnerabilities or more; 13%, three types of vulnerabilities or more; 0%, four types of vulnerabilities or more. No application includes five or more than five types of vulnerabilities. The analysis of the 5547 malwares lasts for 2064 s, averaging 4 s per application.