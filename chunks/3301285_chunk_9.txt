# 3 Non-Verification of SSL Certificate
For establishing a secure connection via SSL, the first and foremost step is to authenticate the server certified by a trusted Certificate Authority. It is essential to check the validity of the server’s authentication, and sometimes a certificate is revoked by the CA in the case where a server has been compromised or is not behaving as per the norm. In Reference , rules for developing and validating certificates are defined based on the X protocol. This document also explains how to check whether the CA has revoked the certificate. The status of the certificate can be checked using the Online Certificate Status Protocol (OCSP) . OSCP provides up-to-date information regarding the status of the certificates as compared to the Certificate Revocation List (CRL) . In Reference , researchers found that many critical applications and libraries were not verifying the SSL certificate at all. A list of software found violating the SSL certificate validation included Amazon’s EC2 Java library and all cloud clients based on it: Amazon’s and PayPal’s merchant SDKs, integrated shopping carts, and AdMob code. For example, AdMob provided code that used data-transport library cURL for connecting SSL to AdMob’s server, however, the code would turn off the SSL certificate validation. In this article, the author has also listed the “dos” and “don’ts” for the application and SSL library developers. Further, while analyzing 137 of 200 applications , which used SSL, it was found that 84 applications used SSL incorrectly. Of 137 applications, in 58 applications, TrustManager used Trust All strategy, and in 13 applications, HostnameVerifier used the Allow All strategy. The remaining 13 applications used both the strategies (Trust All and Allow All). SSL code uses TrustManger and HostnameVerifier classes for verifying and validating server. If the application uses Trust All with Trust-Manager, then it will not require verification of the server. Similarly, if it uses Allow All with the HostnameVerifier approach, then it will not require validation of server.

Vulnerable cryptographic keys and digital certificates were found to be the root cause of such attacks. SSL Blacklisting and Pinning are two methods offered by Android for protecting the system from the threat caused by breached CAs (e.g., Comodo, DigiNotar) and from the use of certificates issued deceitfully. SSL Blacklisting allows blacklisting of certificates and CAs as well. SSL Pinning restricts the number of CAs to be trusted.

# 3 Android Application Security Vulnerabilities
Google has found security flaws in more than 275,000 applications found on the Google Play Store . The App Security Improvement Program notifies the developer quickly whenever it finds a vulnerability. This program started with scanning the Google apps for embedded Amazon Web Services (AWS) credentials and Keystore file. The revelation of credentials and keys were posing grave threats to users’ private information and for data transfer at that time. In reference , the authors have provided a list of the latest security loopholes flagged to developers on Google Play along with the respective vulnerability and solution.

This section has highlighted the common factors that are responsible for the proliferation of attacks that were discussed in Section 2. The next section discusses defensive tools and techniques used to defend the Android system from various attacks and malicious activities.

# 4 ELABORATION OF DEFENSIVE MECHANISMS
This sections will elaborate various defensive mechanism and tools. There are two main approaches for detection and prevention of malicious activity or application. The first mechanism is static, in which the tool can detect the malware or malicious activity before the execution of an application. The second mechanism is dynamic, which detects the malicious activity at runtime. These following subsections will elaborate defensive mechanisms.

ACM Computing Surveys, Vol. 52, No. 1, Article 21. Publication date: February 2019.

# A Survey on Various Threats and Current State of Security in Android Platform
# 4 Tools for Preventing Privileges Escalation Attacks
eXtended Monitoring on Android (XManDroid)  prevents privilege escalation attacks dynamically based on the system policy already defined in the system database. For this purpose, researchers have designed the Policy Check Algorithm, which is embedded in the Decision Maker component of the XMandroid framework. This algorithm keeps track of Inter-component Communication (ICC) among the applications. With the help of policies defined in the policy database that are the security rules, it decides whether it should allow the action or reject it. User confirmation is also taken into account whether to allow ICC call. XMandroid helps in preventing an ICC-based privilege escalation attack. A sample of 50 applications was taken in which XMandroid dynamically observed 11,970 ICC calls that occurred during runtime. The total number of cache hits = 11,592 and cache miss = 378. According to the researchers, the tool performed consistently in cases of ICC between applications as well as in case of ICC with content and service providers.

The Extending Android Permission Model (Apex)  helps users grant permission to applications for accessing resources during runtime selectively. For this purpose, an application installer named Poly is implemented, which is an extension to the already-existing installer in the system. It provides users with an easy interface to imply constraints on access to resources requested by the applications at installation time.

AdSplit (separating smartphone advertising from applications)  separates the advertising libraries from the host application, both run in a completely separate environment. Unique UID and separate permissions are given to applications and the advertising libraries by the UNIX process so that applications need not request for additional privileges for the advertising libraries. Then, for coordination between two processes, an advertising service is there. It keeps track of user actions, performed at UI and sends it to related advertising activity. With the help of a centralized advertising service component, AdSplit can identify any fake UI event, and this component is also responsible for proper display of advertisements. This framework combines two security modes HTML and smartphone applications, which is the current need for smartphone security, as most of the applications and libraries use Java and HTML script.

Like AdSplit, AdDroid (A Privilege Separated Advertising Framework)  also wholly separates the advertising component from the parent application by integrating advertising component into the Android framework itself rather than the parent application. It helps in restricting the advertisement component from gaining access to any security-critical information, even if the parent application has the privilege of accessing the same information. The AdDroid framework achieves this goal by introducing the advertising API (AdDroid API), which is an extension of the Android API, it is responsible for data and application. AdDroid also includes two new permissions, ADVERTISING, and LOCATION_ADVERTISING. For using AdDroid, applications need to request for any of these two permissions. These permissions give requesting application access to the advertising API calls; rest AdDroid handles all the decisions regarding advertising and events related to user interactions. Of 473 advertising libraries of corresponding applications, the functionality of 456 advertising libraries was satisfied by the AdDroid permission system. Thus, a 96% satisfactory rate was achieved.

Component-Level Access Control (Compac) puts a restriction on the privileges, given to the third-party elements at component level. It achieves this by letting the system decide that request from third-party elements for accessing the private information need to be accepted and which not. The system can make the decision based on the information excavated from the application’s components, using runtime information of Java package. Compac gives privilege to the users and system to assign a subset of permission to the application component rather than giving similar access rights to all the components of the application. This approach helps in enhancing the
ACM Computing Surveys, Vol. 52, No. 1, Article 21. Publication date: February 2019.

# Limitation
Permission check can be applied to limited extent by Apex as it does not have access to all the components of the applications.

Taking confirmation from users may be risky sometimes, because user’s lack of knowledge regarding security rules can result in bad decisions.

Applications are still able to send private information to the advertisements running as uniquely identified individual processes.

Lack of flexibility than other existing models.

Difficult to identify Package Forgery attack (Java package name can be forged that can result in bypassing the restrictions on the package.).

Efficiency of separator is reduced if public API code is obfuscated also fails to classify ad libraries in case developers merge self created ad libraries with app logic.

Security of the Android model, in context of the attacks, caused due to third-party libraries or components. The approach achieved 97% success rate in performing privilege escalation (as per Antutu benchmark). The researchers considered a dataset of 18,566 applications in which 16,000 was benign data and remaining 2,566 was malware.

Unlike AdDroid, in Privilege De-escalation (PEDAL)  researchers have included a module, called separator that allows users to assign privileges to ad libraries selectively. This module forbids ad library from inheriting permissions, which are granted to their parent applications by the system at the time of installation. PEDAL achieved 98% accuracy rate in detecting ad libraries.