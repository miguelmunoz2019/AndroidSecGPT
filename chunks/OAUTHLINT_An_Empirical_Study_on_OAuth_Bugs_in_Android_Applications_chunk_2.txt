# B. OAuth 2
Instead of building on top of the existing OAuth 1 protocol, the working group changed the specification completely to create a different protocol, known as OAuth 2. Compared to OAuth 1, OAuth 2 removed obtaining the shared secrets and providing signature as mandatory processes. Instead, OAuth 2 introduced the concept of bearer token . For the bearer token, a users access token was no longer bound to a relying party; any party with this token could access the users protected resource.

In addition, OAuth 2 also offers four different flows, these methods are referred to as grants and they can be viewed as different “versions of OAuth 2. Out of the four OAuth grants, the most popular one is the implicit grant.

In the following, we will use Fig 2 to explain the most popular implicit grant of OAuth 2 . The implicit grant is the shortest of all OAuth 2 flows. It consists of two steps. First, the user is redirected to the service provider to grant the relying party access to his/her protected resource. After the user grants the permission, the service provider redirects the user back to the relying party along with an access token as a parameter in the URI. The relying party can then use this access token to exchange for the users resource. Besides the implicit grant, we find that the authorization code grant is also used in mobile applications we studied. Comparing to the implicit grant, the authorization code grant has additional steps for the relying party to obtain an authorization code and then use the authorization code to exchange for the token.

There are two important differences in the implicit grant comparing to other OAuth flows. First, with exception to the final protected resource request, every message in the protocol is exchanged through the user agent (e.g., using browser redirection or Android Intent). Second, the implicit grant does not require the relying party to present a shared secret to the service provider. This is ideal for the mobile environment, where the relying party resides on an untrusted device.

# Anti-protocols
# OAuthLint
# Taint Analysis
# Secret Tokens
# Callgraph
# Program Facts
# Points-To Analysis
# Callgraph
# Android APK
# C. Using OAuth for authentication
Although OAuth is originally designed for authorization, developers re-purposed it for authentication. Therefore, the way to do authentication using OAuth is never documented in the OAuth standard protocol and developers have to figure out their own ways to run the authentication using OAuth. Typically, they just changed the last step of the OAuth protocol, using the user’s resources to identify the user. Some service providers such as Google and Facebook recognized the limitation of using OAuth for authentication and propose additional steps of verification to improve the security, such as the appsecret proof.

# III. OVERVIEW
In this section, we give an overview of our approach with the aid of a motivating example, and then summarize the threat model in our system.

# A. System overview
a) Pointer analysis: Given the source code or bytecode of an Android application, OA UTH L INT leverages F LOW-D ROID  to perform (field- and object-sensitive) pointer analysis to build a precise call graph and identify all variables that may be an alias to each other. The call graph and alias
# information are further used by the subsequent taint analysis
for generating additional program facts that are relevant to answering the anti-protocols in OAuth.

# b) Taint analysis:
The taint analyzer leverages the annotations in OA UTH L INT’s configuration file to determine taint sources (i.e., secret keys and access tokens) and propagates them using a field- and object-sensitive analysis. Intuitively, a taint flow encodes that a sensitive field (e.g., secret keys) may flow to an untrusted resource (e.g., local storage, WebView, etc.).

# c) Anti-protocols for OAuth:
To find logical flaws due to the misunderstanding of the OAuth protocol, OA UTH L INT first proposes a query language that enables developers to specify anti-protocols. These anti-protocols represent the OAuth-implementation mistakes by developers that may result in severe vulnerabilities such as impersonation attack and users’ privacy violation. Here, each anti-protocol is expressed as a logical formula which encodes a class of vulnerabilities that compromise user’s security and privacy. Section V includes detailed explanation and security impacts of five anti-protocols that widely appear in existing Android apps in Google Play Store. While we propose five anti-protocols using the query language in OA UTH L INT, a security expert can come up with more anti-protocols based on her insight on the standard OAuth specifications. After that, using the program facts generated by our previous analyses, OA UTH L INT leverages a fully-automatic and demand-driven static analysis for checking whether there exists an execution trace such that the anti-protocol holds. If so, a violation will be reported to the developer.

For instance, TikTok, a very popular app for creating and sharing short videos, has over 500 million installs by the time of our submission. To integrate the user accounts from service providers such as Facebook, Instagram, and Google, TikTok implements the standard authentication flow using the OAuth 2 protocol . However, after running OA UTH L INT on TikTok, we found the application contains multiple logical flaws in their implementation for the OAuth protocol.

Firstly, TikTok bundles its consumer key and secret within the application code. The following code snippet from TikTok represents one of the most common ways that developers use to bundle their secrets:
1   final      String CONSUMER_KEY                  =
2         "YYWjeT***...";
3   final      String CONSUMER_SERECT =
4         "w981H5bEd***...";
5   ...

According to the specification in OAuth 1 , the consumer secrets or keys should never be bundled in the clients. The reasons are as follows: first, the consumer secrets are highly sensitive information shared between service providers and relying parties, and service providers will use consumer keys to verify identities of the relying parties. Second, all mobiles devices are technically untrusted, which means that an attacker could extract the consumer secrets through reverse engineering and impersonate a benign replying parties to get access to users’ information.

Moreover, TikTok embeds a WebView to retrieve the access token attached with the redirect URL from Twitter and Instagram.

1    String url = "provider.com/..?
2         client_id=".."
3         &redirect_url=".."
4         &response=token";
5    ...

6    webView.loadUrl(url);
7
8    void onPageStarted(String                       url){
9        String token = parseToken(url);
10   }
When an application hosts service provider’s website inside a Webview, it gets full access to the information such as users’ cookies. Therefore, using WebView for OAuth enables a malicious relying party app to log into a victim user’s account with the service provider. This is due to the fundamental design of isolation in WebView and there is no way for the service provider to protect herself when it was loaded in WebView. Often service providers use long term cookies, which makes such vulnerability persistent.

Furthermore, OAUTH L INT also detects that TikTok exchanges its access token with service providers to fetch the corresponding userId for login purpose.

1    String       user_id        =  fetchUserInfo(token
2                                  , consumer_secret);
3    storeInSharedPreferences(user_id
4                                  , token);
5    ...

6    authorizeUserLogin(user_id);//login
This approach is also vulnerable because any requests made from a client could be potentially tampered by an attacker. Hence, for authentication using OAuth, client devices should not be trusted. According to OAuth 1 and 2, a secure authentication should be made through server-to-server calls.

Finally, after obtaining the userId, TikTok stores both userId and access token as plain text in the SharedPreferences. Here, there are multiple security issues. First, information stored in SharedPreferences is insecure, since they can easily be accessed by another malicious application in a rooted device or emulator. Hence, any sensitive information should not be stored in SharedPreferences. Second, storing sensitive information such as access token as plain text is insecure. According to the suggestion from OAuth 1 and 2, the access tokens should be encrypted and stored on the server side of the relying party.

We have reported all the above-mentioned flaws to TikTok’s security team and they are still working on those issues by the time of this submission.

Authorized licensed use limited to: Pontificia Universidad Javeriana. Downloaded on August 10, 2024 at 05:54:40 UTC from IEEE Xplore. Restrictions apply.

# B. Threat Model
In this paper, we focus on the vulnerabilities in the design and implementation of the relying parties for using OAuth protocols. We assume the service providers are trusted and correctly implement the security schemes for OAuth. For the attacks to authentication, we consider the case where an attacker has the capability of accessing the mobile apps on behalf of the victims. For the attacks to authorization, we consider the case where malicious relying parties seek to access user’s data without consensus.