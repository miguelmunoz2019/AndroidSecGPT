# 5 Approach overview
As depicted in Figure 7, the proposed approach works at two levels. First, at the Application level, it receives a bundle of Android apps, then, at the Model level, it generates useful high-level representations of these apps and their interactions. The main goal of this approach is to provide a better comprehension of the Android system through relevant model-based representations. These representations (models) can then be employed for a variety of purposes, including inter-app security analysis. Note that, At the Application level, both the APK package and source code of the corresponding application are allowed. For the case of the APK package, it will be decompiled to obtain its source code using the Jadx44 tool.

As indicated at the Model level, the proposed approach consists of three main phases: (1) Model Discovery that extracts the initial models from each app without losing any information. These models are detailed enough to be considered as the starting point of various MDRE scenarios, including inter-app security analysis. (2) Transformation and Integration
Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions (https://onlinelibrary.wiley.com/terms-and-conditions) on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License.

# 910 NIRUMAND et al.

# F I G U R E 7
The proposed approach that uses the chain of model manipulation techniques to transform initial models into more manageable representations. This transfer is done by deleting the details that are not relevant to inter-app security analysis. This process, which results in a higher level of abstraction, helps understand Android apps and their interactions better. (3) Analysis that uses the processed models in the previous phase to inter-app security analysis, and finally generates the results in the form of XMI models. In the following, each phase is described in more detail.

# 5 Model discovery phase
Most static analysis methods have used frameworks and tools such as Soot, WALA‡, and JPF § that perform their analysis based on an IR of the code. These tools have various limitations, including considering only a part of the specification of the Android platform. Therefore, the purpose of this phase (i.e., phase 1 of Figure 7) is to provide a comprehensive IR of Android applications. The idea to reach this purpose is to transform from the low-level heterogeneous apps into homogeneous models. In this transition, the artifacts of apps, including Java code and Manifest files, are displayed as a set of interrelated models. For each app, the initial models (i.e., the XML model and the Java model) are obtained through model discoverers provided by the MoDisco tool¶. The created models are considered as inputs for the Transformation and Integration phase. These obtained models represent apps at the same level of abstraction to ensure that no information in this phase is lost.

# 5 Transformation and integration phase
In this phase (i.e., phase 2 of Figure 7), the comprehension of the generated initial models (i.e., the created models in the previous phase) takes place by raising the abstraction level of these initial models using model-to-model (M2M) transformations written in ATL language and obtaining higher-level representations of the Android system.

‡https://researcher.watson.ibm.com/researcher/view_page.php?id=7238
§https://github.com/javapathfinder/jpf-core/wiki
¶https://www.eclipse.org/MoDisco/
Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions (https://onlinelibrary.wiley.com/terms-and-conditions) on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
# NIRUMAND et al.

# Algorithm 1. Extracting ICCs
Input: AASAM-SET: A set of Android Application Security Aspects Models
Output: ICCM: ICC Model
1: // Explicit Communications Extractor - See Sec. 5
2: ExplicitCommunications ← extractAllExplicitIntents (AASAM-SET)
3: AppComponents ← extractAllComponents (AASAM-SET) ∪ extractAllDynamicRegisteredComponents (AASAM-SET)
4: for each EI = &lt; SCN, TCN, N&gt; ∈ ExplicitCommunications do
5:      SenderApp ← extractApplication (SCN)
6:      if TCN ∈ AppComponents then
7:           ExplicitTargetComponent ← getAppComponent (AASAM-SET, TCN)
8:           ReceiverApp← getApplication (AASAM-SET, TCN)
9:      else
10:            ExplicitTargetComponent ← ∅ // There is no receiver component for this intent in the bundle
11:            ReceiverApp← ∅ // There is no receiver app for this intent in the bundle
12:       end if
13:  end for
14:  // Implicit Communications Extractor - See Sec. 5
15:  ImplicitCommunications ← extractAllImplicitIntents (AASAM-SET)
16:  for each II = &lt;SCN, N, A, C, D&gt; ∈ ImplicitCommunications do
17:       SenderApp ← extractApplication (SCN)
18:  // Perform Intent Resolution - See Algorithm 2
19:       ImplicitTargetComponents ← intentResolution (II). getImplicitTargetComponents()
20:  end for
As depicted in Figure 7 (i.e., phase 2), first, for each app, the security information of initial models is extracted and gathered into a single security model called Android application security aspects using an M2M transformation. This generated model conforms to the proposed metamodel shown in Figure 5. The ATL code for this transformation includes 31 rules and 27 helpers. 16 rules and 8 helpers are considered to extract the information from the XML model, whereas the remaining 15 rules and 19 helpers are implemented to extract the security information from the Java model. Then, all Android application security aspects models are received as input models to be transformed into a single model called ICC. This model represents all potential intent-based communications at the intra- and inter-app levels. The ICC model conforms to the proposed metamodel shown in Figure 6. In the following, the process of modeling these domains (i.e., the Transformation to ICC Model process in Figure 7) is described.

# 5 Extracting ICC model
The model-driven chain of this step includes an M2M transformation, written in ATL language, as shown in Figure 8. The ATL code for this transformation includes 17 rules and 28 helpers. In this transformation, a set of Android application security aspects models, the Android application security aspects metamodel, and the ICC metamodel are received as inputs, and the ICC model is obtained as output. The steps of this modeling are shown in Algorithm 1. As depicted in this algorithm, the Extracting ICC Model performs two major steps to extract the ICC model from a bundle of Android applications: Explicit Communication Extractor (lines 1–13) and Implicit Communication Extractor (lines 14–20), which are described in the following.

1. Explicit communication extractor.

As shown in Algorithm 1, to model the explicit communication domain, first (line 2), all explicit intents are extracted from the desired Bundle of Android apps. According to the Android Application Security Aspects metamodel (the part related to the intent element and its references), an explicit intent is considered as a tuple EI = &lt;SCN, TCN, N&gt;, where SCN is the SendComponentName attribute, TCN is the TargetComponentName attribute, and N is the Name attribute.

1097024x, 2023, 4, Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions (https://onlinelibrary.wiley.com/terms-and-conditions) on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
912 NIRUMAND et al.

# Algorithm 2. Intent resolution process
Input: II = &lt;SCN, N, A, C, D&gt;: An implicit intent in the bundle of Android app
Output: ImplicitTargetComponents: A set of target components in the Android system (the bundle of Android apps)
1:  ImplicitTargetComponents &lt;- { }
2:  // ActionTest&amp;CategoryTest&amp;DataTest
3:  if  A ≠ ∅ &amp; C ≠ ∅ &amp; D ≠ ∅ then
4:       ImplicitTargetComponents &lt;- ActionTestCategoryTestDataTest (II)
5:  else
6:       // ActionTest&amp;CategoryTest
7:       if  A ≠ ∅ &amp; C ≠ ∅ &amp; D = ∅ then
8:            ImplicitTargetComponents &lt;- ActionTestCategoryTest (II)s
9:       else
10:            // ActionTest&amp;DataTest
11:            if A ≠ ∅ &amp; C = ∅ &amp; D = ∅ then
12:                ImplicitTargetComponents &lt;- ActionTestDataTest (II)
13:            else
14:                // CategoryTest&amp;DataTest
15:                if A = ∅ &amp; C ≠ ∅ &amp; D ≠ ∅ then
16:                     ImplicitTargetComponents &lt;- CategoryTestDataTest (II)
17:                else
18:                     // ActionTest
19:                     if  A ≠ ∅ &amp; C = ∅ &amp; D = ∅ then
20:                          ImplicitTargetComponents &lt;- ActionTest (II)
21:                     else
22:                          // CategoryTest
23:                          if  A = ∅ &amp; C ≠ ∅ &amp; D = ∅ then
24:                               ImplicitTargetComponents &lt;- CategoryTest (II)
25:                          else
26:                              // DataTest
27:                               if  A = ∅ &amp; C = ∅ &amp; D ≠ ∅ then
28:                                    ImplicitTargetComponents &lt;- DataTest (II)
29:                               else
30:                                    ImplicitTargetComponents &lt;- ∅
31:                               end if
32:                          end if
33:                     end if
34:                end if
35:            end if
36:       end if
37:  end if
For each explicit intent, (line 5), the Android app whose component creates this intent is considered as the sender app (i.e., SenderApp in the ICC metamodel). Since an explicit intent must be delivered to the app component specified by the TargetComponentName attribute of the intent, (lines 6–12), if there exists a component in the Android system that is declared by the explicit intent, this component is considered as the receiver component (i.e., Explicit-TargetComponent in the ICC metamodel). The Android app whose component is declared by the explicit intent is considered as the receiver app (i.e., ReceiverApp in the ICC metamodel).

# (2) Implicit communication Extractor.