# 3 Vulnerability Blueprint
The design of an automatic and rigorous analysis flow for the Frame Confusion vulnerability demands for the selection of a set of features that enable the vulnerability. To this aim, we argue that a minimal set of such features is the following:
1. the app requires the Internet permission in order to access web domains using a WebView component;
2. the app uses at least a WebView (W) that is configured to execute JavaScript code;
3. W sets at least a JavascriptInterface (JI);
4. JI injects at least a public Java method (m) that can be accessed from the JavaScript code;
5. in case of an app targeted to API level 17 or higher, m needs to be further annotated with the @javascriptinterface tag;
6. W loads at least a web page (WP) that contains one or more Iframe elements;
7. WP does not enforce any mitigation technique among those described in the previous section.

# 3 Detection Algorithm
The Frame Confusion detection methodology can be summarized by the pseudocode listed in Algorithm 1. Given a generic Android app in .apk format, the algorithm begins by retrieving a list of the Android permissions used by the app (row 1). If the list does not include the Internet permission, then the app cannot use the WebView component, and therefore it is marked as not vulnerable (rows 2–4). Otherwise, the algorithm computes the list of all the invoked methods of the app (row 5) in order to locate the presence of setJavaScriptEnabled and addJavascriptInterface APIs.

If a setJavaScriptEnabled invocation (row 9) is recognized, the algorithm further investigates the flag parameter of the call (rows 10–14). A True value indicates that the WebView enables the execution of JavaScript and thus its object reference is retrieved (row 12) and included in the list of those that enable JavaScript (row 13).

Instead, the presence of a addJavascriptInterface indicates that a WebView component is configured to expose a bridge between Java and JavaScript. If this is the case, the algorithm extracts (i) the WebView object from which the addJavascriptInterface method is invoked (row 17), and (ii) the Java object injected in the JavascriptInterface (row 18). After that, the algorithm needs to detect if the Java object injected in the interface contains public methods that can potentially be accessed from JavaScript code (rows 19–27). Moreover, in case of apps targeted to API level 17 or above, the public methods of the object need to be further annotated with the @javascriptinterface tag (rows 19–22). If the injected Java object contains methods accessible from JavaScript, then the corresponding WebView instance can be added to the list of those that expose potentially vulnerable interfaces (row 21 or row 25).

Next, if the analysis is not able to find at least a WebView - with JavaScript enabled - that contains a JavaScript interface with exposed Java methods, then the app is marked as not vulnerable (rows 29–34). Otherwise, the analysis collects from the Website collector module all the website pages accessed by the WebView that are (i) included in the resources of the .apk package (row 35), (ii) statically invoked by loadURL methods (row 36), and (iii) dynamically reached during the execution of the app (row 37).

Thereafter, the algorithm collects every website that uses at least an Iframe element that loads an external page (either embedded in HTML pages or generated by JavaScript) and that does not enforce any of the mitigation techniques discussed in the previous section (rows 40–48). Finally, if the app loads at least one vulnerable website, it is marked as vulnerable. On the contrary, if the app uses the appropriate security mechanisms or does not use any Iframe is marked as non vulnerable.

# Droids in Disarray: Detecting Frame Confusion in Hybrid Android Apps
# Algorithm 1. Frame Confusion Detection
1. listPermissions = getPermissionFromApk(app);
2. if "android.permission.INTERNET" not in listPermissions then
3. return notVulnerable;
4. end
5. methodsList = getAllInvMet(app);
6. JSWebView = list();
7. IWebView = list();
8. foreach method in methodsList do
9. if method.getName == "setJavaScriptEnabled" then
10. flagParam = getFlagParam(method);
11. if flagParam == True then
12. webViewObj = getInvObj(method);
13. JSWebView.add(webViewObj);
14. end
15. end
16. else if method.getName == "addJavascriptInterface" then
17. webViewObj = getInvObj(method);
18. interface = getInterfaceObj(method);
19. if getSDK(app) > 17 then
20. if containAnnotatedPubMet(interface) then
21. IWebView.add(webViewObj);
22. end
23. end
24. else if containPubMet(interface) then
25. IWebView.add(webViewObj);
26. end
27. end
28. end
29. if len(JSWebView) == 0 or len(IWebView) == 0 then
30. return notVulnerable;
31. end
32. if len(IWebView ∩ JSWebView) == 0 then
33. return notVulnerable;
34. end
35. resourceFiles = getAllResourceApk(app);
36. dumpWebStat = getStaticUrl(methodsList);
37. dumpWebDyn = getDynamicUrl(app);
38. filesToCheck = dumpWebDyn union resourceFiles union dumpWebStat;
39. vulnerablePages = list();
40. foreach file in filesToCheck do
41. if isHTMLfile(file) or isJSfile(file) then
42. if containIframe(file) then
43. if not containCSP(file) and not containSandboxAtt(file) then
44. vulnerablePages.add(file);
45. end
46. end
47. end
48. end
49. if len(vulnerablePages) > 0 then
50. return vulnerable;
51. end
52. return notVulnerable;
# 4 The FCDroid tool
FCDroid4 implements the proposed detection methodology to automatically identify the presence of the Frame Confusion vulnerability in Android apps. The rest of the section discusses (i) the implementation challenges addressed by FCDroid and (ii) its architecture, emphasizing the underlying tools and technologies.

# 4 Implementation Challenges
The Frame Confusion detection methodology poses several challenges in terms of implementation. Indeed, an automatic detection tool needs to:
1. achieve maximum coverage, i.e., by detecting all possible app execution paths that may lead to the vulnerability;
2. recognize the actual configuration of WebView components, which may dynamically enable JavaScript or define new interfaces;
3. analyze all the web pages loaded inside some potentially vulnerable WebViews, by also considering those loaded according to (i) the user’s input, and (ii) the value of runtime variables.

To address such challenges, an automatic tool can rely on static and dynamic analysis techniques. Static analysis techniques can examine all possible execution paths and variable values, not just those invoked during execution. However, static approaches can (i) introduce false positives and (ii) be unable to detect complex scenarios, like, e.g., values provided by the user or resources loaded at runtime. On the other hand, dynamic analysis techniques allow detecting the actual behavior of the app, but it is limited by (i) the coverage of the analysis and (ii) the time required for the analysis, thus producing potential false negatives.

4FCDroid is available at https://www.fcdroid.com.

# Droids in Disarray: Detecting Frame Confusion in Hybrid Android Apps
To this aim, FCDroid combines static and dynamic analysis techniques to overcome the limitations of both techniques and achieve more accurate detection results.

# 4 FCDroid Architecture
The FCDroid architecture, depicted in Fig. 2, is composed by five main building blocks: the Static Analysis Module (SAM), the Dynamic Analysis Module (DAM), the WebSite Dumper (WD), the Frame Confusion Detector (FCD), and the Exploitation Checker (EC).

# Static Analysis Module (SAM)
The Static Analysis Module relies on Apktool  to disassemble the app package (in the .apk format) and translate the Dalvik bytecode contained in the app into Smali  language. In addition to that, SAM brings the resources contained in the app back to their original form, e.g., from binary compiled XML files into textual XML files. Then, the module extracts the list of permissions requested by the app and the target Android API level according to the content of the AndroidManifest.xml file. Finally, the SAM inspects each extracted Smali file in order to locate all the API invocations related to the WebView component. In detail, the module detects:
- setJavaScriptEnabled that enables the JavaScript code in a WebView object. If found, the SAM also extracts the variable containing the boolean flag passed as an argument;
- addJavascriptInterface, that creates a JavaScript interface object. In this case, the SAM retrieves the Java class of the injected object and the name assigned to the interface;
- loadUrl and evaluateJavaScript, that allows the loading of specific URLs or JavaScript code inside the WebView. In case, the module also extracts the URL address or the script code, if statically defined;
The collected pieces of information are then sent to the WebSite Dumper and the Frame Confusion Detector to continue the analysis.

# Dynamic Analysis Module (DAM)
The Dynamic Analysis Module is in charge of executing the app into a controlled testing environment in order to monitor the stimulation of the WebView components at runtime. To this aim, it installs the app into an Android Emulator and stimulates the app automatically, trying to explore its possible execution states. This allows the DAM to (i) monitor the invocations of WebView-related API along with their execution parameters, and (ii) intercept all the network traffic generated by the app.