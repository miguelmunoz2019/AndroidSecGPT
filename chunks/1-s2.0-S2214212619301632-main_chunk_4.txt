# 3. Order Tampering
In this type of attack, the attacker acts as a malicious user. If the merchant fails to obey the Security Rule 1 and Rule 6, then attacker can cheat the merchant by sending a payment order (orderp) to the cashier different from the actual merchant order (orderm). In this situation, the attacker could tamper the content in the payment order such as the total amount and thus pay less money for the ordered commodities without the merchant’s awareness.

The attack for process model I is shown in Fig. 3. In model I (Fig. 1), the signed payment order is generated and sent by the MS to the CS. A local attacker can only obtain the (TN) message which does not include any detailed information (e.g., the total amount of the payment) of the payment order. Thus, it’s impossible to tamper the payment order information. However, if the MA incorrectly implement the payment order generation step in the app rather than its server, the attacker can succeed in tampering the payment information. Since the attacker can take full control of local app and system, we merge the attacker with the MA in the Fig. 3. The order pT in the figure indicates that the payment order has been tampered already and so does Fig. 4.

In model II (Fig. 2), though the complete payment order information can be achieved by the attacker (orderp need to be returned to MA), he can not tamper it since the payment order is signed by...

# 3. Notification forging
Different from the two attacks above, the victim of order substituting attack becomes the normal user of MA rather than the merchant. The cause of the attack involves multi-parties’ violation of security rules including both cashier (Security Rule 3 and 4) and merchant (Security Rule 5). In this attack, the attacker substitutes an order of one transaction to another, and misleads a victim user to pay for the attacker’s order unconsciously.

If the merchant fails to obey the Security Rule 2 (or Rule 7), and Security Rule 6, then it suffers notification forging attack, allowing attackers to purchase commodity without paying it. In the attack, a normal payment process is performed until the TP-SDK requires user to confirm the order and enter password to pay for it. At that time, an attacker does not pay for it, but instead sends a fake payment result notification to notify the MS that the order is paid successfully. The attack to process model I (Fig. 1), for example, is shown in Fig. 5. If the order is not paid (Step 6 in Fig. 1), it still remains ‘pending’ status, and the MS will not receive the notification from the CS (Step 7 in Fig. 1). However, afterwards attackers can forge the notification and send it to the MS (Step 6 in Fig. 5). If the merchant trusts this fake notification and does not confirm the order’s details to the CS (Step 8 in Fig. 1), the payment is successfully forged. The attack can also be performed to model II (Fig. 2) with the same way, which we omit it here.

Attackers need to exploit several mistakes committed by the merchant to make a forged notification available. First, the notify URL address of MS that receives the payment notification from CS should be known beforehand. So the attack requires MA to contain the notify URL address, which would be placed by the developers accidentally. Actually, as we illustrated before, MA who adopts process model II (AliPay and BadPay) certainly contains the notify URL, since all order information including notify URL is used as input of the TP-SDK (Step 3 in Fig. 2). Second, the attack needs to construct a forged payment order notification of the cashier and cheats MS to accept it. Attackers can obtain the data format of the notification message from documents released by the cashier, and then forge it with a signature which proves the identity of the sender. The KEY used here is often extracted from the MA, in which the merchant’s developers place this shared secret key by mistake (Security Rule 2).

Note that among four cashiers, only the notification of those who adopt hash-function as their signing method (WexPay and BadPay) can be forged because the cashier and the merchant share the same KEY as their signing KEY. For those using SHA1-RSA to sign the messages, the RSA private key of cashiers can hardly be leaked, thus, forging the cashier’s message with legal signature is quite impossible. Moreover, we observe that some MSs even ignore validating the signature of the received messages (Security Rule 7). Thus, the fake notification even with wrong signature is unconditionally accepted. Finally, similar to Order Tampering Attack, notification forging also needs the MS to ignore the order re-confirmation step. Otherwise the merchant can find out that the notified payment order is still remain ‘pending’ status in CS.

# 3. Order substituting
The attack to process model II (Fig. 2) is shown in Fig. 6. The attack is available when the message returned from MS is transferred with an insecure network communication channel. Thus, the attacker can act as a man-in-the-middle between MA and MS. Attackers can intercept the message and substitute signed payment order (orderp) with another one (order p A) of a legal transaction, and send it to the MA on victim’s device. The victim will then pay for the attacker’s order rather than his own order. Note that the attacker uses a legal payment order to replace the original one. This message usually belongs to a normal trade performed by the attacker beforehand (steps between Step 2 and Step2′ in Fig. 6), so it is reasonable to cheat the victim’s TP-SDK and finish the transaction with this message successfully. The attack to process model I (Fig. 1) is similar. The only difference is that the attacker needs to substitute the TN message (Step 4 in Fig. 1) rather than the orderp (Step 2 in Fig. 2) returned from MS.

The root cause of this attack includes the lack of secure communication channel as well as the inadequate prompt information showed by TP-SDK. We discover that the payment UI (asking for user’s confirmation before user paying) of TP-SDK generally does not show enough information about current payment order, thus the victim will confirm and pay for another order without being aware of it. For example, if the payment UI only shows the total amount of the order, then the attacker could make an order with the same price of the victim’s order. Even if some TP-SDKs show the commodities and the merchant name of the order, the attacker could make an order with same commodities while modifying the consignee since it is not difficult for attacker to know what victim is going to buy through eavesdropping the merchant order request (Step 1 in Fig. 6) via insecure network connection between the MA and the MS. What’s worse, if the TP-SDK accepts the orderp (or TN), whatever it is generated by the host MA or not, this attack can be...

W. Yang, J. Li and Y. Zhang et al. / Journal of Information Security and Applications 48 (2019) 102358  7
expanded that even a transaction from another MA can be substituted to that from one MA. In other words, if attackers substitute the original orderp (or TN) with anther orderp (or TN) of malicious merchant registered to cashier by attackers themselves, the money paid for the transaction will be transferred to attackers directly. Nevertheless, our investigation indicates that some TP-SDKs do not verify TN carefully, allowing attackers to substitute the original one easily.

# 3. Unauthorized querying
If the merchant violates the Security Rule 2, leaking its KEY to attackers, it will also suffer the unauthorized querying attack. An unauthorized querying attack allows attacker to query the details of every transaction recorded in CS, acquiring secret business information which should only be shared by cashier and merchant. The root cause of this attack is due to the leaking of merchant’s authentication credential. Cashiers provide several Web APIs for merchant to query various information, such as every payment order’s status and details, the merchant’s history bill of everyday, etc. Furthermore, cashiers make use of the signing KEY to authenticate the identity of each merchant. However, the KEY may be accidentally placed in the MA by the developers of the merchant. So the attacker could utilize the leaked KEY to query transaction information illegally.

# 4. Detecting flawed in-app payments
The violation of the seven security rules causes exploitable attacks and leads to serious consequences. In this section, we will describe how to convert these rules into detectable forms in the payment process both on Android and iOS platform. Detecting these violations is helpful to find flawed in-app payments to actual loss. Furthermore, we discuss the feasibilities and details of detecting such flaws.