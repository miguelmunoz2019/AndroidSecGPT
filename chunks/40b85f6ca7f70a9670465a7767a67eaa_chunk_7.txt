It is interesting to observe that PB, in contrast to PA, does consider fewer instances as harmful for SM11 and SM12. For the first smell SM11: Implicit Pending Intent PB
# Empirical Software Engineering
considers intents with assigned actions frequently as secure, while PA considers them as potential risk, which is more accurate. For the second smell SM12: Common Task Affinity PB considers most apps that used empty task affinity properties as secure, while PA performed a more thorough analysis of the UI and considered additionally the misuse capability of such exposed views, which resulted in many assignments to the category uncertain. We conclude that the very complex and flexible ICC implementation provided by Android overwhelms inexperienced developers, even worse, it could mislead those developers to create insecure code due to their misunderstanding.

Overall, most of the vulnerabilities seem to emerge from SM10 and SM11 that collectively contribute to more than 72% of all detected critical issues. On the other hand, SM04 on its own provides with 77% the largest proportion of false alarms regarding vulnerability capabilities.

# 4 Threats to Validity
One important threat to validity is the completeness of this study, i.e., whether we could identify and study all related papers in the literature. Although we could not review all publications, we strived to explore top-tier software engineering and security journals and conferences as well as highly-cited work in the field. For each relevant paper we also recursively looked at both citing and cited papers. Moreover, to ensure that we did not miss any important paper, for each identified issue we further constructed more specific queries and looked for any new paper on GoogleScholar.

We were only interested in studying benign apps as in malicious ones it is unlikely that developers will spend any effort to accommodate security concerns. Thus, we merely collected apps that were available on GitHub and the F-Droid repository. However, our dataset may still have malicious apps that evaded the security checks of the community or the marketplace.

We analyzed the existence of security smells in the source code of an app, whereas third-party libraries could also introduce smells.

Our analysis is intra-procedural and suffers from inherent limitations of static analysis. Moreover, many security smells actually constitute security risks only if they deal with sensitive data, but our analysis cannot determine such sensitivity.

The Android Lint tool we used for the analysis is prone to errors that could lead to FNs, for example, when Android Lint crashes due to file parsing issues, an immediate termination of the inspection occurs which could cause some misses.

Finally, the fact that the results of our analysis tool are validated against manual analysis performed by the authors is a threat to construct validity through potential bias in experimenter expectancy. We mitigated this threat by including an external participant in the process in addition to the co-author who simultaneously played the senior developer’s role.

# 5 Related Work
Reaves et al. studied Android-specific challenges to program analysis, and assessed existing Android application analysis tools. They found that these tools mainly suffer from lack of maintenance, and are often unable to produce functional output for applications with known vulnerabilities . Li et al. studied the state-of-the-art work that statically analyses Android apps . They found that much of this work supports detection of private data leaks and vulnerabilities, a moderate amount of research is
# Empirical Software Engineering
dedicated to permission checking, and only three studies deal with cryptography issues. Unfortunately, much state-of-the-art work does not publicly share the concerned artifacts. Linares-Vasquez et al. mine 660 Android vulnerabilities available in the official Android bulletins and their CVE details,16 and present a taxonomy of the types of vulnerabilities (Linares-Vásquez et al. 2017). They report on the presence of those vulnerabilities affecting the Android OS, and acknowledge that most of them can be avoided by relying on secure coding practices. Finally, Sadeghi et al. review 300 research papers related to Android security, and provide a taxonomy to classify and characterize the state-of-the-art research in this area . They find that 26% of existing research is dedicated to vulnerability detection, but each study is usually concerned with specific types of security vulnerabilities. Our work expands on such studies to provide practitioners with an overview of the security issues that are inherent in insecure programming choices.

Some research is devoted to educating developers in secure programming. Xie et al. interviewed 15 professional developers about their software security knowledge, and realized that many of them have reasonable knowledge but do not apply it as they believe it is not their responsibility . Weir et al. conducted open-ended interviews with a dozen app security experts, and determined that app developers should learn analysis, communication, dialectics, feedback, and upgrading in the context of security . Witschey et al. surveyed developers about their reasons for adopting or not adopting security tools . Interestingly, they found the perceived prestige of security tool users and the frequency of interaction with security experts to be important for promoting security tool adoption. Acar et al. suggest a high-level research agenda to achieve usable security for developers. They propose several research questions to elicit developers’ attitudes, needs and priorities in the area of security . Our work is complementary to these studies in the sense that we provide an initial assessment of developers’ security knowledge, and we highlight the significant role of developers in making apps more secure.

Numerous researchers have dedicated their work to detecting common ICC vulnerabilities. Despite the fact that their expression has changed over time, the vulnerability classes have remained largely the same. Chin et al. discuss the ICC implementation of Android and examine closely the interaction between sent and received ICC messages . Despite the fact that their work is based on a small corpus containing only 20 apps, they were able to detect various denial-of-service issues in numerous application components, and conclude that the message-passing system in Android enables rich applications, and encourages component reuse, while leaving a large potential for misuse when developers do not take any precautions.

Felt et al. discovered that permission re-delegation, also known as confused deputy or privilege escalation attack, is a common threat, and they pose OS level mitigations conceptually similar to the same origin policy in web browsers . The community aimed on the one hand for preciseness, as countless tools to detect these flaws in ICC have been released, notably Epicc  and IccTA  with a significantly improved precision. On the other hand, the app coverage began to play a major role, as in the work of Bosu et al. who recently discovered with their tool inadequate security measures, including privilege escalation vulnerabilities, among inter-app data-flows from 110,000 real-world apps.

16 http://cve.mitre.org — Common Vulnerabilities and Exposures, a public list of known cyber-security vulnerabilities.

# Empirical Software Engineering
Along with passive analysis, active countermeasures and attacks have emerged in the scientific community. Garcia et al. crafted a state-of-the-art tool to automatically detect and exploit vulnerable ICC interfaces to provoke denial-of-service attacks amongst others . They identified exploits for more than 21% of all apps appraised as vulnerable. Xie et al. presented a bytecode patching framework that incorporates additional self-contained permission checks avoiding privilege issues during runtime, generating a remarkably low computational overhead . Ren et al. successfully investigated design glitches in the multitasking implementation of Android, uncovering task hijacking attacks that affected every OS release and were potentially duping user perception . They considered in particular the taskAffinity and taskParentReparenting attributes of the manifest file that allow views to be dynamically overlaid on other apps, and provided proof-of-concept attacks. Wang et al. assessed the threat of data leakage on Apple iOS and Android mobile platforms and show serious attacks facilitated by the lack of origin-based protection on ICC channels . Interestingly, they found effective attacks against apps from such major publishers as Facebook and Dropbox, and more importantly, indicate the existence of cross-platform ICC threats. Researchers have found interest in reinforcing the Android ICC core framework. Khadiranaikar et al. propose a certificate-based intent system relying on key stores that guarantee integrity during message exchanges . In addition to securing the ICC-based communication, Shekhar et al. proposed a separation of concerns to reduce the susceptibility for manipulation of Android apps, by explicitly restricting advertising frameworks . Ahmad et al. elaborated on problematic ICC design decisions on Android, and found that missing consistent message types and conformance checking, unpredictable message interactions, and a lack of coherent versioning could break inter-app communication and pose a severe risk . They recommend a centralized message-type repository that immediately provides feedback to developers through the IDE.