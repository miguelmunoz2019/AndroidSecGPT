# G. Jeon et al.: Automated Multi-Layered Bytecode Generation for Preventing Sensitive Information Leaks
the sensitive code was separated from the classes.dex, we should patch method call sites that invoke methods in the sensitive code as well. Remaining code in classes.dex has to invoke isolated methods by using the Reflection of Java. To invoke a method with the reflection, we need the procedure to get and access objects and methods to invoke. AmpDroid, thus, must patch all the calling sites invoking methods defined in the isolated class. However, patching all the invoke instructions can increase the size of code unnecessarily. To minimize the redundancy, we design a Generic Reflection Call Method (GRCM) that can invoke any method in the sensitive code with reflection. GRCM is designed to easily provide the procedure to the remaining code without heavily modifying it. GRCM takes the following three arguments: (1) the name of a class object that contains a method to invoke; (2) an array including the name of the method to be called and objects to be passed as parameters when calling the method; and (3) the number of parameters used in the method call. By using GRCM, we can minimize the code redundancy for calling isolated methods. Lastly, AmpDroid re-compiles the Smali files to generate a new classes.dex.

# 2) UDC DEX
After isolating the sensitive code, AmpDroid finds all user-defined classes including MainActivity and isolates them into a UDC dex. The AmpDroid uses the package names of Android libraries to distinguish between user-defined classes and android library classes. Android provides libraries such as java, org/apache, com/google, android, and kotlin, so the other packages can be recognized as user-defined classes and can be split into the UDC dex. Because an application must calls the onCreate method of MainActivity in the UDC dex to execute, AmpDroid patches the classes.dex to call the method by using the reflection. After the onCreate method is executed, the other user-defined methods can be directly invoked. AmpDroid isolates the UDC dex for making static analyses difficult on user-defined classes. By isolating the UDC dex from classes.dex file, an attacker cannot easily analyze it because the code is separated and hidden even though the file exists in the APK file.

# 3) CLASSES.DEX
After splitting the sensitive code and all user-defined classes, classes.dex has classes of Android libraries. Also, AmpDroid inserted code for loading dynamically other dex files with GRCM in the classes.dex.

# VI. IMPLEMENTATION
We implement a proof-of-concept of AmpDroid that prevents information leaks by isolating the sensitive code and its sub-applications. Sub-applications are a sensitive code management server (CMS) that saves and provides the SC dex and a sensitive code management application (CMA) that sends a request to the server and provide the SC dex to an AmpDroid-protected application. AmpDroid is currently publicly available at https://github.com/ssu-csec/code-AmpDroid.

# A. MANAGING THE SC.DEX
To protect applications against the ReMaCi attack, we should securely manage SC dex files isolated from applications. In this work, we focus on identifying and isolating the sensitive code, leaving the secure management of the sensitive code as future work. In our proof-of-concept implementation, we used the CMS and CMA to manage the sensitive code. After splitting the sensitive code, AmpDroid calculates a hash value of the application to check its integrity. It, then, sends the SC dex file and the hash value to the code management server to save it and it manages them with pairs. When the code management server receives a request from the CMA for the SC dex, the CMA calculates and sends the application’s hash value as well. By doing so, we can check the integrity of the application (whether or not the application is modified). After the CMA receives the sensitive code, the CMA delivers it via Intent. To securely transfer intents between AmpDroid-protected applications and the CMA, every intent is encrypted. To this end, AmpDroid and the CMA use a secret key-based encryption algorithm such as AES to transfer intent securely. When AmpDroid isolates a class from an application, it generates a secret key and stores the key into the application.

119582 VOLUME 9, 2021
# G. Jeon et al.: Automated Multi-Layered Bytecode Generation for Preventing Sensitive Information Leaks
and the isolated class. When the AmpDroid-protected application requests the SC dex by using an intent to the CMA, the AmpDroid-protected application encrypts the intent with the secret key and sends it. In the case of delivering the SC dex to the AmpDroid-protected application, the CMA also encrypts the intent and then sends it. By doing so, the intent can be delivered securely.

As we described the management of the SC dex, AmpDroid makes AmpDroid-protected applications executable by dynamically loading the SC dex received from the CMA. The CMA provides the SC dex when AmpDroid-protected applications start executing and request it. Once the CMA first downloads the SC dex from the server, CMA can store it on the device. Therefore, CMA does not need to download the same SC dex several times.

# B. AMPDROID-PROTECTED APPLICATIONS
The AmpDroid-protected application executes with checking whether the CMA is installed on a device or not, and loads the UDC dex only if the CMA is installed (If not installed, exit the process). After loading the UDC dex, the application sends an intent for obtaining the SC dex to the CMA. The CMA calculates the hash value of the application and provides the SC dex to it. The application, then, can load the SC dex. Once loading the SC dex has completed, the application executes the onCreate method of the MainActivity.

When calling the onCreate method using reflection APIs, AmpDroid-protected applications can mitigate that an attacker resolves the static arguments of reflection APIs by using dynamic analysis tools. The calling onCreate method is the next step after the SC dex is dynamically loaded. The attacker without the CMA cannot obtain the SC dex, and thus, the attacker cannot execute the onCreate method even if the attacker uses a dynamic analyzer such as Frida.

AmpDroid can also mitigate the collusion attack, two or more applications collaborate to perform stealthy malicious actions, by restricting the execution of the application. To perform the collusion attack, colluded applications must be executed and malicious code which accesses private data must be inserted in colluded applications. But, the application protected by AmpDroid must be able to execute only with SC dex which includes sensitive data flows which can be exploited by an attacker’s malicious code. AmpDroid uses also an encryption algorithm to prevent a hijacking when it sends SC dex using an intent that can be exploited by colluded application.

# VII. EVALUATION
In this section, we first demonstrate how many recent applications are vulnerable to ReMaCi attacks in Section VII-A. We, also, present how effectively AmpDroid protects applications from sensitive information leaks in Section VII-B, Section VII-C, and Section VII-D, comparing with other obfuscation tools. Also, we demonstrate the performance impact of AmpDroid in Section VII-E.

Our evaluation addresses the following research questions:
- RQ1: Are real-world applications really vulnerable to the ReMaCi attack?
- RQ2: Does AmpDroid effectively prevent ReMaCi attacks?
- RQ3: What is the runtime performance overhead imposed by AmpDroid in comparison with other obfuscations tools?
# 1) EVALUATION SETUP
We collected 8,546 applications from the Google Play Store within the last 2 years and used them for demonstrating the threat of ReMaCi attacks. Our dataset includes quite famous apps that have 1 million+ downloads such as ‘‘com.tflat.phatamtienganh.apk’’, ‘‘com.bianf.avatars.couple.dance.apk’’ to provide an effect of our approach on a variety of applications. The size of our dataset is about 160GB and includes applications from 13KB to 376MB in size and various categories such as Education, Business, Finance, and Lifestyle.

To evaluate the performance of AmpDroid, we used 1,870 random applications (in Section VII-D and Section VII-E) published from 2019 through ApkPure.

We provide our dataset to everyone via a public repository at https://github.com/ssu-csec/code-AmpDroid/tree/main/doc
# G. Jeon et al.: Automated Multi-Layered Bytecode Generation for Preventing Sensitive Information Leaks
We performed our evaluations on the Google Pixel 2XL device of the android 8 version. The detailed specifications of the device are composed of a CPU of 2GHz x 4 & 1GHz x 4 Quad-Core Processor, and 4GB of RAM.

# A. REAL-WORLD APPLICATIONS VULNERABLE TO ReMaCi ATTACKS
To demonstrate real-world Android applications are really vulnerable to the ReMaCi attack, we first selected the top-selling 8,546 applications. We then used AmpDroid to find the stems from the applications. Each stem represents an identifiable execution path that accesses the sensitive information and sends the data out of the application. If we can identify such stems in an application, we can inject malicious code that transfers the data to an arbitrary server or other devices in the application and repack the application for distributing it through third-party markets. Therefore, the existence of identifiable stems in an application can imply the application is vulnerable to the ReMaCi attack.