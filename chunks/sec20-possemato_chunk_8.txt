Thus, we developed an instrumentation framework that records all network activities and, moreover, hooks the network Socket.connect API (by using Frida ). This API is the lowest-level API used for any HTTP or HTTPS connection and it provides the target domain name and the port. Every time the API is invoked, we perform a stack trace inspection to determine which package has originated the call: this setup allows us to match which component (i.e., library) of the app initiated the network request.

Due to the ethical concerns mentioned earlier, we limited ourselves to a very small-scale experiment: we opted to select and analyze only one representative app, Hunter Assassin , an action game with more than 50M installations. This app embeds MoPub and specifies a NSP that reflects MoPub’s documentation. For the experiments, we executed the app 10 times, with each execution lasting 10 minutes. Due to ethical concerns, we opted to not use automatic UI stimulation techniques, but we performed this analysis step manually, by just simulating the interaction of a “real” user. This approach allows us to avoid generating excessive traffic and damage the app developer’s reputation and ad libraries.

During the analysis, our instrumentation framework detected that the MoPub library initiated connections to 83 unique domains. (For this experiment, we discarded the domain names reached by other components of the app.) Surprisingly, for 82 domains (out of 83) the connection was actually established using HTTPS, the only exception loaded over HTTP being
an image, retrieved from a MoPub server. Even though this HTTP connection would be blocked by a non-permissive cleartext policy, we do not believe this is the core reason why MoPub requires the policy to allow cleartext for the entire app. According to the MoPub documentation, it requires HTTP because it may need to serve ads via HTTP—and to do so, it asks the app developer to weaken the policy for the entire app.

We believe this to be a clear violation of the principle of least privilege, as the ad library should allow cleartext for its own connections, without interfering with the rest of the app. However, we note that this current situation is not solely fault of the ad library: with the current policy format, it would be impossible to enumerate all possible domain names that the ad library should be able to reach since this list is not known in advance (and since the NSP cannot be changed at run-time). We identified a conceptual limitation: the current policy format allows developers to specify policies per domain, but we believe a better abstraction for policy specification to be per package. In an ideal world, the ad library should be able to express that only the connections that are initiated by the MoPub library itself should be subject to use cleartext, without the need of weakening the rest of the app. Guided by these insights, we designed and implemented a drop-in extension to the NSP that would address this concern. We discuss this proposal in the next section.

# 7 Network Security Policy Extension
As previously discussed, third-party libraries can significantly weaken the NSP of an app, and ad libraries actually often do so. In some scenarios, however, it is very challenging for ad libraries to “do better.” In fact, the complexity of the ad ecosystem may make it impossible, for example, to know in advance which domain names require HTTP connections, thus leaving the ad library developers to ask to allow cleartext for the entire app. We believe the current format of the policy is fundamentally limited. The current policy allows developers to specify different policies at the granularity level of domain names: we argue that, in some scenarios (e.g., ad libraries), this is the wrong abstraction level.

This section discusses our proposal for an extension of the NSP format to allow for the specification of policies at a different granularity: app components, identified by their package names.

# Our New Extension
The core idea behind the extension is to allow a developer to bind a specific policy to a specific package name(s). To this end, we introduce a new XML node, package-config, which allows developers to specify custom policies for specific external libraries, without the need to modify (and negatively affect) the policy of the main app. To ease the explanation, consider the following concrete example:
&lt;base-config cleartextTrafficPermitted="false" /&gt;
&lt;package-config&gt; &lt;!-- introduced by our extension --&gt;
&lt;package name="com.adlib.unsafe" cleartextTrafficPermitted="true"/&gt;
&lt;/package-config&gt;
This policy specifies that, by default, all HTTP traffic should be blocked. However, it would allow HTTP connections if they are initiated by the com.adlib.unsafe ad library. Note how the ad library can now support occasional HTTP connections even without knowing the list of domain names a priori and, more importantly, without affecting the policy of the app.

# Implementation
We implemented this new extension by modifying the isCleartextTrafficPermitted API to make it aware of the XML policy node. Our modification performs stack trace inspection to determine which package name has initiated the call. For each package name appearing in the stack trace, we then check whether the NSP contains a custom policy for a specific package name: if yes, we use that policy. Otherwise, we apply the default. In case the connection should not be allowed, our implementation raises a RuntimeError, indicating a policy violation.

# Adoption & Backward Compatibility
Our extension can be trivially adopted by app developers and network libraries. In fact, since we modify an API that all these libraries already invoke—and that was a key design choice—they can enjoy the benefits of our policy without the need to make any modification. We also note that our extension is fully backward compatible and it can act as a drop-in replacement of the old version. In fact, apps and policies that are not “aware” about our extension are supported exactly the same as before.

# Performance Considerations
We implemented our extension on a Pixel 3A running Android Pie (pie-qpr3-b-release). Our patch consists of less than 30 lines of code and modifies only two components of the Android framework (the policy parser and the isCleartextTrafficPermitted API). We measured the overhead of our extension with a microbenchmark: we wrote an app that performs 1,000 HTTP requests using the OkHttp3 library. We then run the app 100 times, with and without our modifications, and we compute the difference. The average execution time of the isCleartextTrafficPermitted API, without our modification, is 0 ms with a standard deviation of 0 ms. The average execution time of the same API with our modification is instead 0 ms, with a standard deviation of 0 ms. We believe that the overhead of our defense mechanism is negligible, especially when compared to the overhead incurred by network I/O operations.

# Limitations
Even though our implementation raises the security bar of the current Network Security Policy, we acknowledge that it currently suffers from some limitations. First, it is important to mention that, since we operate with the same threat model of the actual NSP, we do not protect the application against malicious third-party libraries that want to evade the policy defined by the developer. We note that this affects the standard NSP as well: in fact, a malicious library can bypass even the strictest security policy by performing network connections with its “custom” API or by using native code.

A second limitation relates to the fact that we rely on the stack trace to identify which component initiated the connection.

USENIX Association 29th USENIX Security Symposium 355
network connection. We acknowledge that there may be benign situations where the stack trace cannot be fully trusted and there might be the risk of losing the real “caller,” for example, when using dynamic code loading or threading with worker threads. A very detailed analysis of the potential problems of using the stack trace to perform “library compartmentalization” has been studied in FlexDroid . Even if the current threat model of FlexDroid is considering malicious libraries, we believe that their proposal of a secure inter-process stack trace inspection combined to our defense mechanism might create a full-fledged implementation to tackle the compartmentalization problem. To conclude, we currently support only the cleartext Traffic Permitted attribute. However, note that some features already provide a sufficient granularity and do not need to be sandboxed on a “per-package” basis. For example, the certificate pinning feature already creates a sort of “per-site sandbox.”
# 8 Related Work
There are several areas of works that are relevant to this paper: Network Security, the dangerousness of “code reuse,” and advertisements.

# Network Security
A concept similar to the NSP has been first introduced by Fahl et al. : this work proposed a completely new approach to handle SSL security, allowing developers to easily define different SSL configurations and options, like certificate pinning, just by using a XML policy. Thus,  completely prevents the developer to write any code responsible of handling the validation and verification of a given certificate, addressing multiple problems at their roots.