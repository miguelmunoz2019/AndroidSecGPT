- A remote adversary resides in the same WiFi or cellular network to which the victim device connects. Such an
adversary can send TCP/UDP packets to other nodes if the network provides intra-network connectivity or even inter-network connectivity (with public IP addresses assigned to clients), surprisingly true for numerous networks as we will show in Sec. V-C.

• A web adversary remotely exploits a victim’s open ports by enticing the victim to browse a JavaScript-enabled web page under the adversary’s control. This threat is only applicable to HTTP-based ports with a fixed port number, because (i) JavaScript and WebSocket can issue only HTTP packets, and (ii) the resource constraint makes it infeasible for a web page to iterate the ephemeral port range  according to our test. Note that local open ports could be attacked only by the first and the third adversaries, while other open ports may suffer from all three adversaries.

# III. DISCOVERY VIA CROWDSOURCING
The first phase of our pipeline is to discover open ports. Instead of using static analysis as in , we propose the first crowdsourcing approach for the discovery of open ports. It has the following unique advantages: (i) it can monitor open ports in the wild, covering not only third-party apps but also built-in apps that are usually difficult to analyze due to the heavy Android fragmentation ; (ii) it results in no false positive; (iii) it captures the exact port number and IP address used as well as their timestamps; and (iv) it covers both TCP and UDP ports. Furthermore, as to be evaluated in Sec. III-C3, our crowdsourcing is much more effective in terms of port discovery than typical Android static analysis, which cannot handle dynamic code loading , , complex implicit flows , , and advanced code obfuscation ,.

Our crowdsourcing platform consists of an on-device port monitoring app NetMon (Sec. III-A) and a server-side open-port analytic engine (Sec. III-B). We have deployed NetMon to Google Play and collected the crowdsourcing results from a large number of real users (Sec. III-C). Before moving to the technical details, it is worth highlighting the overall challenges in our crowdsourcing approach. The development of NetMon requires us to handle many product-level issues for a long-term and user-friendly deployment, let alone we are the first to explore on-device crowdsourcing for monitoring other open-port apps in real user devices. Moreover, compared to the typical app-based crowdsourcing (e.g., Netalyzer , MopEye , and Haystack ), our open-port crowdsourcing is unique in that the collected raw records cannot be directly analyzed due to the existence of random port numbers. We thus need to design an “intelligent” analytic engine that can effectively cluster raw records into per-app open port results.

# A. On-device Open Port Monitoring
Different from ZMap  and Nmap  that probe ports by externally sending network traffic, we launch on-device port monitoring directly on crowdsourced devices to collect not only open port numbers but also their app information. Fig. 2 shows two NetMon user interfaces for port monitoring. Fig. 2(a) shows a partial list of apps running with open ports, while Fig. 2(b) shows the detailed records for a specific app (YouTube), including the TCP/UDP port numbers, IP addresses to which the ports bind, and the timestamps.

(a) A sample of open-port apps. (b) Detailed records for YouTube.

Port monitoring mechanism. NetMon leverages a public interface in the proc file system  to monitor open ports created by all apps on the device. The four pseudo files under the /proc/net/ directory (i.e., /proc/net/tcp|tcp6|udp|udp6) serve as a real-time interface to the TCP and UDP socket tables in the kernel space. Each pseudo file contains a list of current socket entries, including both client and server sockets. Any Android app can access these pseudo files without explicit permissions, and this works on all Android versions including the latest Android 9. By using such an interface, NetMon can obtain the following port-related information:
- Socket address. It covers a port number and an IP address.

- TCP socket state. There are 12 possible TCP states , such as LISTEN and ESTABLISHED.

- The app UID. Using the PackageManager APIs, NetMon obtains the app’s name from its UID (user ID).

According to the definition in Sec. II, NetMon considers server ports as open ports. Therefore, it identifies a TCP open port from the proc file when it is in the LISTEN state. On the other hand, since UDP has no state information, we rely on the server-side analytic engine to further identify UDP open ports. Hence, the collected UDP port records are only the initial results and not all of them will be treated as open ports (e.g., the client UDP port used by YouTube in Fig. 2(b)).

Challenges. The goal of long-term port monitoring on real user devices requires NetMon to periodically analyze those four proc files with minimal overhead. A simple idea of creating a “long-lived” service to periodically monitor open ports would not work as the service will be stopped by Android after a certain amount of time (e.g., after the device goes to sleep) or simply terminated by users. To overcome this, we leverage Android AlarmManager  to schedule periodic alarms to perform the proc file analysis robustly. We chose five minutes as the alarm interval because it provides a good sampling rate (excluding many client UDP ports) while incurring negligible overhead. Our experience shows that the potential information loss within the five-minute interval is well compensated by the large number of users contributing data in our crowdsourcing campaign. Moreover, we take advantage of the batched alarm mechanism  introduced since Android 4 and a characteristic in /proc/net/tcp6|tcp — the server socket entries always appear in the top rows — to further minimize the overhead. As a result, NetMon incurs less than 1% overhead on CPU and battery for a daily usage.

# Raw port monitoring records from crowdsourcing
# Step 1: Aggregation
# Step 2: Clustering by occurrences
# Step 3: Clustering
# Clustered per-app open ports
(Using Netflix’s TCP4/UDP4 ports as examples)
# B. Server-side Open-Port Analytic Engine
The open port information gathered from individual phones, e.g., the Netflix app opens TCP port 9080 at time t1 and opens UDP port 39798 at time t2, constitute individual observations that need to be clustered to generate per-app open port results, e.g., Netflix has a fixed TCP port 9080 and a random UDP port. More specifically, different port records associated with the same “random” open port should be unified, and open ports with “fixed” port numbers should be recognized. This may sound straightforward, but it turns out to be a challenging task because fixed and random ports could exhibit indistinguishable observations. To overcome this challenge, we introduce a server-side analytic engine, as shown in Fig. 3, to perform a three-step clustering:
# Step 1: Aggregation
We first aggregate each app’s observations by different types of ports and IP addresses. This is a “narrow down” step to effectively reduce the complexity of clustering — open ports with different types or IP addresses shall be in different clusters, since they are created by different APIs or InetAddress parameters at the code level. Specifically, we divide the observations into 12 groups, enumerating the combination of four types of ports (TCP/UDP ports in IPv4 or IPv6) and three types of IP addresses (loopback address 127, ANY address 0, and the specific host address such as 192.X.X). In the Netflix example shown in Fig. 3, we have two groups — TCP4 and UDP4 (both with IP 0).

# Step 2: Clustering by occurrences
A fixed port on an app presents itself as identical records on multiple user devices, while a random port presents its observations with different port numbers. Based on this observation, we can differentiate between fixed and random ports by analyzing the occurrences of a record within each group (constructed in Step 1). We define this occurrence as the fraction of user devices presenting a specific port number within the group. For example, the UDP port 39798 for IPv4 address in our Netflix set has an occurrence of 3%.