# 2 HMAC-based One-Time Password (HOTP)
The algorithm of HMAC-based one-time password (HOTP) combines an incrementing counter value (C) and a secret key (K) to generate the one-time password. The OTP value generated by the HOTP algorithm is defined as :
value = HOT P(K, C),
where HOT P is the function:
HOT P(K, C) = Truncate(HMACH (K, C)).

where H is a cryptographic hash function, and the output of the hash function HMACH is truncated to a user-friendly size.

An HOTP value with a short length is convenient, but vulnerable to brute-force attacks. To address this problem, RFC 4426 recommends two steps: 1) the maximum number of possible attempts per login session should be set beforehand, and 2) each failed attempt should introduce an additional delay before a retry is permitted. RFC 4426 also suggests that with these protective steps the length of an HOTP value should be at least six digits.

# 2 Time-based One-Time Password (TOTP)
The time-based one-time password (TOTP) algorithm  is an extension of the HOTP algorithm, using elapsed time increments instead of an event counter. Because of human and network latency, the one-time password for each login session must remain valid over a time interval (defined by the time step parameter). Based on RFC 6238, the OTP value generated by the TOTP algorithm is defined as:
value = HOT P(K, CT)
where K is a secret key, and CT is an integer counting the number of completed time steps between the initial counter time T0 and the current Unix time. Given a time step Tx in seconds, CT is calculated as:
CT = (current unix time − T0) / Tx
Due to the network latency, the number of time steps (CT) calculated by clients and servers may differ and so resulting in different TOTP values. This problem can be addressed by setting the OTP time step Tx to an acceptable size. The OTPs generated anytime within a time step will be the same and will allow the user to login successfully. However, depending on when a login request is made, a server might reasonably accept OTPs from earlier or later time steps. For example, if an OTP is generated near the end of a time step, the user may compute a counter based on the succeeding time step due to latency. To take this into account, the server may accept OTPs computed from time steps +/-1 from its current time step. A larger time step makes the OTP authentication protocol with a TOTP value become more vulnerable because it offers an attacker more time to guess the TOTP value and consume the TOTP value before the valid user does. To balance the security and the usability of this authentication scheme, RFC 6238 recommends setting the size of the time step to 30 seconds.

Furthermore, the server must ensure that sufficient time has elapsed between generating successive TOTP values so that the number of time steps (CT) has changed.

# 2 Best Practices and Threats for OTP
In this subsection, we first summarize six OTP rules (i.e., rules for secure OTP implementation) according to RFC documents, and then discuss threats against OTP authentications if one or more rules are violated.

# 2 OTP Rules
Several RFC documents such as RFC 4226 , RFC 2289 , RFC 6238 , RFC 1750 , and RFC 4086  regulate how to securely implement an OTP authentication protocol. We conclude them as six OTP rules
# Recommendations for Secure OTP Implementation
# R1: OTP Randomness
Use a random value as an OTP for authentication. The server needs a cryptographically strong pseudo-random number generator to generate the OTP value for each login session, as an attacker can exploit any detectable non-randomness in the successive OTPs. Some poor pseudo-random number generators can be identified from the series , or values in the sequence may appear periodically. In the worst situation, an implementation of OTP authentication may keep using a static value as the OTP for all authentication sessions.

# R2: OTP Length
Generate an OTP value with at least six digits. The official document RFC 4226  points out that “the value displayed on the token MUST be easily read and entered by the user.” It requires that the OTP value should also be of reasonable length. Particularly, RFC 4226 indicates that an OTP value of at least six digits could adequately reduce the probability of a successful brute-force attack. In view of both usability and security considerations, OTP values with a length from six to eight digits achieve the required overall performance.

# R3: Retry Attempts
Set a limit on the number of validation attempts allowed per login. RFC 4226  recommends a maximum number of possible attempts for OTP validation. In particular, when the maximum number of attempts is reached, the server must lock out the user’s account to defend against a brute-force attack.

# R4: OTP Consumption
Only allow each OTP value to be consumed once. According to the definition of the OTP authentication protocol, each OTP should only be valid for one authentication session.

# R5: OTP Expiration
Reject expired OTP values generated by the TOTP algorithm. Referring to RFC 6238 , the OTP value generated in the next time step MUST be different. It represents that the OTP value generated by the TOTP algorithm should only be valid for a limited time.

# R6: OTP Renewal Interval
OTP values generated by the TOTP algorithm should be valid for at most 30 seconds. Due to the network latency issue, RFC 6238  recommends that “A validation system SHOULD typically set a policy for an acceptance OTP transmission delay window for validation.”; thus, a renewal interval is allowed. For the renewal interval, the login validation system achieves a higher usability by allowing for a longer latency, potentially caused by human and network operations. To balance the demands of usability and security, RFC 6238 suggests that the OTP should be renewed every 30 seconds.

# 2 Threats against OTP Authentication
We determine whether an implementation of the OTP authentication protocol is secure, in that it should at least meet the following two requirements:
1. The authentication protocol should not be vulnerable to brute force attacks.

2. The authentication protocol should be secure against replay attacks.

We observe that if one or more defined OTP rules are violated, the above two requirements may not be satisfied. In the following, we discuss how the violation of our defined OTP rules threatens the security of OTP authentication.

- The violation of R1 indicates that an OTP becomes predictable, and thus the validation systems are vulnerable to replay attacks, allowing attackers to impersonate legitimate users.

- The violation of R2 indicates that an OTP is of limited length, which is vulnerable to brute-force attacks and may be cracked within a few minutes.

- The violation of R3 indicates that an attacker could easily guess the OTP value through a brute-force attack if unlimited attempts are allowed.

- The violation of R4 indicates that a validation system allows an OTP to be used multiple times and thus is vulnerable to replay attacks.

- The violation of R5 indicates that a validation system accepts an expired OTP value and thus allows an unlimited time for an attacker to discover the OTP and consume it before the legitimate user does.

- The violation of R6 indicates that a validation system provides a long time window for an attacker to crack the OTP.

Moreover, we observe that even though the violation of a single rule might not cause severe security issues, powerful attacks could be launched if multiple rules are violated simultaneously:
1. Violation of R1 and any of the other rules. A static OTP value is always vulnerable to replay attacks.

2. Violation of R2 and R3. For an OTP value with length less than six, an attacker can easily crack the OTP value if the number of validation attempts is unlimited (i.e., vulnerable to brute force attacks).

3. Violation of R2 and R4. The violation of R4 allows an attack to reuse current OTP values to launch replay attacks. At the same time, if R2 is also violated, attackers can easily extract OTP values for further attacks.

(4) Violation of R4 and R5. The OTP validation system is vulnerable to replay attacks by allowing an OTP to be used multiple times. In addition, if the validation system does not set OTP expiration, an attacker is able to launch replay attacks by providing the same OTP value. Even though an OTP is encrypted, the attacker can request for verification by submitting the encrypted format directly.

(5) Violation of R2, R3, and R6. Similar to situation (2), an OTP validation with a larger renewal interval provides an attack enough time to crack an OTP with less than six digits. It is vulnerable to brute force attacks.