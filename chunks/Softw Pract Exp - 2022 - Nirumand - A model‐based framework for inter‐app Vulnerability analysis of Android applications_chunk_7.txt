As shown in Algorithm 1, to model the implicit communication domain, all the implicit intents in the Android system are extracted (line 15). According to the Android Application Security Aspects metamodel (the part related to the intent element and its references), an implicit intent is considered as a tuple II = &lt;SCN, N, A, C, D&gt;, where
1097024x, 2023, 4, Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
NIRUMAND et al. 913
# F I G U R E 8
Transforming Android application security aspects models into an intercomponent communication model
SCN is the SendComponentName attribute, N is the Name attribute, A is the Action attribute, C is a set of categories, and D is a set of data. According to the specification of each intent, first, the Android app whose component creates this intent is considered as the sender app (i.e., SenderApp in the ICC metamodel) (line 17). Then, in line 19, the Intent Resolution process45 is used to extract and determine the receiver app(s) and the receiver component(s) (all components in the Android system that can receive and handle this intent). The concept of Intent Resolution and its implementation steps are explained in the following.

# 5 The intent resolution process
When the Android system receives an implicit intent, for example, an implicit intent to launch an Activity, the Android system searches to find the best Activity or Activities for the desired intent. To determine the receiver component(s), the Android system compares the specification of the intent with the intent filters in all available Activity components This comparison is made through the following tests:
1. Action test. The action specified in intent must match one of the actions in the intent filter of the desired component.

2. Category test. The intent filter for the desired component must have the categories specified in the intent.

3. Data (both URI and Data type) test. Depending on the structure of the data, the intent filter of the desired component must support the data in the intent.

The steps considered to implement this process using the ATL and OCL rules are shown in Algorithm 2. This function receives an implicit intent as input and returns app components that can receive and handle this intent. As depicted in this Algorithm, depending on what features the intent has (i.e., action, category, and data), the Intent Resolution Process performs the relevant tests to identify all components of the Android system that can receive and handle this intent. Listing 6 shows an ATL helper, part of Transformation to ICC Model code (i.e., MAASA2MICC ATL code in Figure 8), that implements the Action test for an implicit intent and identifies a set of Activity components that can receive and handle this intent.

Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions (https://onlinelibrary.wiley.com/terms-and-conditions) on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License.

# NIRUMAND et al.

1  ---test context OnlyAction     for    Activity:
2  helper                   MMAASA!Intent          def:TestActionForActivity:Sequence(MMAASA!Activity)=
3
4 if MMAASA!Component.allInstances()->select(c |                               not    c.oclIsTypeOf(MMAASA!ContentProvider))
.notEmpty()         then
5     if MMAASA!Activity.allInstances()->select(c |                                not   c.filters.oclIsUndefined()).notEmpty
6       () then
7     if   not    thisModule.stringOfIntentAction2FilterAction.get(self.Action).oclIsUndefined()
8       then
9          if   not    thisModule.IdentifyReceiverComponentActivity(thisModule.

10      stringOfIntentAction2FilterAction.get(self.Action)).oclIsUndefined()                                              then
11                  thisModule.IdentifyReceiverComponentActivity(thisModule.>collect(c |
12      stringOfIntentAction2FilterAction.get(self.Action))->flatten()-                                                           thisModule
13      .createTargetComponentForActivity(c))
14           else
15              OclUndefined
16       endif
17      elsenot
18       if          thisModule.IdentifyReceiverComponentActivity(self.Action).oclIsUndefined()
19    then
20         thisModule.IdentifyReceiverComponentActivity(self.Action)->flatten()->collect(c |
21    thisModule.createTargetComponentForActivity(c))
22       else
23         OclUndefined
24       endif
25      endif
26    else
27      OclUndefined
28    endif
29 else
30 OclUndefined
31 endif;
Listing 4: ATL helper to perform Action test on Activity components for an implicit intent
Note that the two algorithms (Algorithm 1. Extracting ICCs and Algorithm 2. Intent resolution process) have been implemented precisely and comprehensively to make VAnDroid2 a generic framework for supporting multiple security issues, including inter-app security analysis. Due to the lack of space in this paper, the details of the ATL and OCL rules implemented for these algorithms are explained in a technical report.

# 5 Analysis phase
By gathering all potential communications between Android apps and representing them in a single model, it is possible to automatically and effectively perform security analysis at the intra- and inter-app levels. In this paper, we focus on two prominent inter-app vulnerabilities called Intent Spoofing and Unauthorized Intent Receipt.

Intent Spoofing is an ICC vulnerability. Definition 1 is used to identify all potential communications that can cause this type of security vulnerability. In this security threat, the malicious component (c1 in Definition 1) can communicate with a public component (c2 in Definition 1), while this communication is not expected. If the public component trusts the incoming (received) intent without performing the required security checks, the malicious app component can cause this app component to perform malicious actions. As it was previously discussed, according to the type of the victim component (c2.Type in Definition 1), there are three types of Intent Spoofing: (1) Malicious Activity launch, (2) Malicious Service launch, and (3) Malicious Broadcast injection.

# Definition 1 (Intent spoofing)
Let BApps be a set of benign apps, MApps be a set of malicious apps, AppBundle be a set of benign and malicious apps (i.e., AppBundle = BApps ∪ MApps), C be a set of all three kinds of components (Activity, Service, and Broadcast Receiver), TargetComps be a set of all public (exported) app components of C that can receive an intent, c1 and c2 be two members of C (i.e., c1, c2 ∈ C), P be a set of all four kinds of permissions (normal, dangerous, Signature, and SignatureOrSystem), NormalPermissions be a set of all permissions that their types are normal (i.e., NormalPermissions ⊆ P), c2.Permissions be a set of permissions enforced by c2, c1 and c2 can communicate together, and this communication can be done through an implicit intent or explicit intent. We say that communicate between c1 and c2 has inter-app Intent Spoofing vulnerability, if c1 and c2 do not belong to the same app and there is no permission for c2 or all permissions in c2.Permissions are normal permissions.

Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions (https://onlinelibrary.wiley.com/terms-and-conditions) on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
# NIRUMAND et al.

# Intent Spoofing attack Type (communication (c1, c2)) ≡
c2 ∈ TargetComps ∧ c1.app ∈ MApps ∧ c2.app ∈ BApps ∧ c1.app ≠ c2.app ∧ (c2.Permissions = ø ∨ c2.Permissions ⊆ NormalPermissions)
where attackType =
- Malicious Activity launch, if c2.Type = Activity
- Malicious Service launch, if c2.Type = Service
- Malicious Broadcast injection, if c2.Type = Broadcast
# Unauthorized Intent Receipt
Unauthorized Intent Receipt is another ICC vulnerability. Definition 2 is used to identify all potential communications that can cause this type of security vulnerability. In this security threat, the malicious component (c2 in Definition 2) can intercept an implicit intent (I i in Definition 2) by introducing a filter that matches the sent intent. Therefore, the malicious app component can access all the data on the intent. As it was previously discussed, this ICC vulnerability can be of three types depending on the type of malicious app component (c2.Type in Definition 2):
1. Activity hijacking
2. Service hijacking
3. Broadcast theft
# Definition 2 (Unauthorized intent receipt)
Let BApps be a set of benign apps, MApps be a set of malicious apps, AppBundle be a set of benign and malicious apps (i.e., AppBundle = BApps ∪ MApps), C be a set of all three kinds of components (Activity, Service, and Broadcast Receiver), TargetComps be a set of all public (exported) app components of C that can receive an implicit intent, c1 and c2 be two members of C (i.e., c1, c2 ∈ C), communication (c1, c2) be an implicit communication between c1 and c2, I i be an implicit intent that initiates the communication (c1, c2), P be a set of all four kinds of permissions (normal, dangerous, Signature, and SignatureOrSystem), NormalPermissions be a set of all permissions that their types are normal (i.e., NormalPermissions ⊆ P), I.Permission be the permission specified for I, we say that communication between c1 and c2 has inter-app Unauthorized Intent Receipt vulnerability, if c1 and c2 do not belong to the same app and there is no permission for I i or I.Permission be normal permission.