# 2) WebView BYPASS CERTIFICATE VALIDATION VULNERABILITY (WBCVV)
An App uses the WebView API for certificate verification, but the method onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) which is for handling the exception certificate does not perform any processing. This causes the abnormal certificate to pass the verification.

Vulnerability in overridden method (OM). The functions that lead to the above two vulnerabilities have common characteristics in analytical methods. These are subclass methods provided by the Android system to developers to customize the strong validation logic, and the parent class methods they inherit have the vulnerable logic in default. Developers don’t strictly follow the security specifications to customize the security policy code. The analysis method for this type of vulnerability is described in TABLE 6. An App has an overridden method that is to do the security validation, and its inherited parent method is a weak logic in default. If the method of the App is not written with strong verification, then the App is vulnerable.

# 3) WebView REMOTE CODE EXECUTION VULNERABILITY (WRCEV)
There are three elements that can cause an App to have this vulnerability. First, the App needs to support to run on Android version 4 or below. Second, the App uses WebView’s API addJavascriptInterface(Object Object, String name) to allow JavaScript to run Java. Finally, the App does not add an API as shown in TABLE 5 to remove the weakness interface in the context of using the above API.

Vulnerability of using unsafe APIs (USS). For an App, it uses a potentially vulnerable API, and the developer does not perform codes to protect against the vulnerability in the.

# J. Qin et al.: Vulnerability Detection on Android Apps–Inspired by Case Study on Vulnerability
‘OM’ refers to ‘Overridden method’, ‘USS’ refers to ‘Use unsafe settings’, ‘DLSI’ refers to ‘Data leakage of sensitive information’; ‘ICV’ refers to ‘Improper certificate validation, ‘WBCVV’ refers to ‘WebView bypass certificate validation vulnerability’, ‘WRCEV’ refers to ‘WebView remote code execution vulnerability’ and ‘ACOCDV’ refers to ‘Alibaba Cloud OSS credential disclosure vulnerability’.

# IV. VulArcher-A TOOL TO DETECT VULNERABILITIES
# A. SYSTEM OVERVIEW
As shown in Fig 10, the working process of VulArcher can be divided into the following steps:
# 1) DECOMPILATION
For an App, VulArcher decompresses it to obtain the classes.dex file which contains the source code, the Android-Manifest.xml file which contains component information, permissions and the resource files. VulArcher reverses the classes.dex based on Androgurd . Through this process, it obtains the classes and methods in the source code of the App. Also it decompiles the AndroidManifest.xml file to obtain registered component information and configuration information.

# 2) PACKER IDENTITION
VulArcher recognizes whether an App is packed according to formula (1) and (2). AC indicates the number of all components registered by the App, and CC indicates the number of classes in classes.dex which can obtain from the AC. Because the packed App almost hides all components and other logic codes, classes.dex does not contain these information. Some packing methods have signature files, ie. libexe*.so and libexecma**.so. In order to further clarify packing methods, VulArcher uses the fingerprint to identify the detailed packing type and version of the App.

F = ACCC (1)
App{unpacked, if F ≥ 0 (2)
packed, otherwise
# 3) UNPACKING
At present, more and more Apps are packed. Static analysis can not directly get the real code of the packed Apps. This causes static detection to fail to analyze vulnerabilities of such Apps. Therefore, the analysis of packed Apps should be carried out by unpacking method, for extracting the original code of Apps. The unpacking method used in this system DexX  is a result of our previous research. It can handle the six packers, such as Ali , Baidu , Bangcle , Tencent , Qihoo 360 Mobile , and ijiami . This paper does not elaborate too much for the method.

# 4) BUILDING TAINT PATH
VulArcher creates a taint control flow graph(TCFG) of a classes.dex, the algorithm is shown in Algorithm 1. VulArcher creates a control flow graph(CFG) of the classes.dex. the set V of p nodes in CFG is shown in formula (3). Each vk contains the package name(pkgk), class name(ck) and method(mk). As shown in formula (4), the set IA of m interested APIs is a subset of V. For each iA,j we follow the heuristic method to find its taint path tp, it’sj′ are shown in formula (5). V ′ is a subset of V, the points in V related to the control flow of iAj. If vk has a control flow to vw,
VOLUME 8, 2020 106443
# J. Qin et al.: Vulnerability Detection on Android Apps–Inspired by Case Study on Vulnerability
# docompiation
# Packor Identntion
# Unpacking
compcnen sonilas App memory
chrnp derIile
Resouict
unzip
cmnone
i packed
Apk file
# Methods
S0 Ilet @eniity the type
Dickina
gacked
Dex file
Dex Ille
# Detection
vulnerabilin
# Building Taint Path
Heurised constnucion aint aths
# Methods
taniDuins
# Algorithm 1 The Algorithm of Building TCFG
1. Input: IA, CFG {IA the set of interested APIs.}
2. Output: TCFG
3. INITIALIZE TCFG = ∅
4. for each iAj ∈ IA do
5. tpj ⇐ HeuPath(CFG, iA) {A heuristic method to find taint path tpj of iAj.}
6. BuildG(TCFG, tp) {Building the TCFG with tpj.}
7. end for
8. return TCFG
CS = {cs|j = 1, . . . , r}
f (R, CS){Vul,R = {vr1, vr2, . . . , vrn} if vri is matched in CS notVul, otherwise
we think there is a taint control flow relationship from vk to vw <vk , vw>, we denote the set of all the above relationships as E′. As shown in formula (6), TCFG is composed of all tp(j = 1, . . . . ., m).

V = {vk = (pkgk , ck , mk )|k = 1, . . . , p}
IA = {iAj = (pkg, c, m)|j = 1, . . . , m, and m ≤ p}
tpj = {(V j ′, Ej ′)| < vk, vw >∈ Ej ′, V j′ = {vk|k = 1, . . . , q}}
TCFG = {tpj|j = 1, . . . , m}
# 5) DETECTION
VulArcher uses the rules of above vulnerabilities and the TCFG of an App generated in the Building Taint Path for vulnerability judgment. In order to detect vulnerabilities faster, we propose a heuristic vulnerability search algorithm.

The algorithm first obtains a suspected vulnerable point in interestSet, then in the already constructed TCFG, it constructs the relevant slice content of all objects.

106444
VOLUME 8, 2020
# J. Qin et al.: Vulnerability Detection on Android Apps–Inspired by Case Study on Vulnerability
# Algorithm 2 A Heuristic Vulnerability Search Algorithm
1. Input: interestSet, FR, TR {interestSet in the algorithm represents all sensitive APIs and methods that may cause vulnerabilities in the App. FR represents a collection of rules for vulnerability fixes and TR represents the set of rules that the vulnerability triggers.}
2. Output: output(path,contextSlice) {This stores the detailed code snippet of the vulnerability and the path where the vulnerability is located.}
3. INITIALIZE output(path,contextSlice) = ∅ {FindPath can find the caller paths in the APK through a function that is suspected of a vulnerability.}
4. for each ti ∈ InterestSet do
5. path ⇐ FindPath(TCFG,ti)
6. contextSlice ⇐ GetContextSlice(path) {Getting detailed function information by the path.}
7. if (FR ≠ ∅) and (TR ≠ ∅) then
8. if HeuSearch(contextSlice,TR) == True and HeuSearch(contextSlice,FR) == False then
9. output(path,contextSlice)
10. end if
11. end if
12. if FR ≠ ∅ then
13. if HeuSearch(contextSlice,FR) == True then
14. continue
15. else
16. output(path,contextSlice)
17. end if
18. end if
19. if TR ≠ ∅ then
20. if HeuSearch(contextSlice,TR) == True then
21. output(path,contextSlice)
22. else
23. continue
24. end if
25. end if
26. end for
27. return output(path,contextSlice)
variables in the point, that is, contextSlice. It uses a heuristic search algorithm to search in contextSlice. If there is a rule for repairing the vulnerability in the slice, then the App does not have the vulnerability. Otherwise, if it finds the rule for triggering the vulnerability in slice through the search algorithm, then it records the complete path information and slice of the vulnerability of the App.

# C. VERIFY METHOD AND WORKFLOW
Nowadays there are more and more vulnerability detection tools. To some certain extent, they can detect some vulnerabilities and weaknesses. But they do not provide developers with some way to reproduce vulnerabilities. This is the reason why more and more vulnerabilities are ignored by developers, as a result, many Apps still have vulnerabilities that have been reported for a long time. In this paper, we provide semi-automated verification methods and workflow for the vulnerabilities and weaknesses we analyzed. This work can verify the detection results of VulArcher and provides readers with clear methods of vulnerabilities’ verifications.