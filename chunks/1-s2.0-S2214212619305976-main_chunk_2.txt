# 2. Anti-Debugging protections
- Emulator detection: Attackers may take advantage of Android emulators to monitor the status of an app. Attackers can read the values of program variables and sniff Internet traffic, inferring valuable information about the functioning of the app. However, Android emulators have several default configuration values that app developers can detect. Therefore, app developers can insert in their apps mechanisms to inspect system properties to check whether the app executes in an emulator. For instance, it is common to read the model or the manufacturer of the smartphone to compare it against values related to Android emulators, like “generic” or “goldfish”.

- Dynamic analysis framework detection: Similar to Android emulators, dynamic analysis frameworks allow attackers to gain insights on the functioning of an app. These frameworks, like Taintdroid , Xposed and Frida, run on real Android devices and allow manipulating the runtime environment by hooking API calls to return spurious values. For instance, whenever the app is requesting its digital signature through the PackageInfo.signingInfo attribute, the attackers could use Xposed to intercept this invocation and return whatever value they like. Moreover, these frameworks allow monitoring the status of Android apps and dynamically altering their behaviour. Detecting these runtime modifications is not easy. Therefore, the focus of the protection is often on spotting the presence of these frameworks in the smartphone. The simplest way is to scan package names, files or binaries to look for resources known to be components of these frameworks.

- Debugger detection: Android supports two debugging protocols: Java level through the Java Debug Wire Protocol (JDWP) and Linux level with GNU Debugger (GDB). Usually, developers employ debuggers in the testing phase to find bugs in their apps. However, attackers can use debuggers to send commands to the app and alter the execution flow or the values within program variables. For instance, an attacker could tamper with the value of the variable holding the amount of virtual money in a game app. To be fully protected, an app has to implement protections against both levels of debugging. An app can detect a JDWP debugger by invoking the available API through both Java and Native.

1 https://www.xda-developers.com/xposed-framework-hub/
2 https://www.frida.re/
S. Berlato and M. Ceccato / Journal of Information Security and Applications 52 (2020) 102463
# 2. Anti-tampering protections
- Signature Checking: Tampering an app usually implies the modification of its code. Then, the attackers have to repackage the new version of the code into an Android Package (APK) file that end-users will install on their smartphones. Since the Android operating system requires APKs to have a digital signature to check upon installation, the attackers need to sign the APK file again. The attackers cannot access the private key of the original developers. So, the attackers will sign the APK file with a different key. Therefore, the most trivial protection against tampering is to compare the current signature of the APK file with the original one. The app can obtain the current signature through dedicated APIs using the PackageManager.GET_SIGNATURES and the PackageInfo.signatures (until Android version 8) or PackageManager.GET_SIGNING_CERTIFICATES and PackageInfo.signingInfo (from Android version 9) APIs.

- Code integrity checking: Following the same concept of the previous protection, Code Integrity Checking is another similar protection. This time, the app computes a digest value on a specific resource or file and then compares it with the expected value. Therefore, an app can access and hash the file containing the Java code (i.e. the .dex file) and check whether this value is equal to the expected value or not. App developers can use standard libraries like Zipentry3 to automatically obtain useful values like the Cyclic Redundancy Check (CRC) error-detecting code.

- Installer verification: To avoid detection, usually, attackers publish tampered and repackaged apps in third-party app stores15. When installing an app, the Android operating system keeps track of the app store where the APK file comes from. The app can invoke the PackageManager.getInstallerPackageName API that returns the package name of the app through which the end-user installed the current app. The protection consists of checking whether this value is consistent with the app stores where the developers published their app. Let’s suppose the developers published their app only in the Google Play Store. End-users should have installed the app through the Play Store app that has “com.android.vending” as the package name. If the value returned by the PackageManager.getInstallerPackageName from Aptoide4 API is “cm.aptoide.pt”, the app was installed from an independent Android app store. Therefore, some attackers likely tampered the app and published it on Aptoide.

- SafetyNet attestation: SafetyNet16 is a platform security service offered by Google16. An app can invoke SafetyNet to verify the integrity of the smartphone in which it is running. However, SafetyNet can also provide information about the app that invoked the service, like the signature.

# 2. Exclusions
Developers can implement many other protections in their apps, that we decided to exclude:
- Root detection: A end-user can obtain superuser permissions over an Android smartphone through a process called “Rooting”. With superuser permissions, it is possible to alter system settings, access private areas in the primary memory and install specialized apps. For instance, with superuser permissions, an attacker can install dynamic analysis frameworks like Xposed. Even though providing significant insights about the smartphone where the app runs, this protection does not address AD or AT directly. Indeed, this protection provides information about the status of the smartphone rather than on the app itself.

- File storage integrity checking: Some apps may externally download code and resources after they are installed and then perform checks on them, but this is a discouraged feature17. Therefore, an app would not implement this protection not because the developers are overlooking security, but because downloading code after installation is a feature not implemented in the app.

- Time-checks: Another way to detect debuggers is to implement time-checks. The possibility to insert breakpoints in the code is one of the most useful features of a debugger. This allows analyzing the execution flow of the app and the status of the variables. However, this also halts the execution of the process. Therefore, an app can monitor the elapsed time between two instructions. If this time is longer than a pre-defined threshold, a debugger has most probably halted the execution in between the operations with a breakpoint. However, an app may query for the time for many reasons, like performance evaluation, alerts or scheduled notifications. Therefore, this protection is problematic to detect and it would suffer many false positives.

# 3. Definition of protection fingerprints
We now present our method for the detection of the protections in Android apps. In this section, we describe the general
3 https://developer.android.com/reference/java/util/zip/ZipEntry.

4 https://www.aptoide.com/en/home.

# S. Berlato and M. Ceccato / Journal of Information Security and Applications 52 (2020) 102463
Set of protection atoms for the installer verification protection at java level.

# Example Implementation of Installer Verification Protection
approach with a concrete example for one protection. Then we illustrate how we combine the elements of each protection to create a fingerprint. Finally, we present the tool we developed for the automation of the protection detection.

# 3. General approach for protections atoms identification
Starting from the description of each protection, we analyze instruction-by-instruction which are the most characterizing programming elements. From each instruction, we extract the essential ported symbols (C++) and strings (Java elements in terms of classes, methods, attributes programming C++) used in the code. The result is a collection of elements that together identify the protection. When found in the code, these elements are clues that the developers deployed the protection in their app. We call these elements “protection atoms”. We applied this approach for every protection for both Java and C++ implementations. For instance, Fig. 1 (page 5) shows the implementation for the Installer Verification protection proposed by Alexander-Bown.

The snippet of code in Fig. 1 (page 5) checks whether the end-user installed the app from the Google Play Store. To achieve this objective, the code declares a string variable containing the package name of the Google Play Store app, that is “com.android.vending” (line 1). Then it defines a function verifyInstaller (line 5). Given an instance of the Context object, this function gets the package name of the installer (lines 6-7). The function tests whether the string is empty or not (line 9). If the end-user installed the app from an APK file manually and not from an app store, this could happen. Finally, the function checks whether the string is equal to the package name of the Google Play Store app (line 10). If this is the case, the end-user installed the app through the Google Play Store. Otherwise, the app comes from another source. In case the developers originally published their app only in the Google Play Store, this is an indication of possible tampering attempt. It implies that someone else downloaded the app, most probably modified it, and then published it in another app store.