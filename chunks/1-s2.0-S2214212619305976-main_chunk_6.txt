We observe that 99% of the identified protections are implemented in Java. Only 2% (521 over 23,610 apps) of top-category Android apps implement Native protections, and in general no more than one. We can infer that there are more protections.

12 S. Berlato and M. Ceccato / Journal of Information Security and Applications 52 (2020) 102463
deployed at the Java level rather than at the Native one, implying that developers quite never consider implementing protections in C++. Then, the trend of Java protections is practically equal to the one presented in Fig. 8 (page 15). There can be several explanations for this lack of Native protections:
- It is more difficult to implement protections at the Native level than at the Java one.

- While every app contains Java code, not all apps include Native code.

- Empirically, we noticed that it is easier to find on the internet snippets of code for Java protections rather than Native ones.

adoption rate decreases from 12% to 11% and the Code Integrity Checking, that decreases from 0% to 0%.

We applied the Fisher’s exact test on the data in Fig. 12. The test result confirms that the different trends between 2015 and 2019 are statistically significant.

# 6. Discussion
In this section, we discuss technical limitations and the threats to validity.

# 6. Technical limitations
# 5. RQ5 - Evolution in adoption of AD and AT protections
This last research question compares statistics about identified protections between the datasets of apps from 2015 and 2019. The results are reported in Fig. 12 (page 20). Results are in percentage, because of the different number of apps in the two datasets of this analysis. According to Fig. 12 (page 20), apps in 2019 seem to deploy more protections than apps from 2015. In fact, the percentage of adoption increases from 80% to 88% for the Signature Checking protection, from 71% to 74% for the Installer Verification protection and from 41% to 49% for the Emulator Detection protection. The other protections follow a similar pattern, with the only exception of SafetyNet Attestation, whose ATADetector is a static analysis tool and Java Reflection, even though mitigated by detecting FQN, will always be a limitation. Through Reflection, developers can screen API invocations in the code of their apps. Besides, there are methods through which developers can furtherly hinder the analysis of their apps. For instance, String Encryption consists in encrypting constant strings to make them unreadable by static analysis tools. Then, a routine decrypts the strings at runtime when detection needed. ATADetector relies on strings for both the of FQN to mitigate Reflection and as protection atoms themselves. Therefore, String Encryption threatens the effectiveness of the detection of our tool as well since it makes statically reading the value of these strings nearly impossible.

# S. Berlato and M. Ceccato / Journal of Information Security and Applications 52 (2020) 102463
# 6. Threats to validity
Construct validity: There are three reasons for which the statistics we produced may not be accurate:
- Our fingerprints may not cover all possible ways in which developers can implement AT or AD protections. Despite we adopted an incremental refinement and validation of our fingerprints to limit this threat, there may be other programming elements we did not consider that developers can use to implement their protection. Therefore, we could still have missed some protections.

- Third-party libraries detection is based on a list that may not contain the package names of all third-party libraries available to Android developers. Therefore, this measurement could not be extremely accurate. Also, if the developers obfuscated the package names of the libraries, we would misclassify some protections. However, note that solving these issues would only lower even more the percentage of protections found in the apps developers’ code. Detecting third-party libraries with more precision would categorize more protections as belonging to the libraries themselves. Therefore, the percentage of protections coming from the developers is anyway less than 28%.

- In general, it is known that code hardening (e.g., reflection, string encryption, obfuscation) causes problems to static analysis. Therefore, ATADetector may have missed some protections because concealed by the developers. However, ATADetector found more protection in 2019 than in 2015. This suggests that, even though apps from 2019 may have been hardened, our approach works well on modern and obfuscated apps.

External validity: Our analysis considers apps from one single app store only, i.e. the Google Play Store. Therefore, our analysis could be biased and our results might not extend in general to apps coming from other stores. To limit this threat, we considered apps from all the categories to have a wide variety of cases, and from different years.

# 7. Related work
In the literature, numerous researchers focused on the security analysis of Android apps. Concerning protections against malicious reverse engineering, some works presented novel approaches and schemes. Others described large-scale studies to assess several properties of Android apps related to security and reverse engineering.

# 7. New protections for android apps
Piao et al.  proposed a server-based approach to provide both encryption and AT protection. A server stores the main functionalities of the app encrypted together with a tamper detection protection. When needed, the code is downloaded and decrypted with a one time secret key. Similarly, Viticchie et al.  automatized the deployment of AT protections using a Reactive Remote Attestation technique. This technique consists in splitting the code of the app and moving the core routines server-side. Before accessing these routines, the app has to prove its integrity to the server. In a successful scenario, the server executes the core routines and returns the results to the app. Otherwise, the server does not run the code to prevent the tampered app from continuing its execution. Divilar is a tool developed by Zhou et al.  for re-encoding an Android app with a random instruction set over dex bytecode as an AT protection. The app executes with a specialized virtual instruction interpreter, designed to be integrated with the Dalvik virtual machine to reduce the performance overhead. Wan et al.  developed an AD protection by building check points for integrity verification. They analyzed open-source tools for hookings methods and APIs to identify such check points. If one of these tools hooks a method to debug an app, it will alter the value of the check points related to the method. Their approach can detect this modification and then raise a warning. Abrath et al.  investigated the weaknesses in AD protection through self-debugging. They argue that attackers can easily bypass this approach with little effort. Therefore, they propose a new technique in which portions of the code of the app are moved in the debugger itself, hindering the attackers in the reverse engineering process. They also provided an
# 7. Large-scale studies on android apps
Ghafari et al.  analyzed thousands of app from the Google Play store to detect pre-defined patterns of coding errors that lead to security vulnerabilities. First, they defined a list of bad programming habits, the resulting vulnerability and a possible solution or mitigation. Then, they implemented the detection of such errors in a static analysis tool. They asserted that more than 90% of the examined Android apps contain at least one potential vulnerability. Shan et al.  focused on the categorization of what they defined as “self-hiding behaviours” in Android apps. These techniques allow apps to conceal their activities from end-users. They provided a list of such behaviours along with a description and an example implementation. From this code, they extracted unique patterns and designed a static analysis algorithm able to detect them. One of their findings is that legitimate apps employ these behaviours as much as malicious ones. Gao et al.  analyzed trends in misuse of Android’s cryptographic-related APIs. A misuse is defined as a wrong or insecure configuration of such APIs, like the use of outdated algorithms (e.g., MD5), the hardcoding of salt values and the storing of sensitive data as (immutable) Java strings. The initial assumption is that app updates across an app lineage are likely to fix these misuses. The authors employed an already existing static analysis tool in a large-scale study on 40 thousands of apps lineages. Counterintuitively, the finding is that misuses of crypto-APIs are not likely to be fixed by app developers. Habchi et al.  performed a large-scale study to analyze bad programming practices, which they call “code smells”, on Android apps. Their goal is to understand whether these smells come from inexperienced developers only. The authors defined and described 8 bad programming practices and build on top of them a static analysis tool. Their finding is that smells are not the responsibility of an isolated group of developers, and there are no distinct groups of code smell introducers and removers. Developers who introduce and remove code smells are mostly the same.