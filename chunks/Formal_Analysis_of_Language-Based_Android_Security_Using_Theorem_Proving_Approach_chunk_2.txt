# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
(integrity violation). The bottom dashed arrows in Fig. 1 show an example of the best practice: public and trusted data can be read by a component with secret and untrusted security context (data flow from higher security context to lower is permitted). A number of other data flow scenarios in Android applications, which can be captured by the type system mechanized in this paper, have been described in.

To prevent such security violations, existing security enforcement systems ,  can be used to type-check (capture valid data flows) and reason about Android applications. However, giving guarantees of data flow security properties of well-typed applications in an informal setting is tedious and error prone. Furthermore, these security techniques themselves need to be reasoned about to verify their correctness. As these security techniques cannot be read by a formal computer tool, they are not fit for mechanical reasoning about Android applications’ security and the (programming) language-based technique itself. Among the major advantages of formal analysis using computer-aided formal verification tools is that a computer can be used to machine check correctness (well-typedness) of Android applications, analyze them mathematically and generate machine-readable proof script. Formally reasoning about programming language properties using mechanical theorem provers is challenging due to the issues with representation and manipulation of terms using variable binding . To resolve such issues, locally nameless representation  has been applied to formalizing programming languages in theorem prover. Locally nameless representation has been applied to different domains in the past –. However, to the best of our knowledge, no one has used this approach in mobile applications’ security domain.

# B. SOLUTION OVERVIEW
In this paper, we build a formal model of language-based technique  in the human-assisted computer-based proof tool Coq using locally nameless representation. Furthermore, we demonstrate effectiveness of locally nameless representation in carrying out formal machine-readable proof of soundness of the language-based technique. The major contributions of this paper are the following:
- We enable formal reasoning about Android’s permission system using computer-based theorem prover tool; a formal model of the Android’s permissions is built using the logic behind theorem prover.

- We augment the language-based security technique with computer-aided verification tool, and locally nameless representation is formalized.

- We mechanically (using a computer) check correctness of terms (programs), and build a formal model of Android type checker.

- We demonstrate that locally nameless approach facilitates the proof process and guarantees well-typed (correct) Android code, and mechanically carry out formal proof of soundness of the Android type checker.

The rest of the paper is organized as the following: In the next section, a brief overview of the Android application security, permissions, Coq theorem prover and locally nameless representation is given. In Section III, the formal model of the type system is presented. The proofs of the type system properties, weakening and strengthening, are given in Section IV. A summary of the related work is presented in Section V, and the paper is concluded in Section VI.

# II. BACKGROUND
In this section, Android application framework with the security model, the formal language describing Android applications, proof assistant Coq and locally nameless representation are briefly introduced. The formalization of Android permissions and language-based security technique are described in Section III.

# A. ANDROID SECURITY MODEL
The Android application framework  supports programming languages Kotlin, C++ and Java for application development. The source code of an Android application is compiled into an Android package (APK) using Android SDK tools. The package, containing all the contents of Android app, is used by the Android-powered device to install the app. Following Linux kernel security rules, Android operating system considers each app as a different user and assigns it a unique user ID. It executes each individual app in isolation by a separate process using its own virtual machine. The default rule for Android security is the principle of least privilege. By this rule, each app is given only the minimum permissions to access components required for its work. Different applications can also share data with each other (e.g., by sharing common Linux user ID) and access system resources by requesting permissions.

An Android application comprises of many components of four types: activity, receiver, service and provider. Each individual component provides a different entry point for the system to enter the application. The activity component represents the presentation layer of application. For example, the user interface on screen, which the user sees, is controlled by an activity. A single application may include more than one activity and a user can switch between activities. Services execute in the background and perform long-running operations without a user interface. However, they can notify the user through notifications. Broadcast receivers receive messages from system and receive implicit (without target name) intents. The intents are messages used by Android applications to request different functionalities from other services or activities. An application can address/access a component through intents explicitly by using the target component name or implicitly by naming an action to be performed by a relevant component. Content provider components serve as data storage units for the applications. Other application components can read/write the data from/to content provider upon permission.

16552 VOLUME 7, 2019
# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
# Binder Phone
Terms t in the language are defined for call and return from an activity, bind to service, register new service, send to a receiver, reading from/writing to content provider and so on. A program runs in an environment, derived from the set of applications installed on the mobile device, and maps names to components. Avik Chudhuri defined a security type system to capture safe data flows among Android applications. For further details about the language syntax and type system, readers are recommended to refer to.

# Android Permission System
Android enforces security through permissions by restricting applications to interact with each other and access different resources. For two applications to access each others’ resources, they both must share the same user ID or they must have the desired permission to do so. Two applications, both with IDs 1001 in Fig. 2 (inside sandbox), have the same user ID (they are created by the same developer who has requested common ID) and can access each other’s resources directly using the file system. All other applications, with different user ID, can interact with each other through the Android binder interface, which invokes permissions. To send an SMS, for example, the Message application (Fig. 2) requests the Phone application through the binder to send an SMS. The binder forwards the request only if the Message application has the permission SEND_SMS.

# Program Syntax
# Language-Based Android Security
Chudhuri  defined a core programming language to describe Android applications. Assuming a security lattice of permissions, the language syntax (Fig. 3) includes intents as a pair of component name (action) to be accessed and a value to be passed to the component as a parameter. All names n, variables x and a constant void make the values v. Next, we define a recursive function add (lines 5–9) on the numbers just defined. The function returns the second argument m if the first argument is O and it returns S (add n′ m) if the first argument is of the form S n′. A lemma add_n_o, that add n O = n holds for any value of n, is stated and proved in Fig. 4 (lines 11–18). The lemma is proved using induction on the construction of the first argument n. During the proof process, the theorem prover is guided interactively by providing commands called tactics (lines 13–17). The correctness of the proof script just created (lines 12–18 in Fig. 4) can be mechanically checked using the Coq proof checker program. The symbol → in the Coq script.

# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
# D. LOCALLY NAMELESS REPRESENTATION
For increased confidence on complex and large system designs in programming languages, it is often desired to check the proofs of properties of programming languages using human-assisted computer-based theorem provers, such as Coq and Isabelle/HOL. However, this comes with the key challenge of representation and manipulation of terms with variable bindings, in particular, in large formal developments. Aydemir et al.  introduced a novel approach to formalizing metatheory based on a combination of locally nameless  representation of terms involving binders and cofinite quantification of free variable names in rules involving binders in inductive definitions of relations on terms. In locally nameless representation, bound variables are represented with de Bruijn indices and free variables are represented with names. Locally nameless representation obviates the issues related to alpha-conversion as now each alpha-equivalence class of terms has a unique representation. Cofinite quantification, on the other hand, makes the structural induction principles of relations strong enough for metatheoretic reasoning ,.