First, the developer embeds a given ad library in her application. Then, when the app is running, the ad library contacts its backend server and asks for an ad to be displayed. Depending on the ad library’s implementation, this first request can reach one or multiple servers. In case of an individual ad network, the library contacts a single server, while in case of an ads aggregator the request is sent to multiple servers. The server then forwards the request to its ad network, which might be more or less complex. Within the ad network, the bidding auction starts. Bidding consists of advertisers (brand) declaring the maximum amount of money they are willing to pay for each impression (or click) of their ad. The winner sends the content of the ad back to the library, and the ad is then displayed in the app, normally within a WebView. Moreover, if the user clicks on the ad, then the full enriched content is retrieved from the server of the auction’s winner (which is related to the specific ad, and not to the ad library itself). The complexity of the ad ecosystem and the interconnection of multiple players—each of which only controls a portion of the ecosystem—opens interesting questions related to the NSP. Since the winner of the auction is usually not under
352 29th USENIX Security Symposium USENIX Association
# 6 Dataset
To perform this investigation, we built a comprehensive and representative dataset of the most used ad libraries. We choose the Top 29 ad libraries from AppBrain  based on the ranking “number of applications.” Table 4, in Appendix, summarizes the statistics about the ad libraries.

# 6 Policy Characterization
We investigated whether a given ad library requires a policy modification and of which kind. To identify if a library requires a policy, we start by looking at its official documentation. In case we do not find any reference to the NSP, we then proceed by analyzing the source code of the “reference example app,” which is always provided by the ad library developers to show how such a library can be integrated. Among the 29 libraries that we analyzed, we found that 12 of them do require the developer to modify the policy. (The remaining 17 do not require any modification, which suggests that their backend infrastructure is fully compliant with the latest standards and defaults.) One of these is the Facebook ad library, which only requires the developer to specify a configuration for a single domain (see Section 5). The other libraries require more invasive modifications, which we discuss next.

# Cleartext
Our first finding is concerning: All the 11 libraries require the developer to allow cleartext on her application. We found that MoPub, HyprMx, HeyZap, Pollfish, AppMediation, and Appodeal do force the developer to completely allow cleartext protocols for all domains. We also found that AdColony, VerizonMedia, Smaato, AerServ, and DuApps push the developer to adopt the first version of the policy, with similarly negative consequences. These configurations make ineffective any safety net that a NSP may provide. However, we note that these ad libraries may be required to ask for this modification since it could be that a given ad framework does not have enough control over the type of URLs (HTTP vs. HTTPS) that are served as part of the ads.

# Trusted Anchors
We have identified ad libraries defining a trust-anchors node. Even in this case, the findings are concerning: Appodeal  and HeyZap  suggest the developer to add User KeyStore as trusted, thus providing a venue to perform MITM attacks. Moreover, none of these libraries provide any custom CA, nor ask the developer (or the user) to do so, making this risk completely unnecessary.

# Misleading Documentation
We argue that the security repercussions of NSP modifications should be explained and justified to developers so that they can take informed decisions on whether to include a given ad library. However, we found how this “transparency” is not a common practice. After closely inspecting the documentation of the 11 ad libraries mentioned above, we found that none of them inform developers of the possible consequences of allowing cleartext protocols or trusting User KeyStores. Some of these libraries simply inform the developers that they need to apply their modifications of the NSP in the name of “usability” and to avoid any faulty behavior. Moreover, we identified how Millenial Media, Smaato, HyprMX, and AerServ simply ask the developer to copy-paste the provided sample AndroidManifest, without explicitly mentioning the fact that such a sample manifest silently specifies a “usesCleartextTraffic” policy. Even worse, we found how Du Apps misleadingly justifies the need to allow cleartext traffic because it is “required for target SDK28.” We believe that the underlying reason for these problems is that most of these ad libraries found themselves in difficulty due to their infrastructure not being ready to deal with Google’s HTTPS everywhere push.

# 6 Ad Libraries in Apps
As previously discussed, we identified some ad libraries that ask developers to weaken their security policy and to allow cleartext. We performed additional experiments that aim at determining how frequently these ad libraries are used within our dataset and whether these apps allow cleartext as part of their NSP.

To detect a third-party library within a given app, we use LibScout , the state of the art static analysis tool for this kind of task. According to the paper, LibScout can detect the inclusion of external libraries within apps even when common bytecode obfuscation techniques are used. LibScout supports two types of detection: the first one is based on a simple matching with the package name, while the second one relies on code similarity. By default, it reports only matches that have a similarity of at least 70%. For our experiment, we used the same threshold. Currently, LibScout supports only the Facebook Audience ad library. We extended it by creating profiles, necessary for the detection, for all the ad libraries that require the developer to
Dataset 1 represents the analysis over 16,324 apps, while Dataset 2 represents the analysis over the second version of the dataset composed of 108,542 apps.

We modify the NSP to allow cleartext. Then, for each of the apps in our datasets, we run LibScout for a maximum time of one hour.

We run LibScout on the first dataset of 16,324 apps (which specify a NSP), and also on the second “fresher” dataset of 108,542 apps. For the first dataset, LibScout was not able to conclude the analysis in time for 8 apps, while it terminated correctly for all the apps in the second dataset. In total, the matching engine was able to identify that 19% of the apps belonging to the first dataset (3,230) do have one of the ad libraries that requires cleartext. For the second dataset, instead, it identified 8% of apps (9,645) containing at least one of the libraries.

We then proceeded by checking how many of the apps identified by LibScout effectively have a NSP that allows global cleartext, as defined by the ad libraries. Table 2 summarizes our findings. We note how for the first dataset, 89% of the apps (2,891) embedding an ad library do have a NSP that allows cleartext. However, 11% (339) do not allow it: for these apps, the ads served over HTTP will not be displayed and an Exception is thrown. We also note that even if apps do not use ad libraries, a large portion of them (83%) still use HTTP. Thus, while ad libraries asking developers to weaken their security policy certainly does not help, it does not seem to be the only reason app developers stick to insecure HTTP connections. For the second dataset, we found that, among apps that include an ad library, 75% of them (7,298) define a NSP that permits cleartext. The percentage of apps that allow cleartext decreases to 66% when considering apps that do not include one of the ad libraries we have checked for.

# 6 Case Study: MoPub
We now present an in-depth analysis of one of the most prominent ad libraries, MoPub . This library is an individual ad serving platform used by over 19k applications, some of which have more than 50M unique installations. MoPub is one of those libraries that requires an app developer to allow cleartext for her entire app. For this case study, we set out to determine whether this library really had no other choice but to require cleartext on the entire app to properly work. To shed some light, we aimed at monitoring the network requests performed by this ad library at run time. We note that a simple network monitor on the traffic generated by the entire app is not enough: by just observing network traces, it would be very challenging to determine which traffic has been generated by the ad library and which by unrelated components of the app.