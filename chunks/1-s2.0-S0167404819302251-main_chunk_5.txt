We evaluate EspyDroid+ on diverse datasets to avoid any potential discrimination. The first dataset is composed of 13 medium size open source apps downloaded from F-Droid (Free and Open Source App Repository, 0 0 0 0). The reason for choosing this dataset is the availability of app source code, which makes it easier for manual verification purpose. We manually add malicious reflection code, which includes ICC dependency and obfuscation in each app. We obtain ICC communication among components of each app and select any two components (caller-callee) at random having communication. The code for collecting IMEI using reflection APIs and sending this IMEI to callee along with ICC call as parameter is added in caller component. Similarly, the code for receiving of IMEI and leaking it through use of reflection APIs is added in callee component. This approach of adding reflection is based on various samples contributed by us to DroidBench. The second dataset composed of same 17 apps as used by Ripple  on reflection analysis. All the apps are downloaded from Google Play store. The choice to select this dataset is because the apps contain reflection code and we could compare the results. The average app size is 55 MB in this dataset. The apps were quite large as compared to F-Droid dataset and all the apps were having complex GUI, and large number of components, which is a challenge for state-of-the-art. The third dataset is composed of randomly selected samples (2017 and 2018) downloaded from VirusTotal. As the fourth dataset, we choose various families from Malgenome project (Jiang and Zhou, 2012). Specifically, we selected the apps from families that massively use reflection to hide calls to sensitive API methods used for leaking sensitive data. The last dataset is composed of 413 apps which are classified by authors in four categories i.e., SMSMalware, Adware, Scareware, and Ransomware. This dataset is created by the Canadian Institute for Cybersecurity and recently used in (Fallah and Bidgoly, 2019; Lashkari et al., 2017; 2018; Lee and Park, 2019; Taheri et al., 2019).

# J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
Performance evaluation of proposed approach RGSS.

Evaluation of dynamic analysis.

VT - VirusTotal, #RLog - Number of reflection calls logged.

responds to a huge reduction in the exploration space of dynamic analysis with same accuracy. This reduction is without loss of any information as our approach does not remove any path leading to desired state. As shown in the last column of Table 1, exploration of sliced apps takes around 1 minute for the average app size of approximately 55 MB while the original apps have quite large exploration time. The automated exploration follows the approach mentioned in . Table 1 - column 7 depicts the number of explicit transitions added by EspyDroid+ for different datasets for improving the coverage of reflective calls. We manually verify the results of Table 1 for F-Droid dataset (opensource) and found that EspyDroid+ is able to log all reflection calls successfully. We used Android emulator having API level 19 for experiments. The apps are instrumented with APIMonitor to report the reflection APIs executed in Logcat. Table 2 shows the results of number of distinct reflection calls logged and exploration time for both original (#RLog (Original)) and sliced app (#RLog (Sliced)) after dynamic analysis module of EspyDroid+. Due to paucity of space, details of nine randomly selected apps have been added. We have added the results of all the 267 apps as the last row of Table 2. As seen from the Table 2, the number of logged reflection APIs is sufficiently higher on sliced apps. Moreover, the exploration time on sliced apps is reduced significantly. The results in Table 2 show that EspyDroid+ has 9% more coverage (Number of reflection calls logged increased from 2684 to 2950) on sliced apps because of conditional rewriting through instrumentation, improved UI exploration, and adding of explicit intents. Table 2 further shows 51% of decrease in analysis time (exploration time reduced from 15,356 seconds to 7486 seconds) due to removal of irrelevant paths. We came across various sensitive run-time operations, such as termination of incoming calls, connecting to Command & Control server, etc., which were hidden through reflection deeply inside app components.

RGSS for representative example of Virustotal dataset.

The app checks whether Internet is available or not and turn on the mobile data in case Internet not available. The app has declared permission of CHANGE_NETWORK_STATE along with other dangerous permissions. The app uses field, method, and class reflection for enabling mobile data and thereafter leaks various information of device like IMEI, Build, release, etc., through Internet. The original app is having 12 states (2 activities, 2 services, 5 receivers, and 3 non-component classes), 12 transitions, and one final states (State 11). Reflective calls were present mainly in one Java class. RGSS reduced the number of transitions to 10 where one of the valuable pruning is the transition between MainActivity to Cgiva Activity (State 1 to State 2 in Fig. 9). As shown in Table 2, the number of reflection calls logged in original app is 0. The dynamic analysis is triggering Cgiva activity and then stopping the analysis. There is receiver boutq which has paths to final state. However, its calling is dependent on system event BOOT_COMPLETED.

3 https://developer.android.com/studio/command-line/logcat
4 0a3e346cce78c22a1e8a6ee92d97e65050bcd92339eda1ee738759446a8b4f4e
10 J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
therefore, receiver’s call is added from Launcher activity (dotted line between State 1 and 7). Moreover, the invocation of service aznfeuwcwekw in state 3 is controlled through IF condition which checks the specific value of incoming Intent Extra. EspyDroid+ has successfully rewritten that constraint to make forced invocation of service and able to log all reflection APIs.

# 5. Limitations of EspyDroid+
EspyDroid+ cannot handle hybrid apps that include native code in the app itself not from the Android OS, and JavaScript code. If the ICC links are not statically resolvable by Dialdroid, then component transition analysis would not calculate paths completely. Nonetheless, the success rate, identified links/actual links, of DialDroid is 95% as measured and verified manually on open source apps downloaded from F-Droid Free and Open Source App Repository. DialDroid misses the links to component of fragment Activity type so the transition in state diagram is missed. However, EspyDroid+ adds a direct intent to such missed components. EspyDroid+ instruments the apps for optimization as well for appending non-reflection calls corresponding to reflection calls. Therefore, EspyDroid+ can not analyze the apps which have implemented the mechanism to prevent themselves from being modified or function improperly on being modified. EspyDroid+ will be inefficient in situations where the app contains behavior dependent on specific data inputs which are not removed in RGSS and the desired inputs are not provided by dynamic analysis.

The effectiveness of static reduction depends on whether a large part of the app is irrelevant with respect to the reflection code. However, our approach never prunes a relevant component as it does an over-approximation. We keep all paths towards a relevant component, so if at least, one path leading to target code will be executed, it give at least 1 value of obfuscated parameters of reflection APIs. The over-approximation approach implies that EspyDroid+ never results in loss of information due to slicing with respect to analysis targets.

# 6. Related work
We broadly categorize approaches for reflection analysis of mobile apps in static analysis and dynamic analysis. This section elaborates upon various state-of-the-art solutions under each approach.

# 6. Static analysis
Li et al., proposed DroidRA , which uses string inference for resolving reflection targets in Android apps. DroidRA addresses reflection by solving a constant string propagation problem. However, the approach can resolve class and method names from reflective calls only if these are constants. This limits the approach for targets which are non-constant.

Ripple  further supplemented string inference with type inference for getting reflection targets, which are non-constant and non-null strings but whose variable/object type can be inferred like values read from configuration files or provided from command lines. For a known target method whose receiver object is unknown, it infers the object based on the type of method’s class. However, type inference is limited due to a large number of false positives as many objects/variable may have the same type in a method. This leads to low precision. Second, static analysis based on type inference like Ripple generates many false positives, leading to low precision. Ripple is unable to resolve many reflection targets. The primary reason is attributed to the lack of both string and type information for the reflective targets that are accessed with statically unknown ways like encryption, polymorphism, and reflection. EspyDroid+ prevents false alarms in contrast to Ripple as targets are reported only after actually executing the app. EspyDroid+ has high recall as it can effectively handle obfuscation with the use of dynamic analysis.