The victim app in this case is a popular e-Book Reader of Android with over 20 million downloads. Users can purchase non-free e-books in this app via payment channels of all four cashiers. We take the BadPay for the case. The app use HTTP connections when users browse book lists in the app. When users want to pay for a book then the connection will turn to HTTPS but the app fails to check the HTTPS certificate correctly (allow all certificates described in ). So our proxy can intercept, eavesdrop and tamper the connection. Once a user orders a book and is about to pay, our proxy extracts from the network traffic which book the user want to buy and the order information including price (10 yuan in the case). Then our proxy places a new order request using another app (a take-out food order app) to buy a burger which is also 10 yuan, and get the order information from the MS without paying for the burger in the latter step. Instead, the proxy intercepts the payment order response of the book and substitutes it with the attacker’s burger order. As a result, the MA receives the replaced order response and prompts the user with its payment Activity (UI component of Android apps) of the TP-SDK. Note that information on the payment Activity of BadPay only including price, are exactly the same as the price of the book. User cannot distinguish this replaced order and is cheated to pay for it. Thus after the payment, the burger is paid and delivered to us while the e-book is still kept unpaid. When user paid for the attacker’s order and found their own orders are still unpaid, they just believe it is the delay of the CS that leads to a temporary unpaid status. Imagine that if the take-out food order app here becomes a malicious MA controlled by the attacker, then the attacker can easily generate an order in arbitrary price according to the victim’s order and substitute it. Thus, after user pay for it, the money is directly transferred to the attacker’s account. Even with those TP-SDKs that display the merchant name (WexPay and UniPay), the attacker can still cheat users to pay for attacker’s order in the same app.

Since a thorough fix of this issue is to apply HTTPS to the whole website, it took several weeks for the merchant to release the new version of the app after receiving our report. After that, the vulnerability was eliminated.

# 5. Android app with multiple vulnerabilities
Apps may violate multiple security rules and even patch vulnerabilities incompletely, so a relevant transaction could be vulnerable to not only a single type of attack. To illustrate, we demonstrate how to acquire free movie tickets in different ways by exploiting a movie ticket ordering app with an approximate 10 million users. The vulnerable app allows users to select the cinema, the movie,
and the seats they want, and then buy the movie tickets online via an in-app payment. After the payment, users will get a ticket code and when they get to the cinema, they can enter the ticket-code on an automated ticket machine to get the real movie tickets.

Unfortunately, We detected several security flaws in this app when users pay for tickets via WexPay in the app. The first one is that the app commits Local Ordering mistake and thus exposes the secret key and notify URL. As a result, an attack can hook the order-generation function based on Xposed in the app and tamper the price to a particular value (e.g., one yuan). In addition, with this leaked secret key, an attacker is able to download all bills of each day of the merchant. The bill also contains the details of every transaction in that day, including payer, paying bank, discount, etc. Thus the attacker can know exactly how much people buy movie tickets through WexPay everyday in that app, which obviously should be confidential to any unauthorized visitors. To validate the vulnerability, we conducted a penetrating test to buy a ticket, and paid for it via WexPay with only one yuan (or even cheaper if we wish) and received the available ticket-code, fetched the physical tickets and watched the movie successfully.

After we reported the Local Ordering flaws to the merchant (and they replied that they have fixed the vulnerability in the next version of the app), we tested the new app again. This time we found that the app is still vulnerable to another kind of attack. In detail, an attacker follows all the normal step of a transaction until the app invokes the WexPay’s payment Activity to ask for the payment password to pay for the ticket. Then the attacker terminates the following steps and directly forges a payment notification with the signature signed by the leaked KEY in the previous attack to the merchant server. Surprisingly, our ethical test found that we could still get valid ticket-code, which means the merchant only moved the placing order step from the app to its server, but never renewed the leaked KEY. Even worse, the merchant server still miss the notified payment confirmation as before.

Before informing the merchant and repaying the tickets we have bought this time, we have waited for a certain period (thus the merchant could check the collection of all past orders periodically sent from the cashier) to check whether the merchant verifies it. Disappointingly, until we explained our behavior to the merchant this time, they still had no idea about our two penetrating tests. In the end, we help them fix all these flaws through renewing the secret key, reconfirming the notified payment, and verifying its signature correctly. And we have repaid all fees for tickets bought in our penetrating tests.

# 6. Ethical consideration
We carefully designed our experiments to avoid ethical problem. First, we reported all our findings and the behaviors we performed during the experiments to the related parties and did what we could do to help them improve the systems. Our effort was appreciated by these organizations. In detail, we reported the mistakes in documents/sample codes to WexPay, AliPay and BadPay. All of them have fixed and updated it. For instance, Official documents of AliPay  shows an updated payment process figure. The original figure told the developers to generate and sign the payment order in client app (as we mentioned in Section 5), which is obviously insecure. Both AliPay and WexPay updated their official attentions of developing due to our suggestions . All the three cashiers expressed their gratitude to us. Also we detected flaws (such as missing order signature validation) of several merchant servers described in Section 5 and performed several proof-of-concept attacks described in Section 5. We reported all these flaws and explained our behaviors to these influenced merchants as soon as we carried out our experiments, and helped them to fix these vulnerabilities. Since hundreds of merchants suffer flaws in their apps as we mentioned in Section 5, it would be very difficult for us to inform all of the merchants directly. Hence, we report the vulnerable MA list to the Security Response Center of Tencent, Ant Financial, and Baidu, who are responsible for the security of their payment ecosystems (WexPay, AliPay, and BadPay). They informed all the related merchants of their security risks, revoked leaked KEY and renewed them.

We use Web APIs provided by cashiers as oracles to help finding the leaked KEY in MA, which need to brute-force the parameters of the API and may induce potentially heavy load to cashiers server. We did restrict the frequency and times of invoking the API to avoid potential denied of service attack against the server. After we described our detecting method to cashiers, they confirmed the issue and planned to impose some constraints to invoking the API in future (WexPay even deprecated their download history bill API).

In addition, we ensure no financial damage was inflicted upon the merchants by returning items or re-paying the unpaid orders, etc. The victim user in the Order Substituting Attack (described in Section 5) is actually a colleague of us. We informed him beforehand and later paid for the e-book order for him. We made use of the result of downloaded history bills of merchants to evaluate the feasibility of Unauthorized Query attack, and helped to detect KEY Leakage in MA using WexPay and AliPay. We not only described our detecting method in detail to merchants, but also deleted all these data at once to avoid further exposures.