# 4 LLB ANALYZER
We use the insights from the experiments to put together a python package called “LLB”, which can be invoked to run the pipeline on any target android application. The package is designed to facilitate the scanning of Android projects for security vulnerabilities. It employs a Command Line Interface (CLI) as shown in Figure 3, leveraging the Typer framework to provide an intuitive user experience. This package integrates distinct scanning mechanisms, offering flexibility and comprehensiveness in the vulnerability assessment process.

The core functionality of "llb" is encapsulated in the scan command. This command allows users to specify the target Android application directory for analysis. In alignment with the package’s focus on adaptability, it incorporates multiple scanner options, namely ’GHERA’ and ’VULDROID’, along with an ’all’ option to execute all available scanners. These scanners are tailored to identify different categories of vulnerabilities, ensuring a thorough examination of the target application. The scan command also supports an output directory specification, where the results of the scan are systematically compiled and stored. This feature is critical for maintaining a record of the vulnerabilities identified and serves as a reference for further analysis or remediation efforts. An example of a part of the report generated by LLB is shown in Figure 4.

In addition to its scanning capabilities, "llb" includes the expert command. This command is particularly useful for post-scan analysis, allowing users to append expert comments or insights to the generated reports. This feature underscores the package’s utility in collaborative environments, where multiple stakeholders, including security analysts and developers, might interact with the scan results.

Custom Scan
# CS858, Project Proposal, LLbezpeky
Noble Saji Mathews, Yelizaveta Brus, Yousra Aafer, Meiyappan Nagappan, and Shane McIntosh
# 5 Case study
# 5 Flagged Vulnerability: Deep dive
Let us look at the analysis report for case “WebView NoUser-Permission InformationExposure” in Ghera. In mobile app security, it’s crucial to handle sensitive user data carefully. In this case we have a simple web browser that allows web pages to access the device’s location via a GPSTracker API. The API’s getLatitude() method can be triggered by JavaScript on a webpage to fetch the user’s latitude without asking for the user’s consent each time. This creates a vulnerability: a malicious webpage could use this method to secretly track a user’s location. To mitigate this risk, apps must not only ask for user permission to access sensitive data initially but also maintain strict control over its access during use, particularly when dealing with potentially untrustworthy web content.

@JavascriptInterface
public double getLatitude () {
if ( location != null ) {
return location . getLatitude () ;
} else {
// return dummy value
return 42;
}
}
Listing 1 Information Exposure snippet flagged by LLB as indicated in the Ghera benchmark
In this case LLB correctly identifies the concerning snippet shown in Listing 1. LLB returns the reason as follows: “The application is vulnerable because it exposes sensitive information (GPS location) to the JavaScript code running in the WebView without explicitly asking the user for permission. . . The application does request the ACCESS_FINE_LOCATION permission, but it does not inform the user that their location will be accessible to any malicious JavaScript code running in the WebView.” and also provides a suggested fix to remediate the issue.

# 5 Misclassification: Deep dive
A common trend which we observed among misclassified samples was that they either were flagged for bad patterns in code which might not necessarily be considered vulnerable by an expert in the context we are analysing. Let us look at a case where the LLM was thrown off. The initial classification of the code as "Vulnerable" due to lack of sanitization checks on the file paths seems to be based on a misunderstanding. In the provided snippet, the file name fileNm is hard-coded to "demo.txt", and there’s no indication that it is influenced by external inputs or user-provided data. Therefore, the specific concern of path traversal, where an attacker could manipulate file paths to access unauthorized directories, does not apply here.

String fileNm = " demo . txt ";
// ...

if (i != null && i. getStringExtra (" fileName ") != null && !i. getStringExtra (" fileName "). equals ("")
&& i. getStringExtra (" fileContent ") != null && !i. getStringExtra (" fileContent "). equals ("")
&& i. getStringExtra (" fileName "). equals ( fileNm )) {
fileContent = i. getStringExtra (" fileContent ");
} else {
setResult ( RESULT_CANCELED );
return ;
}
// ...

File file = new File ( dir , fileNm );
try ( FileWriter fileWriter = new FileWriter ( file )) {
fileWriter . append ( fileContent );
} catch ( IOException e) {
Toast . makeText ( getApplicationContext () , " IOError while writing " , Toast . LENGTH_SHORT ). show () ;
setResult ( RESULT_CANCELED );
e. printStackTrace () ;
}
// ...

Listing 2 Misclassified example in Ghera
The common pattern of vulnerabilities associated with file handling operations, especially when they involve input from intents or external sources. When it sees code that interacts with file systems, there may be an overcautious approach to flag potential security risks, such as path traversal. The expert follow-up correctly clarifies that, in this specific case, there is no direct vulnerability present in the snippet due to the fixed file name. Using the expert comment we are able to set the analyzer on the right track even in other cases and give a more relevant suggestion if required.

# 5 Vuldroid
In order to analyze a full application with multiple known vulnerabilities we chose to conduct a case study on Vuldroid. Vuldroid is a vulnerable Android application, which contains only security issues. The app consists of the following vulnerabilities:
- Steal Password MagicLoginLinks (V1). This vulnerability allows a malicious app to intercept password reset tokens or magic login links. This is possible because the app doesn’t properly restrict which activities can handle deep links, allowing an external app to capture these sensitive tokens.

- Webview Xss via Exported Activity (V2). Here, the vulnerability lies in an exported activity that loads web content. Since the activity doesn’t validate the URLs it loads, a malicious app can pass a script (like a JavaScript prompt) through an intent, leading to a cross-site scripting (XSS) attack.

- Webview Xss via DeepLink (V3). Similar to the previous one, this exploit involves XSS attacks but through
# LLbezpeky: Leveraging Large Language Models for Vulnerability Detection
# CS858, Project Proposal, LLbezpeky
deep links. The app fails to validate deep link URLs, allowing the injection of malicious scripts via query parameters in these URLs.

- Stealing Files via Webview (V4). This issue arises because the app’s webview settings allow access to local file URLs (file:///). By crafting a specific URL, an attacker can access and transmit local files to a remote server.

- Stealing Files via Fileprovider (V5). The FileProvider is misconfigured to expose all paths, and combined with an exported activity, it allows other apps to access and steal files.

- Intent Sniffing Between Two Applications (V6). This vulnerability occurs when two apps communicate using intents without proper security checks. A malicious app can intercept these intents and access the transmitted data.

- Reading User Email via Broadcasts (V7). Due to an exported broadcast receiver in the app, a malicious app can trigger this receiver and access the user’s email information.

- Command Execution via Malicious App (V8). This vulnerability allows a malicious app to execute unauthorized commands or operations within the vulnerable app. The details of this exploit weren’t fully described in your summary.

The results of the case study are described in Table 4. The meaning of the symbols:
- C - vulnerability was detected
- W - the provided information wasn’t enough for the LLM to make the decision.

- X - vulnerability wasn’t detected
We note that running LLB on the Vuldroid source code we correctly identify 6 of the 8 seeded vulnerabilities. The 2 which couldn’t be classified were because the analyzer could not find the relevant snippets for analyzing by requesting files. For the remaining 6 cases the correct snippet is identified and a valid fix is also suggested in most cases. Thus the LLB report doesn’t just tag vulnerable applications but actually walks you through the reasoning involved and how to fix the flagged issue.