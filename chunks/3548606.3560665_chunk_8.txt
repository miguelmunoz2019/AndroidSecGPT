• We also found 5 VPN clients use the shadowsocks [ 50 ] protocol to receive free and premium server credentials from a proxy server through an encrypted channel. After decrypting the credentials on the device, it checks whether the user can authenticate and connect to premium or free servers. Since this check occurs at the client side, and ThirdEye can find the corresponding encryption parameters, we obtained connection information and credentials (e.g., server address, password) required to connect to the server.

# To use or not to use non-standard channels and custom encryption
We checked several apps manually to understand their reasons for using non-standard and custom encryption channels. The examples we observed do not clearly justify such channels, at least not in an obvious way (there may be deployment/operation constraints we are not aware of). Notable cases with raw TCP/UDP connections: Forex Event - Platform Trading (com.bonus.welfare) uses a plain TCP channel to receive the latest shares and forex events; Modern Combat 5 (com.gameloft.android.ANMP.GloftM5HM) uses a TCP channel apparently as a game control channel, and sends game server details and the user access tokens as plaintext; and Netspark Real-time filter (con.netspark.mobile), a parental control app, sends real-time device activities (e.g., application-related events) to their server using a plain UDP channel.

The use of custom encryption should be avoided in general; as evident from our results, most app developers fail to use such encryption securely, e.g., about 87% of apps used fixed keys for their symmetric cryptographic operations, where the ciphertext is indeed sent to the network. For specific app issues, we suggest the following fixes. For example, Recipes in Russian (ru.mediafort.povarenok) could use their own public key to encrypt and store the device email on the shared storage; Comico (tw.comico) could do the same to store their user authentication tokens; CamScanner’s RSA-512, and both Dailyhunt and SHAREit’s RSA-1024 keys could be replaced with a stronger one (e.g., RSA-2048); UC Browser could simply use HTTPS (instead of custom encryption over HTTP with a fixed key); for the 5 VPN apps that expose premium account checks at the end client side, these apps should perform the validation at their server-ends; and 22 apps that use custom encryption to share securely-established session tokens, should simply use HTTPS.

In the end, custom encryption is generally not the solution for any of the reasons that we observed—all of which can be easily met by Android’s default crypto support. Besides using HTTPS properly for communication, app developers should rely on Android Keystore for local key management, and Android EncryptedFile and EncryptedSharedPreferences for securely storing local data [ 26 ].

To protect confidentiality of selected private content against third-party content-scanning/distribution services (e.g., allowing CDNs to scan HTTPS traffic), custom encryption may be used, but only under HTTPS (to limit any weakness of custom encryption to the CDNs, instead of any on-path attacker). To avoid the use of custom encryption over non-standard channels, e.g., AES-over-UDP/TCP, developers should instead choose QUIC.

# 8 RELATED WORK
Privacy leakage via covert channels. Side channels allow apps to access protected data/system resources, while with covert channels, an app can share permission protected data with another app that leaks permission-protected information. Reardon et al. [ 43 ] automated the execution of 88,000 apps (at system and network levels), and monitored sensitive data sent over network traffic by apps, and scanned apps that should not have access to the transmitted data, due to lack of permissions. The authors also reverse-engineered the respective components of apps to determine how the data was accessed, and studied the abuse from side and covert channels. Examples from their findings include: 5 apps collect MAC addresses of connected WiFi base stations from ARP cache; an analytic provider (Unity) obtained device MAC address using the ioctl system call (42 apps were found to exploit this); third-party libraries from Baidu and Salmonads, wrote phone’s IMEI to the SD card, and other apps that do not have permission to access the IMEI, can read from the SD card (13 such apps were found). They also found that 153/88,000 (0%) apps used hard-coded encryption keys.

Palfinger et al. [ 37 ] built a framework to identify timing side channels (e.g., via querying installed apps, active accounts, files, browser logins) in Android APIs. The leaked information can be used to fingerprint users, identify user habits or infer user identity. Bakopoulou et al. [ 7 ] intercepted the network traffic from 400 popular apps (with monkeyrunner), and performed manual/automated analysis to understand PII exposures. They found 29 apps exposed the ad ID and location info via UDP; 7 apps exposed Android ID, and another exposed username over plain TCP.

We implement ThirdEye to detect information leaks from non-standard and covert channels not reported in past studies — e.g., malicious apps revealing neighbor’s BSSID, obfuscation using nested encryption/decryption. In addition to HTTP/HTTPS, we also capture traffic from other network protocols above TCP/UDP. We found 2880/2887 (99%) apps send/receive data over custom encrypted channels to/from the network; 414/2880 (14%) of these apps used hard-coded keys on their communications. We also look for more fine-grained privacy-oriented sensitive information — e.g., GPS coordinates with different accuracy, and user credentials.

Obfuscation-resilient privacy leakage detection tools. Mobile apps and ad libraries can leverage various obfuscation techniques (i.e., encoding, encryption, formatting) to hide the leakage of private information of users. Continella et al. [ 10] developed a tool (AGRIGENTO) based on blackbox differential analysis (i.e., using a baseline, and observing the network traffic flow after modifying the sources of private information) for privacy leak detection resilient to underlying obfuscations. AGRIGENTO (implemented on Android 4) captures HTTP/HTTPS traffic using mitmproxy. The authors evaluated AGRIGENTO using the most popular 100 apps.

# Hidden in Plain Sight: Exploring Encrypted Channels in Android Apps
# CCS ’22, November 7–11, 2022, Los Angeles, CA, USA
from Google Play, and identified 46 of them had privacy leaks; with manual inspection, the authors found that 4/46 (8%) of those apps were false positives. AGRIGENTO does not consider non-deterministic sources (e.g., one-time non-reusable keys, authentication tokens), and focuses on privacy leakages only from deterministic sources, i.e., Android ID, contacts, ICCID, IMEI, IMSI, location, MAC address, and phone number. With AGRIGENTO, Continella et al.  also found false positives of specific sources of information leaked in a number of apps — Android ID (5), IMEI (9) MAC address (11), IMSI (13), ICCID (13), location (11), phone number (16), contacts (13). In contrast to AGRIGENTO, ThirdEye uses more comprehensive UI interactions, and relies on deep packet inspection; therefore, it can capture more privacy leaks from both deterministic and non-deterministic sources.

# UI automation frameworks
Past work  has mostly relied on Appium  and monkeyrunner  for Android UI automation. Appium uses app-specific scripts to drive automation relating to interactions with UI elements. Monkeyrunner solely uses random clicks on UI elements for automation. Dynodroid  focuses on processing automatic input. SmartDroid  automatically reveals UI-based trigger conditions of sensitive behaviors of Android apps, but it cannot interact with WebView (commonly used by recent apps). Patel et al.  found that random testing with monkeyrunner is extremely efficient, effective and leads to a higher coverage . In contrast, Wang et al.  argue that monkeyrunner is unsuited for UI automation (for testing specific SSL/TLS vulnerabilities), as its random clicks do not precisely target the specific area on the UI. They leverage AndroidViewClient for UI interactions (e.g., check a radio button, input content to a text box), based on the priority of a UI element; the priority depends on the vulnerabilities in the SSL/TLS implementation. In contrast, we set the priority of UI element interaction in a list of clickable/fillable elements. Our UI interactor is also built on top of AndroidViewClient, which has a better code coverage (e.g., accommodate interacting with UI elements that have non-English labels), not restricted to triggering UI elements associated to vulnerable SSL/TLS implementations, and supports running on multiple devices.

# Root detection evasion
We implement effective evasion mechanisms to bypass various root detection techniques incorporated by some apps. We use rule-based API hooking, and support both Android SDK and NDK based root detection. We surpass the capabilities built into common tools including RootCloak , RootCloak Plus  and xCon , and handle more modern root detection measures; RootCloak only supports up to Android 6 and cannot bypass other tools/libraries like the RootBeer . We support Android 12 and can bypass more complicated techniques, including the latest version of RootBeer, which is used in 178/6075 (2%) apps that trigger encryption/decryption APIs in our test.