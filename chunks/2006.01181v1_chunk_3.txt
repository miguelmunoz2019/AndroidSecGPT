# 5. Custom Scheme Channel
Scheme channels (a.k.a protocol prefixes) like fblite:// for Facebook allow seamless interactions between web and Android apps. Issue: The sender of a scheme message is not able to verify the recipient of the message so that malign apps could register themselves as a receiver of another app’s unified resource identifier (URI) scheme. Consequently, adversaries could collect access tokens or other sensitive information. Symptom: The registration of a URI scheme within the intent-filter in manifest file. The SchemeRegistry.register method is in the code. Mitigation: Adopt the dedicated system scheme i.e., Intent which is harder to compromise.

# D. Sensitive Data Exposure
# 1. Header Attachment
The header section of data transport protocols like HTTP comprises key/value pairs to store operational parameters. Issue: Developers may rely on headers to transfer sensitive data, e.g., they store credentials to auto-login into a service. Consequently, any adversary eavesdropping on the network may easily access the attached data. Symptom: Calls like HttpGet.addHeader() are present in the code to store private data. Mitigation: Do not store sensitive data in headers, instead rely on dedicated mechanisms like OAuth2 protocol to authenticate to third-party services.

# 2. Unique Hardware Identifier
Each device often has a couple of globally unique identifiers such as the IMEI number, MAC address, etc. Issue: For various purposes like user profiling, apps utilize these IDs, which are tied to each device. Consequently, anyone in the possession of such IDs would be able to track the user’s activities across various sources. Symptom: Method calls that return IDs from associated classes like TelephonyManager or BluetoothAdapter exist in the code. Mitigation: Use the UUID.randomUUID() API to ensure that the retrieved ID is globally unique for each user, but only within the same app identity.

# 3. Exposed Clipboard
Users usually rely on a clipboard to copy and paste data across apps. Issue: The clipboard content is readable and writable by all apps. Consequently, a malign app could perform versatile attacks on the clipboard content from URL hijacking to data exfiltration and code injection. Symptom: The related calls on ClipboardManager exist in the code. The app uses the common TextView.

# Exposed Persistent Data
Android provides various storage options to store persistent data. These options vary depending on the size, type, and accessibility of data Issue: Developers may opt for a particular option without considering its security implication. Consequently, they expose private data. Symptom: The existence of a private storage with global access scope (i.e., MODE_WORLD_READABLE or MODE_WORLD_WRITEABLE) in the app. The app relies on ContentProvider to access data, but there is no access restriction for other apps. Mitigation: Specify permissions to protect who can access your shared data. Encrypt any (internally or esp. externally) stored sensitive data, and place the encryption key in KeyStore, protected with a user password that is not stored on the device.

# Insecure Network Protocol
Data transportation channels exist in various flavours, and insecure ones like HTTP are more prevalent and easy to maintain. Issue: Insecure channels transfer data without encryption per se. Consequently, an attacker can secretly relay the data and possibly alter it Symptom: APIs related to opening insecure network connections like http or ftp exist in the code. Mitigation: All app traffic should happen over a secure channel. Otherwise, any sensitive data should be encrypted before it is sent out. Android 6 or above provides the cleartextTrafficPermitted property which protects app from any usage of cleartext traffic.

# Exposed Credentials
Passwords, private keys, secret keys, certificates, and other similar credentials are commonly used for authentication, communication, or data encryption. Issue: In some circumstances such data is inadvertently disclosed to unauthorised parties. Consequently, this could break the intended security. Symptom: The app contains hard-coded credentials, or they are stored without any password protection such as when the KeyStore.ProtectionParameter is null. Mitigation: Store such data in a KeyStore in a protected format which restricts unauthorised accesses.

# Data Residue
According to recent research, about 80% of abandoned apps are likely to be uninstalled in less than a week Issue: After an app is uninstalled, various types of data associated to the app, ranging from its permissions, operation history, configuration choices, and so on may still remain in a few system services Consequently, such so-called “data residue” can be associated to another app and empower adversaries to access sensitive information Symptom: The app calls system services that are known to be subject to data residue problem. Mitigation: Unfortunately, an app may not always be aware of its data being stored in system services, and the mere mitigation is to avoid sharing private data with these services, if possible.

# Lax Input Validation
# XSS-like Code Injection
WebView is an essential component that enables developers to use web technologies such as HTML and JavaScript to deliver web content within an app. Unlike Web browsers like Chrome, FireFox, etc. which are developed by well-recognized companies that we trust, each app using a WebView is like a customized browser which may not have undergone thorough security tests. Issue: An app may load web content unsafely i.e., without sanitising the input from any code. Consequently, an adversary could inject malicious code through any channel that the app uses to get web content Symptom: The setJavaScriptEnabled call with value true which enables execution of JavaScript exists in the code, and the app fetches web content from untrustworthy sources (e.g., by calling loadUrl or loadData on WebView) without applying proper sanity checks. Mitigation: Invoke the default browser to display untrusted data. Use a HTML sanitizer to filter out any code inside the data, and show plain text only using safe APIs that are immune to code injection (i.e., do not execute JavaScript code). Beware of third-party libraries that employ WebView. Disable JavaScript, if you do not need it.

# Broken WebView’s Sandbox
There is a sandbox inside WebView that separates its JavaScript from the rest of system. Issue: WebView provides an API, addJavascriptInterface, through which an app can access Java APIs, and therefore mobile resources, from within JavaScript code inside the sandbox. Consequently, if the app renders the web content unsafely, a code injection attack is possible Symptom: In addition to the symptoms of the previous issue, the addJavascriptInterface call exists in the code. Mitigation: Take into account the suggestions of the previous issue, and as well use the @JavascriptInterface annotation to specify any method that is exposed by JavaScript to prevent reflection-based attacks.

# Dynamic Code Loading
Android allows apps to load and execute external code and resources. Issue: Although dynamic code loading is widely adopted, developers are often unaware of the risks associated to this generally unsafe mechanism or fail to implement it securely An attacker can replace the code that is to be loaded with a malicious one. Consequently, this can lead to severe vulnerabilities such as remote code injection Symptom: Use of
# III. EMPIRICAL STUDY
We developed a lightweight analysis tool that statically detects known security smells in an app. We rely on the Apktool to reverse engineer Android apk files and generate smali code. We defined a set of rules to capture the symptoms of each security smell. In particular, we utilize Java XML Parser for parsing the Manifest files and use regular expressions to define and match the code pattern corresponding to the identified symptoms of each smell in the code.

We randomly selected our apps from the AndroZoo dataset. This dataset currently provides more than 5M apps collected from several sources. We initially collected a random subset of 70 000 apps whose sources are in Google Play. However, to collect more meta data information such as an app’s category, its number of downloads, update cycle, and star rating we still needed to visit the Google Play website. Unfortunately, we could not access 25 000 apps for various reasons, for example, because they were no longer available on the store, or they were not accessible from Switzerland. In the end, we included 46 000 benign apps in our dataset. About 90% of these apps were released between 2014 and 2016, a quarter of them were updated within three months, the majority were rated more than four stars, slightly more than 27% were downloaded above 50 000 times, and the median apk size was 5MB.

# A. Result
We applied our lightweight tool to all apps in the dataset. Figure 1 shows how prevalent the smells are in our dataset. A majority of apps potentially suffer from XSS-like code injection (85%) followed by dynamic code loading (61%).

We conjecture this issue should have decreased also in other markets without this constraint as recent build platforms automatically disable the debug mode in the signed release version. In contrast, there is an increase in the existence of the Exposed Clipboard security smell. This could stem from the many sharing options for social media in the apps. Similarly, the issue of Dynamic Code Loading has been noted.