# 5 Manifest Constraint Extraction
(I) Extraction Result. We first present how ManiScope performs when provided with the Android documentation. Since it is a fully automated system, it can parse all Android documentation including the historical ones. As such, we tested ManiScope with 20 different Android documentation from Android developers website from the most recent one (after 7) to the oldest available one, namely Android 1, and this result is reported in Table 2. Note that the source code of the historical documentation after 7 is no longer published on public Google repositories, and we obtain the most recent one by directly fetching the online HTML files. In particular, as illustrated in the first row for the most recent documentation, ManiScope collected 26 documentation files related to manifest declaration, and identified in total 348 sections containing 849 paragraphs. When printing them in a format preserved manner (they are organized in a structure), we obtained 190 pages. Among the paragraphs parsed, ManiScope found that 1,326 sentences are written in normal voice and 256 are written in passive voice. Additionally, there are 404 phrases that do not have nominal subjects, either in normal voice or passive voice, which are identified as simple phrases rather than complete sentences. Our Constraint Filter filtered over 90% of non-manifest related constraints through context-filtering rules, and the word filter rules filtered out additional 1% of non-manifest constraints, and eventually it obtained 254 manifest constraints for 28 elements and 125 attributes.

(II) The Evolution of Manifest Documentations. Being able to analyze the historical manifest documentation, we can draw insights such as how they evolved. As such, we quantified such evolution by presenting the difference between two adjacent version of manifest documentations, as shown in Figure 7. First, we observe that the total sentences of manifest constraints, although added or removed, are constantly growing, where the growth rate can range from 0% to over 50%. Second, we notice that during updates, sentences may often be removed with new sentences added, be those removal of deprecated elements or attributes or changes made to descriptions. Interestingly, we also observe that fixing for some typos that eventually caused confusion among developers resulted in some of the misconfigurations, which will be introduced in the correctness evaluation of documentation later.

(III) False Positives (FPs) and False Negatives (FNs) Analysis of Extracted Constraints. The accuracy of the extracted constraints directly determines the accuracy of our misconfiguration detection. Therefore, we must first make sure there is no false positive or false negative. If so, we must correct them. To validate the accuracy of our constraint extraction, we chose the most recent documentation and manually constructed the schema by going over all the documentations. In total, there are 190 pages with 849 paragraphs. To generate the ground truth, we have two security researchers each read the documentations, manually extracted the constraints, wrote the manifest schemas; then the two researchers cross-validated their results to converge. It took 20 days for both researchers to read the documentation, pick out manifest-related documentations, understand contexts, construct schema, and validate them. Then, we compared the manually constructed ground-truth schemas with the automatically generated ones. Among them, we found no false positives but 3 false negatives in constraint generation out of 257 (1%) total schema constraints generated manually. The reason is that the documentation of compatible-screen did.

# Detecting and Measuring Misconfigured Manifests in Android Apps
# CCS ’22, November 7–11, 2022, Los Angeles, CA, USA
# Google Play apps
# Pre-installed apps
# Manifest Misconfiguration Detection
# (I) Detection Result.

With the XML schemas reconstructed by ManiScope, we then use them to detect the misconfigurations in most recent apps in Google Play and preinstalled apps in historical firmware, whose overall results are presented in Table 3. Note that the subtotal of apps may not always be equal to the subtotal of misconfigurations as a single app may contain multiple misconfigurations. For Google Play apps, we identified 812,763 misplaced configurations, 5,379 missing configurations, and 165,093 misspelled configurations. For pre-installed apps, we found 301,654 misplaced configurations, 1,730,628 missing configurations, and 85,515 misspelled configurations. We found that manifest misconfigurations are quite prevalent in real-world apps where more than 30% of these apps have at least one misconfiguration.

# Misplaced Configuration.

Most of the misconfigurations among manifest files are misplaced configurations, and ManiScope identified 261,089 misplaced elements and 551,674 misplaced attributes among the 1 million Google Play apps, and 814 misplaced elements and 300,840 misplaced attributes among the 0 million pre-installed apps, as shown in Table 3. We also found that most of the misplaced attributes were related to feature requirements (e.g., android:hardwareAcclerated, android:required), and most of the misplaced elements were frequently used manifest elements (e.g., &lt;meta-data&gt;, &lt;category&gt;), and elements used to configure access permissions (e.g., &lt;permission&gt;, &lt;uses-permission&gt;). Additionally, we observed misconfigurations in extremely popular apps related to icons and themes (e.g., the YouTube app contained a misplaced android:theme attribute), although they are likely to be of no security concern.

# Missing Configuration.

For Google Play apps, missing configurations occur in both elements and attribute. For missing elements, all the 3,900 misconfigurations are related to &lt;action&gt; element in &lt;intent-filter&gt; element. The missing attributes, on the other hand, mainly involved in component name attributes (e.g., android:name) and compatibility attributes (e.g., android:minSdk Version). One possible explanation is that the compiler already examines some critical missing problems and aborts compilation if these misconfigurations exist. However, missing configurations are still concerning since they can result in unavailability of app components and create compatibility issues. For example, if the android:minSdkVersion attribute in the &lt;uses-sdk&gt; element is missing, the system regards the app as compatible with all Android versions, which can cause the app to crash.

For pre-installed apps, although ManiScope did not find any missing attributes, we still identified a large amount of missing &lt;action&gt; (1,673,727 of 1,730,628) and &lt;application&gt; (56,901 of 1,730,628). This could be explained by the difference between pre-installed apps and Google Play apps. For instance, compared with Google Play apps that rely on Intents to perform functionality, most of the pre-installed apps do not need to specify actions for intent-filter, and therefore many &lt;action&gt; elements are not present in &lt;intent-filter&gt; element.

# Misspelled Configuration.

ManiScope detected a large number of misspelled elements and attributes. Among them, we found that there are many more typos than capitalization errors (such as).

# CCS ’22, November 7–11, 2022, Los Angeles, CA, USA
# Yuqing Yang et al.

AV: Attack Vector, AC: Access Complexity, C: Confidentiality Impact, I: Integrity Impact, A: Availability Impact, G: Google play app, P: pre-installed app. : None, : Low, : High.

∗: For all entries, Privileges Required (PR) is None, User Interaction (UI) is None, and Scope (S) is Unchanged. †: The total downloads of all apps in this category.

Service v.s. service) in misspelled elements. Also, most of the capitalization errors of elements (30 of 39) have the first character capitalized (e.g., Activity). All the 9 capitalization errors in pre-installed apps are the first-character-capitalization problem of <service> (i.e., Service). For typos of elements, most are due to spelling errors (e.g., mata-data v.s. meta-data, which accounts for 5,585 misconfigurations among the 6,446 misconfigurations). Another source of typos comes from a missing hyphen (e.g., intentfilter v.s. intent-filter), and incorrect usage of plural/singular form (e.g., support-screen v.s. support-screens). For pre-installed apps, 472 out of 486 misconfigurations are typo from intent-filter to intent-flter, whereas the rest 14 are plural problems, i.e., permission spelled into permissions. For the top misspelled attributes, we found that missing prefixes are most prevalent (e.g., exported v.s. android:exported).

# (II) FP and FN Analysis of the Detected Misconfigurations
To confirm whether there are any FPs and FNs in the identified misconfigurations, we manually checked random samples of 500 misconfigurations identified by ManiScope from pre-installed and Google Play apps, respectively. Among these 1,000 misconfigurations, we identified zero FNs but 27 FPs (2%). For the false positives, we found that the root cause is due to the typos in the official documentations, which involve two attributes: (1) 5 out of 27 FPs involve android:allowBackup, which was misspelled into android:allowbackup from 4 to 4. As such, ManiScope may only regard android:allowbackup as correct name for a certain version. If a manifest file contains android:allowBackup in application element, which is actually correct, ManiScope identifies it as misspelled instead, resulting in a FP. (2) 22 out of 27 FPs involve resizeableActivity, where the android: prefix is missing from the documentation. As such, ManiScope will identify the correct attribute with prefix as misspelled, resulting in a FP. Interestingly, although the typo of allowBackup is fixed after 4 (but still causing FPs when ManiScope analyzes apps for these versions), the typo of resizeableActivity remained until our responsible disclosure as in July 2021.