# GAO et al.: UNDERSTANDING THE EVOLUTION OF ANDROID APP VULNERABILITIES
# 5
shell, are executed using the Runtime API. Such vulnerabilities can appear in unsuspected scenarios: in a recent study, Thomas et al.  discussed a case where a remote attacker could use a WebView executing dynamic HTML content driven by JavaScript to reflectively call the Java Runtime.exec() method for executing underlying sensitive Shell commands such as “id” or even “rm.”
# c) Permission:
The Android application sandbox security feature isolates each app data and code execution from other apps. However, the documentation explicitly recommends to avoid permissions MODE_WORLD_READABLE and MODE_WORLD_WRITEABLE for interprocess communication files (i.e., sharing data between applications using files), since, in this mode, Android cannot limit the access only to the desired apps . Nevertheless, the secure alternative of implementing content provider may be too demanding for developers, leading to the development of many vulnerable apps.

# d) WebView:
The example vulnerability described for the Command case reflects a more generalized security issue with WebView’s capability to render dynamic content based on JavaScript. Until Android Jelly Bean, i.e., API level 17 (included), JavaScript code reflectively access public fields of app objects. This is problematic since an attacker may leverage this security hole to remotely manipulate the host app into running arbitrary Java code. Luo et al.  described this kind of attacks in detail.

# e) KeyStore:
Android relies on the KeyStore API to manage highly sensitive information such as cryptographic keys for banking apps, certificates for virtual private networks, or even pattern sequences or PINs used to unlock devices. Unfortunately, a recent study has confirmed that developers may not use the API very well, opening doors to attacks . In any case, some developers continue to directly hard code certificate information in their app. Others who use the KeyStore end up exposing the so-far secured information by saving the keystore object into an unprotected file, or by loading it into as an ordinary byte array that can then be obtained by attackers.

# f) Fragment:
A specific case of code injection can be implemented in apps running earlier versions of the Android operating system (OS): fragment injection, reported by researchers at IBM , exploits the fact that any user interface (UI) class (i.e., Activity extending PreferenceActivity) can load any other arbitrary class in a Fragment (i.e., Subactivity). When the UI class is exported (i.e., can be reused by other apps—for example, a mail app may directly allow viewing a PDF attachment by calling a reader app activity), malicious apps can break the sandbox mechanism by accessing information pertaining to the vulnerable apps or abuse its permissions. R. Hay has demonstrated6 how this vulnerability could be exploited to attack the Android Settings app to enable an unauthorized and effortless change of device password. Fortunately, this vulnerability was patched starting with Android Kit Kat (API level 19), where all apps including the concerned activities must implement a specific behavior for properly checking the code to be run via the isValidFragment() API.

6 [Online]. Available: https://goo.gl/zQnpTq —Retrieved August 17, 2017.

# g) Encryption:
It is a standard practice to encrypt sensitive information when they are hard-coded within app code. Unfortunately, developers often confuse encryption with simple encoding: in both cases, the string may appear unreadable (e.g., in base 64 representation); however, simply encoded strings can be decoded by anyone using the standard API without the need of a key. Listing 4 illustrates an example of vulnerable code. In line 4, where base 64 encoded information is hardcoded in the program, which the developer believes it is safe as it is decoded on-the-fly at runtime, is actually accessible to any attacker.

# Listing 4. Vulnerable encryption using Base64 string encoding.

The next two vulnerability cases that we consider are related to the pervasive use of intercomponent communication (ICC) for enabling interaction and information exchange between Android app components (within and across apps). Two Android concepts are key in these scenarios: the intent object, which is created by a component to hold the data and action request that must be transferred to another component, and the intentfilter attribute, which specifies the kind of intents that the declaring component can handle. When intents are implicit, i.e., they do not name a recipient component, they are routed by the system to the appropriate components with matching intent filters. Security of intents can then be compromised by malicious apps that may exploit vulnerabilities to intercept intents intended for another, or by sending malformed data to induce undesired behavior in a vulnerable app. These attacks, known as intent interception and intent spoofing attacks, have been studied in detail in the literature , , , , and.

# h) Intent:
Implicit intents, although they provide flexibility in run-time binding of components, are often reported to be overused or inappropriately used . For example, attackers may simply prepare malicious apps with intents matching the actions requested (e.g., PDF reader capability) by vulnerable apps, to divert the data as well as prevent other legitimate components to be launched. In our article, following security recommendations in , we consider an app to be vulnerable w.r.t. to Intent when it uses implicit intents to communicate with its own components: the developer should have used explicit intent, thus avoiding potential interception by unexpected parties.

# i) IntentFilter:
Android apps may declare their capabilities via intent filters. However, when faced with an incoming intent, a component cannot systematically identify which component (trusted or untrusted) sent it. In that case, a vulnerable app may actually be implementing a redelegation  of permissions to perform sensitive tasks. Best security practices require app developers to protect the offered capabilities with the relevant.

This article has been accepted for inclusion in a future issue of this journal. Content is final as presented, with the exception of pagination.

# 6
# IEEE TRANSACTIONS ON RELIABILITY
(or some ad-hoc) permissions; thus, the attacker would need the user to grant permission for accessing the sensitive resources he was attempting to abuse. We otherwise consider the app to be vulnerable.

j) Leak: Sensitive data flows across app components and outside an app have been extensively studied in the literature , , –. When such flows depart from known sensitive sources (e.g., API methods for obtaining user private data) and end up in known unsafe sinks (e.g., methods allowing to transfer data out of the device by logging, HTTP transferring, etc.), these are privacy leakages. When such data flow paths are found in an app, a vulnerability alert should be raised.

# C. Reconstruction of App Lineages
We now describe the process (illustrated in Fig. 3) that we followed to reconstruct app lineages from AndroZoo’s data heap. To reconstruct app lineages, we need first conservatively identify unique apps, and then, link and order their app versions (i.e., apks) into a set of lineages. The objective is to maximize precision (i.e., a lineage will only contain apks that are actually different versions of the same app) even if recall may be penalized (i.e., not all apk versions might be included in a lineage). Indeed, missing a few versions will not threaten the validity of our study as much as linking together unrelated apps. Hence, we implement the following four steps.

1. Application ID Extraction: Google recommends  that each app should be named, in the usual Java package naming convention. This avoids the collision in app names, which the market must avoid since two different apps with the same name cannot be installed on the same device. App name is indicated uniquely in the Manifest file with the attribute applicationId. We group together apks with the same application ID as candidate versions of a given app.

2. App Grouping by Certificate: Since Android apps are prone to repackaging attacks , , different apks in a group sharing the same app name may actually be different branches by different “developers.” We do not consider in our study that repackaged apps should appear in a lineage since the changes that are brought afterward may not reflect the natural evolution of the app. Thus, we group apks in each group based on developer signatures. Meanwhile, during the implementation of this step, we also noticed that most of the markets, even for Google Play (the official market), do not emphasize a unique certificate (i.e., only one certificate for each app). For these cases, we found that there are around 0% apks, which include more than one certificates. Since, for these apks, we cannot uniquely distinguish their ownership, we dropped them in the final dataset.