# Session 4A: Mobile Security
# Towards Understanding Android System Vulnerabilities: Techniques and Insights
Daoyuan Wu∗
Singapore Management University
dywu@smu.edu.sg
Debin Gao
Singapore Management University
dbgao@smu.edu.sg
Eric K. T. Cheng
The Hong Kong Polytechnic University
kam-to.cheng@connect.polyu.hk
Yichen Cao
SOBUG, ShenZhen, China
caoyichen@sobug.com
Jintao Jiang
SOBUG, ShenZhen, China
jiangjintao@sobug.com
Robert H. Deng
Singapore Management University
robertdeng@smu.edu.sg
# ABSTRACT
As a common platform for pervasive devices, Android has been targeted by numerous attacks that exploit vulnerabilities in its apps and the operating system. Compared to app vulnerabilities, system-level vulnerabilities in Android, however, were much less explored in the literature. In this paper, we perform the first systematic study of Android system vulnerabilities by comprehensively analyzing all 2,179 vulnerabilities on the Android Security Bulletin program over about three years since its initiation in August 2015. To this end, we propose an automatic analysis framework, upon a hierarchical database structure, to crawl, parse, clean, and analyze vulnerability reports and their publicly available patches. This framework includes (i) a lightweight technique to pinpoint the affected modules of given vulnerabilities; (ii) a robust method to study the complexity of patch code; and most importantly, (iii) a similarity-based algorithm to cluster patch code patterns. Our clustering algorithm first extracts patch code’s essential changes that not only concisely reflect syntactic changes but also keep important semantics, and then leverages affinity propagation to automatically generate clusters based on their pairwise similarity. It allows us to obtain 16 vulnerability patterns, including six new ones not known in the literature, and we further analyze their characteristics via case studies. Besides identifying these useful patterns, we also find that 92% Android vulnerabilities are located in the low-level modules (mostly in native libraries and the kernel), whereas the framework layer causes only 5% vulnerabilities, and that half of the vulnerabilities can be fixed in fewer than 10 lines of code each, with 110 out of 1,158 cases requiring only one single line of code change. We further discuss the implications of all these results. Overall, we provide a clear overview and new insights about Android system vulnerabilities.

∗The idea was proposed by this author, and partial of his work was performed while at SOBUG (https://sobug.com/) during a research internship as a vulnerability analyst.

Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org.

AsiaCCS ’19, July 9–12, 2019, Auckland, New Zealand © 2019 Association for Computing Machinery. ACM ISBN 978-1-4503-6752-3/19/07. . . $15 https://doi.org/10/3321705
# 1 INTRODUCTION
Android has become the most popular system for pervasive devices over years, with a global market share of smartphones at over 80% . As more and more attacks are targeting at Android by exploiting vulnerabilities in its apps and the system , detecting and analyzing Android vulnerabilities has been an emerging topic in Android security research. Compared to app vulnerabilities that have been extensively studied (e.g., [22, 24, 25, 27, 30, 34, 42, 48, 54, 58, 66–69, 72, 79, 80]), system-level vulnerabilities in Android, however, were much less explored in the literature (mainly about framework-layer vulnerabilities, e.g., ). This could be due to the difficulty of understanding low-level system vulnerabilities and the lack of analysis resources.

The recent arise of bug bounty programs gives researchers a new source to systematically analyzing vulnerabilities. For example, Finifter et al.  performed the first empirical study of vulnerability rewards programs (VRP) using the Chrome and Firefox VRPs, and Zhao et al.  measured the vulnerability reports submitted by white-hats on the Hackerone and Wooyun vulnerability platforms. Android also has its own bug bounty program called the Android Security Bulletin program. A recent study  utilized the Bulletin resource to analyze Android system vulnerabilities; however, it relied on significant manual effort to measure 660 vulnerabilities only for metadata and statistical results. Moreover, only text information from corresponding CVE (Common Vulnerabilities and Exposures) reports was analyzed, while the patch was left not mined.

In this paper, we aim to fill the current gap in understanding Android system vulnerabilities by performing the first systematic study that covers all 2,179 vulnerabilities and their 1,349 publicly available patches on the Android Security Bulletin program from
# Session 4A: Mobile Security
its initiation in August 2015 to our analysis launched in June 2018.

To make such scale a study and to easily adapt to larger datasets in the future, it is critical to adopt a systematic methodology with manual efforts involved only for configuring the analysis and interpreting the results. Fortunately, with structured Bulletin reports, we are able to propose such an automatic analysis framework that can crawl, parse, clean, and analyze vulnerability reports and their patches. Specifically, it builds upon a hierarchical database to store all the text and code information of each Android vulnerability in an organized and searchable structure, and the major novelty lies in its three analyzers for the analysis of vulnerable modules, patch code complexity, and vulnerability patterns. In particular, how to automatically cluster vulnerability patterns from a number of initially irrelevant code fragments (i.e., contiguous lines of code ) is the key challenge. We now elaborate these three analyzers and the corresponding analysis results.

# 1. Vulnerability Analysis
In the first analyzer, we classify vulnerabilities by different Android modules to shed light on the system modules that are most susceptible and thus require more security attention. Unlike the prior work  that employs manual analysis, we propose a lightweight technique that leverages two useful features of Android Bulletin reports (see §3 for details) to effectively pinpoint the affected modules of given vulnerabilities. With this analyzer, we successfully obtain the layered map of vulnerable Android modules, and find that 92% of the Android vulnerabilities are located in low-level modules that are mainly coded in C/C++, especially native libraries and kernel drivers. In contrast, the framework and application layers contribute to only 5% and 2% vulnerabilities, respectively. Moreover, the media, Wi-Fi, and telephony related modules introduce hundreds of vulnerabilities across different layers, making them highly risky. We also perform more in-depth study on code with a large number of vulnerabilities, e.g., MPEG4Extractor.cpp in the libstagefright media library that appeared in 26 distinct patches.

# 2. Patch Code Complexity
Secondly, we present a robust method to study the complexity of patch code, in which we extract the “real” patch diff code by excluding not only the auxiliary code lines (e.g., the include/import and the comment statements) but also the test code that is associated with patches. We analyze the complexity of diff code extracted at both the file and the code line granularity. Results show that a significant portion of the Android vulnerabilities involve non-complex fixes, with 60% requiring only one file change and with 50% fixable in fewer than 10 lines of code. This indicates that many Android vulnerabilities are likely implementation bugs.

# 3. Similarity-Based Algorithm
Lastly, we propose a similarity-based algorithm to automatically cluster Android patch code patterns, and reveal system developers’ common coding mistakes that lead to vulnerabilities. Note that this task is different from the classic code clone detection problem [17, 39, 40, 43, 44, 49 – 51, 71] because our goal of clustering similar patches is about finding similar “changes” that involve four pieces of code per pair of patches, whereas code clone detection focuses only on two pieces of “original” code per comparison. Hence, we design a new algorithm specifically for similar patch clustering. We first extract diff code fragments’ essential changes and express each such change into one code text. We then generate a similarity matrix by calculating these code texts’ pairwise similarity, and further leverage affinity propagation  to automatically generate clusters according to the matrix. Finally, patterns are abstracted from top similar cases within clusters.

By running this algorithm, we obtain 83 initial clusters of which we quickly filter out 50 small-size ones as they contain only fewer than 10 code fragments each and actually do not exhibit evident security-oriented patterns. Out of the remaining 33 clusters, 28 (84%) are associated with certain patterns, with 19 clusters for security-oriented patterns and 9 clusters for non-security-related patterns. We eventually extract 16 vulnerability patterns from 19 security-oriented clusters. They include not only traditional patterns, e.g., overflow and uninitialized data, but also six new ones not known in the literature, such as mis-retrieving Android service by reference and inconsistent Android Parcelable serialization. We then analyze their characteristics by performing case studies.