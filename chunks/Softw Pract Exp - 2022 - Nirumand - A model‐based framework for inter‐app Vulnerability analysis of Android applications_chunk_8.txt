# Unauthorized Intent Receipt attack Type (communication (c1, c2)) ≡
c2 ∈ TargetComps ∧ c1.app ∈ BApps ∧ c2.app ∈ MApps ∧ c1.app ≠ c2.app ∧ (I.Permission = ø ∨ I.P ∈ NormalPermissions)
where attackType =
- Activity hijacking, if c2.Type = Activity
- Service hijacking, if c2.Type = Service
- Broadcast theft, if c2.Type = Broadcast
An automated process is performed during this phase which includes three steps: measuring potential communications in the Android system, identifying communications that have the potential to cause a security threat, and finally presenting the results to the user using XMI models. The model-driven chain at this phase includes a set of M2M transformations written in ATL transformation language and OCL queries. Due to lack of space in this paper, the details of these transformations are described in a technical report.

To better illustrate the phases of the proposed approach, consider the motivation example of Section 4. In the following, the results obtained in each phase are described. As discussed earlier, in the Model Discovery phase, for each app, the initial models (i.e., the XML model and the Java model) are obtained through MoDisco discoverers. These initial models generated for each app are shown in Figures 9 and 10. The Model Browser of MoDisco is used to display these models. As shown in Figures 9 and 10, in the left panel of the displayed models, the possible element types are specified (i.e., concepts related to the concerned metamodels), while in the right panel of the displayed models, the model elements themselves are shown. In the transformation and integration phase, first, for each app, the security information of initial models is extracted and gathered into a single security model called Android application security aspects. These models generated for each app are shown in Figure 11. As can be seen, these models represent the main specification and security structure of Android apps, including information about the app components. Then, by collecting these models, all potential ICCs.

Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License.

# NIRUMAND et al.

# AndroidManifest_Xmlxmi
# F I G U R E 9
The XML models of the described apps in Section 4. (A) Benign; (B) Malicious
# Benign javaxmi
# F I G U R E 10
The Java models of the described apps in Section 4. (A) Benign; (B) Malicious
Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License.

# NIRUMAND et al.

# Perign_ArdioidApplicaricnsecurityAspectsMocelxri
# Malicious_Android-pplicationsecurityA spects Modelxmi
F I G U R E 11 The Android application security aspects models of the described apps in Section 4. (A) Benign; (B) Malicious
(at intra- and inter-app levels) are extracted and integrated into a single model called ICC, which is shown in Figure 12. Since the intent sent by Malicious has the only action, the Action test is executed for it (line 18 in Algorithm 2). Therefore, all Broadcast Receivers are identified (shown in Figure 12) that can receive and handle this intent. Finally, in the Analysis phase, by performing formal analysis operations, the ICC vulnerability is identified. As depicted in Figure 13, the communication between MalActivity in Malicious and emailBroadcastRecv in Benign has a kind of Intent Spoofing vulnerability called Broadcast Injection.

# 5 Incremental ICC analysis feature
In general, there are three types of ICC analysis approaches. First, a pure program analysis approach, such as IccTA, considers the entire system as a large program to perform the ICC analysis. Second, a hybrid yet nonincremental approach, such as COVERT, divides the ICC analysis into two tasks: identifying security specification from each app and then examining the vulnerabilities of these specifications. Since these two approaches lack an appropriate way to consider the Android system changes, the ICC analysis must be repeated from the beginning for each app. In unstable environments, such as Android that apps are constantly added, removed, or updated, these approaches are often considered unscalable and impractical. Therefore, a third approach, incremental ICC analysis, such as FLAIR, is proposed to use the results of the previous system analysis to optimize subsequent analysis and automatically update ICC analysis to respond to the system changes. In this paper, to further improve the performance and scalability of the proposed approach, the incremental ICC feature is considered. In the next section, details of the implementation of this feature are described.

# 5 Tool support
To demonstrate the ability of the proposed approach to detect inter-app vulnerabilities, it is developed as an Eclipse-based tool called VAnDroid2. Figure 14 shows the architecture of the tool implementation. Each phase of the proposed approach is implemented as a separate component so that each component provides the required input models for another component. The implementation of the metamodels (discussed in Sections 5 and 5) is based on the Eclipse Modeling Framework.

Any change to an Android system (i.e., deletion apps or addition apps) is considered in this tool to support the incremental ICC feature. To better illustrate this implementation, consider the app addition. When an Android app is added to
# 6 EMPIRICAL EVALUATION
To evaluate the ability of VAnDroid2 to detect inter-app vulnerabilities in real-world apps, VAnDroid2 has been applied to 10 bundles of real-world Android apps. To create these bundles, first, we constructed a dataset of benign, malicious, and
# ICCModel xmi
[Umplicitlntent] inten:
eContainer
SendComponentName MalActivity
Name Intent
Action eduksucs acticn EMAIL
Permission =
Data iue
MethodForSend sendBroadcast
ImplicitCommunication
target_components (1)IImplicitTargetComponent] emailBroadcastRecv
# IntentSpoofingModelxmi
# Properties
F I G U R E 12 Intercomponent communication model of the described bundle in Section 4
F I G U R E 13 Evaluation model of the described bundle in Section 4
1097024x, 2023, 4, Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [09/08/2024]. See the Terms and Conditions https://onlinelibrary.wiley.com/terms-and-conditions on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
# NIRUMAND et al.

# Initial Models Extractor Results
EMF EMF XMI Models
Android Application Security Aspects Models Results Extractor
Eclipse Modeling Framework Madel Results
# Inter-Component Communication (ICC) Model Extractor
Inter-App Security Analyzer
Intcnt Spoofing Unauthorized Intent Analysis Receipt Analysis
Component diagram of the implementation vulnerable Android apps. Then, 10 app bundles, each containing 35 apps, have been randomly selected from our dataset.

# Research Questions
- RQ1 (Correctness): How reliable are the analysis results of VAnDroid2?
- RQ2 (Scalability): Is VAnDroid2 capable of performing the inter-app analysis to identify vulnerabilities in real-world Android apps?
- RQ3 (Run-time performance): Is VAnDroid2 practical in terms of execution performance?
Our experiments ran on a 3 GHz, Core i7 computer with 32 GB RAM. In the following, a description of the provided dataset of real-world Android applications is given in Section 6. Then, the correctness, scalability, and run-time performance criteria are evaluated in Sections 6, 6, and 6, respectively.

# 6 The dataset of real-world Android apps
We constructed a dataset of benign, malicious, and vulnerable Android applications, as shown in Table 2. For benign and malicious apps, AndroZoo is considered. AndroZoo is a growing collection of millions of Android applications collected from various marketplaces such as Google Play and F-Droid. From this collection, 500 benign apps (the creation date after December 2019), as well as 300 malicious apps (the creation date after December 2018), are selected. In addition, 257 vulnerable apps are considered from four Android application vulnerability benchmarks, including DroidBench, ICC-Bench, Ghera, and UBCBench.

According to the mobile app statistics in recent two years, on average, 40 apps in 2020 and 30 apps in 2021 are installed on the user’s devices per month. Therefore, in this evaluation, 10 bundles of apps, each containing 35 apps, are created randomly from the provided dataset. Each bundle contains 29 benign apps, 3 malicious apps, and 3 vulnerable apps.

# Distribution of selected apps from various repositories that were considered in our dataset
# Histogram of categories of apps selected from Google Play (282 Android apps)
# RQ1 (Correctness)
According to the definition given by Pressman and Maxim, correctness indicates the extent to which a software product satisfies its objectives. This criterion determines the correctness of the approach used in the VAnDroid2 tool and to what extent the analysis results of this tool (i.e., inter-app vulnerability reports) can be reliable.

To examine the correctness criterion, it is necessary to consider an Android app vulnerability benchmark that proposed known vulnerabilities in its bundles. For this purpose, the Ghera repository is considered. To specify the reason for the selection of the Ghera repository, the main characteristics of this repository are described in the following.