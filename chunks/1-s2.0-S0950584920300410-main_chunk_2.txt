In this context, we investigate the run-time behavioral evolution of benign apps versus malware in Android with a focus on app execution structure. While dynamic characterization is generally subject to limited code coverage, it reveals the real behaviors actually observed hence complements static characterization. Specifically, we characterize the execution structure in terms of various app functionality scopes (user code, Android framework, and third-party libraries) and their interaction, distribution of component types and communication between components, and callback use extent and categorization. All these dynamic measures are computed via the full scope of method calls and inter-component communication (ICC) exercised during app executions. We chose these specific measures as motivated by our previous study  that found them to well capture behavioral differences between benign apps and malware of a particular year. Also, concerning that capturing explicit malicious behaviors (e.g., sensitive data flows ) is not always feasible because sophisticated malware may hide their true behaviors at runtime  to evade detection, we chose the structural measures which are not explicitly associated with obvious, known malicious behaviors.

By examining the execution traces of 30,634 apps, including 15,451 benign apps and 15,183 malware as group samples (rather than evolved versions of the same apps), throughout the past eight years, we performed in-depth investigations of how malware evolves differently from benign apps in terms of various measures of execution structure. Through this extensive dynamic evolution study, we address the following research questions, with corresponding major findings summarized below. These questions are integral parts of an umbrella question of how does malware behave differently from benign apps in terms of code-level execution structures?, consistent with our goal with this study of understanding the run-time behavioral differences between the two app groups in terms of such structural traits.

- How does malware exercise its functionalities in varied functionality scopes differently from benign apps? We found that generally the execution of benign apps is similarly distributed over the three high-level functionality scopes (user code, third-party libraries, and the Android SDK), with similarly little yet still shrinking portion of user code exercised, to malware. However, malware made calls to SDK mainly via third-party libraries, as opposed to benign apps making such calls from within the SDK.

- How does malware execute different types of components differently from benign apps? Our results reveal that while the execution of both benign apps and malware was dominated by user-interface (Activity) components, the use of such components was steadily shrinking in benign apps whereas in malware the use was on rise after two periods of declination. Compared to benign apps, malware executed significantly larger portions of Services, but smaller portions of Content Providers. Also, malware made larger portions of ICCs connecting to external (built-in) apps. Although both groups did not carry any data in most ICCs, data-carrying ICCs in malware transferred data via standard-data fields significantly less often than benign apps.

- How does malware use callbacks of various categories differently from benign apps? We found opposite trends in overall callback usage between benign apps and malware during their evolution. In particular, compared to the gradual reduction in their run-time invocation of callback in benign apps, malware has seen drastic growth in executing callbacks, as mainly attributed to the rise in using lifecycle callbacks. Meanwhile, rankings of callback categories were similar and generally stable over time between benign apps and malware, yet rank differences were shrinking in malware.

# H. Cai, X. Fu and A. Hamou-Lhadj
# Information and Software Technology 122 (2020) 106291
We also discussed implications of our findings to app testing and security analysis. To the best of our knowledge, this is the first, longest-spanning study focusing on the evolution of dynamic behaviors of benign apps versus malware in terms of code-level execution structures. Our study dataset and utilities have been made publicly available (as found here ) to the community to facilitate replication and support further studies. The toolkit for the study has been made publicly earlier , with detailed usage documentation available as well . The dataset comes with necessary details for obtaining the apps themselves, and the toolkit is accompanied by informative usage documentation.

# 2. Background
This section gives background on the Android framework and its applications to facilitate understanding our study.

# 2. Android framework and callbacks
The middle layer between the Android OS (a customized Linux kernel) and its user applications constitutes the Android framework. This framework provides the implementation of application programming interface (API) methods through which user apps can receive system services and invoke common functionalities associated with mobile devices. The API is typically part of the Android software development kit (i.e., SDK) which also includes tools to support app development. The user apps are event-driven and interact with the framework often via callbacks implemented in their user code, including those dealing with various events (i.e., event handlers) and those for the framework to manage app lifecycles (i.e., lifecycle methods).

# 2. App components and ICC
Under the framework-based development paradigm, Android apps usually comprise building blocks called components of four types: Activity forming the basis of user interface, Service performing background tasks, Broadcast Receiver responding to system-wide broadcasts, and Content Provider offering database capabilities. The Android framework defines a set of lifecycle methods for each top-level class corresponding to each of these component types and additionally for the class android.app.Application. Inter-component communication (i.e., ICC) is the primary means for components within (i.e., internal ICC) the same app and across apps (i.e., external ICC) to exchange messages via message objects called Intents. The target of ICC may be explicitly specified (i.e., explicit ICC) or left unspecified for the framework to resolve at runtime (i.e., implicit ICC).

# 3. Scope and research questions
Our overarching aim is to understand how the execution structure of malware evolves differently from that of benign apps. Importantly, we focus on the differences that have security relevance and implications. Thus, we compare benign apps and malware as two large groups, disregarding (1) functional differences (e.g., between game apps and musical apps) and (2) differences within each group (e.g., among benign apps of different kinds/categories or among malware of varied families). In particular, we examine the execution structure of apps by profiling all method calls during their executions. Further, we express the structure in terms of the following three groups of dynamic measures.

- Functionality scopes (code layers). In general, an Android application package (APK) may contain three high-level scopes (layers) of app functionalities at runtime: user code (userCode, i.e., any code the app developer actually wrote), Android libraries (SDK, i.e., framework APIs), and third-party libraries (3rdLib, i.e., any libraries other than the SDK used by the app). We measure execution structure through the distribution of executed methods over these three code layers according to which layer each of these methods is defined in. We further measure calls across layers.

- Components. Android apps follow a general modular design, implementing four high-level categories of functionalities (user interface, background service, system communication, and data management) in the four different types of components (Activity, Service, BroadcastReceiver, and ContentProvider, respectively). In addition to code layer distribution and interaction, we examine app execution structure also through how apps execute code in each of these types of components and how app components communicate through ICC of varied types (implicit versus explicit and internal versus external). We further looked into the data fields in the Intent of exercised ICCs, concerning the three ways an ICC may carry data: only via standard URI (the data field of the Intent), only via bundle (the extras field of the Intent), or both (two Intent fields carrying data).

- Callbacks. Due to their event-driven programming paradigm, Android apps feature common use of callbacks through which apps leverage the SDK capabilities and the Android platform communicates with apps. We thus measure the overall callback usage and distribution of such usage over the two major kinds of callbacks: lifecycle methods and event handlers. We further examine the use of each kind over its major categories. Specifically, we categorize lifecycle methods according to the five top-level enclosing classes defined in the SDK: Activity, Service, BroadcastReceiver, ContentProvider, Application. A lifecycle method is categorized into one of these categories based on the rationale that the method is one of those that the framework uses to manage the lifecycle of the corresponding type of component or the entire app. For event handler callbacks, we consider five types of user interfaces (UIs) associated with (App bar, Media control, View, Widget, Dialog), and five types of system events handled (App management, System status, Location status, Hardware management, and network management). An event handler is categorized into one of these categories as it is the callback that the framework invokes when the UI or system event occurs. Our choice of these types of events is informed by a previous study that found them as the top five most-frequently exercised UI/system events.