Listing 3 shows the implementation of getIntent method in the HiddenBehavior class. On line 4, getIntent obtains a reference to the Location Manager, a service that provides periodic updates of the device’s geographical location. On line 5, the Location Manager is used to get the user’s last known location. In lines 7–9, it creates an implicit Intent and adds a phone number and the user’s location as the extra payload of the Intent. This code is compiled to a DEX format and archived in a JAR file using the dx tool, a tool that generates Android bytecode from .class files. The JAR file could be downloaded by the malicious app after installation.

On lines 5 and 6 of Listing 1, the Sender service extracts the phone number and the location information from the received Intent, respectively. The extracted information is used in line 8 to send a text message. The Sender component is vulnerable to a privilege escalation attack since it performs a privileged task, sending text messages, without checking if the caller component has the required SMS permission to perform the task. An example of such a check is shown in line 4 of Listing 1, but in this example, it is commented. This type of vulnerability is quite common, as many developers fail to properly use the APIs or follow the best practices for secure programming. In fact, in the Android domain, since many apps are developed by novice programmers, misuse of APIs is rampant.

The illustrative example described in this section allows LevelUp to hide its malicious behavior to exploit a privilege escalation vulnerability and leak the user’s sensitive information (i.e., user’s location) via text messaging without having the SMS permission. This kind of an attack is neither effectively detectable through static program analysis, since the malicious behavior is down-
# 1. public class HiddenBehavior {
2          ...

3          public Intent getIntent ( Context context ) {
4                 LocationManager locMgr = ( LocationManager ) context.getSystemService ( Context.LOCATION_SERVICE ) ;
5                Location loc = locMgr.getLastKnownLocation ( LocationManager.GPS_PROVIDER ) ;
6                String msg = loc.getLatitude () + " ," + loc.getLongitude () ;
7                Intent i = new Intent ( "SEND_SMS" ) ;
8                i.putExtra ( "PHONE_NUMBER", msg ) ;phoneNumber ) ;
9                i.putExtra ( "MSG_CONTENT",
10                return i ;
11          }
12    }
Listing 3. Code downloaded after initial installation of app.

# Original Architecture
loaded after installation, nor through dynamic program analysis, as malicious apps often incorporate complicated evasion tactics (e.g., timing-bombs Coogan et al., 2009). We show how through establishment of an LP architecture, DelDroid can effectively mitigate such threats.

# 4. Approach
As depicted in Fig. 2, DelDroid consists of five steps (1) Architectural Elements Extractor uses static program analysis techniques to elicit the system’s principal components along with their properties, latent communications, and permissions usages from the apps comprising a system. (2) Privilege Analyzer systematically examines each component to comprehensively determine its privileges, the permissions it can use as well as components with which it can communicate, both inside and outside the scope of its hosting app, as permitted by the Android runtime environment. The result of this step is captured in a Multiple-Domain Matrix (MDM), representing the original architecture of system. (3) Privilege Reducer determines the exact permissions and communications each component needs to fulfill its functionality. The derived information is then captured in an MDM, representing the least privilege architecture for the system. (4) Security Analyzer evaluates the identified LP architecture apropos potential security threats, and presents the analysis results to the security architect who may further modify the architecture as needed to establish the proper privileges for each component. (5) Finally, LP Enforcer regulates interactions at the granularity of components through enforcing automatically generated or expert-supplied least-privilege architecture at runtime. It relies on two components, i.e., Resource Monitor and ICC Monitor, within the Privilege Manager layer that we have added to the Android runtime environment to check the conformance of ICC and resource-access transactions to the LP architecture.

The extracted architectural elements for the Android system shown in Fig. 1.

# 4. Step 1: Architectural elements extractor
To obtain the system’s architecture, we first need to determine the principal components that constitute the system, their properties, communication interfaces, and permission usages. Such information is obtained from two sources, an app’s manifest file and its bytecode.

DelDroid utilizes APKtool, a reverse engineering tool for Android APK files, to recover an app’s manifest file. By simply parsing the manifest file, we can extract certain information readily available about the components comprising an app, such as their names, types, visibility, permissions required by other components for interaction. Table 1 partially shows the extracted information corresponding to our running example (recall Section 3). The Component Type column represents the particular type of a component, which could be either Activity, Service, Broadcast Receiver, or Content Provider. The Exported column indicates whether a component can be launched from outside its hosting app or not. The Intent Filter column shows the interfaces provided by a component. Finally, the Granted column shows the permissions requested by an app, and subsequently granted by Android to all of its components. Among others, the three components of the Messaging app all have access to both the SMS (android.permission.SEND_SMS) permission and the Bluetooth (android.permission.BLUETOOTH) permission, given that the Messaging app acquires the SMS and the BLUETOOTH permissions.

Not all information about an app can be obtained from its manifest file. For example, Broadcast Receivers can be registered in code without declaring them in the manifest file. Components can also programmatically define Intent Filters in code. In addition, all ICCs are latent in the app’s bytecode. Components can communicate with one another in two ways: (1) using Unified Resource Identifiers (URIs) to access the encapsulated data in Content Providers, and (2) by sending Intents, either explicitly or implicitly. DelDroid utilizes IC3  to analyze each app in the system and extract such latent information from its bytecode. IC3 is the state-of-the-art static program analysis tool for Android. For each Intent in bytecode, DelDroid extracts the sender component, receiver component, action, categories, and data. Table 1 shows the remaining information collected in this way for our running example. Intent Intenti3 is not shown, since the program logic that creates that is not initially part of the FunGame (recall Listing 2). Moreover, the type of each extracted Intent, i.e., explicit or implicit, is indicated in the Intent Type column.

DelDroid also identifies the permissions actually used by components. These are the permissions that a component uses for (1) accessing a protected Content Provider, or (2) calling a protected API. For the former, we have created a mapping between protected Content Providers and the required permissions. For example, to read the contacts information from Android’s Contacts Content Provider, a component needs android.permission.READ_CONTACTS permission. Using this mapping and the accessed Content Providers, our approach determines the actually used permissions for a component. Since IC3 does not extract the permissions used through API calls, for the latter case, DelDroid leverages PScout permission map , one of the most recently updated and comprehensive permission maps available for the Android framework. It specifies mappings between Android API calls/Intents and the permissions required to perform those calls. For example, Sender component API for sending text messages (see line 8 of Listing 1), which requires SMS permission. We thus consider this to be a permission that is actually used by this component, as shown in the Used column of Table 1.

Finally, DelDroid builds on our prior work  to extract the permissions enforced by a component at two levels. While the coarse-grained permissions specified in the manifest file are enforced by the Android runtime environment over an entire component, it is possible to add permission checks, such as check-CallingPermission, throughout the code controlling access to specific parts of a component (see line 4 of Listing 1). DelDroid identifies both types of checks. Since the system of Fig. 1 does not perform any checks (line 4 of Listing 1 is commented out), the corresponding column in Table 1 is empty.

# 4. Step 2: Privilege analyzer
The next step is to derive the overall system architecture from the information obtained for individual components in the previous step. We call this the Original system architecture, as it represents the architecture of the system if it were to be deployed on the official Android runtime environment. DelDroid models the system architecture as a Multiple-Domain Matrix (MDM) (Lindemann and Maurer, 2007). MDM provides an elegant representation of complex systems with multiple concerns (domains). Each concern is modeled as a Design-Structure Matrix (DSM) Steward (1981)—a simple matrix that captures the dependencies of one relationship type. MDM is formed by connecting the DSMs together. We capture five domains in an MDM to represent an Android system’s architecture for the purpose of privilege analysis.