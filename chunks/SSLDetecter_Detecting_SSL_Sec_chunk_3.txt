In summary, SSL security issues still need to be taken seriously in Android applications. Some of exiting methods cannot effectively deal with the analysis of packed applications , and in many cases, it does not work. Some others also has disadvantages, such as time-consuming analysis and system modification, which make it difficult to effectively detect SSL security vulnerabilities. How to automate and effectively detect SSL security vulnerabilities in Android applications is still a challenging problem that has not been well solved. Based on our previous work , we have proposed a new automatic traversal method to detect SSL security vulnerabilities of Android applications. Our new method is described in detail below.

# 4. UI Traversal Strategy
Android applications realize user interaction through the component named Activity. Each Activity corresponds to one or more interfaces (views). The interface contains a number of widgets that are bound to listen to user events, and the user manipulates these widgets to perform program functions. In a directed graph that only knows the initial node, the interface jump is generated by simulating the user.

# 4. Our Traversal Model
The traversal model is a finite state machine to represent the interface (view) states and the transition process between them. We build our novel GUI traversal model for Android applications based on the widget level. We give specific definitions of our traversal model below.

Interface state consists of binary group &lt; interface widget tree, Activity name&gt;, and is used to identify different interfaces in the process of application running. The interface widget tree refers to a tree with widgets as its nodes, which is built according to the hierarchical relationship and the dependency relationship of widgets in the interface. Each node holds the widget’s structural information (parent widget, child widget, and widget path) and widget property information (such as widget type, text information, and clickable). The Activity name defined by its fully qualified type name represents the Activity to which the interface state belongs.

Actions are specific actions that cause changes in the state of the interface. They can be divided into simple actions and combined actions. Simple actions consist of a triple &lt; widget ID, event type, and additional information&gt;. Widget ID is used to identify the widget. The event type indicates the action performed by the widget. Additional information provides widget action assist information. Combined actions consist of two or more simple actions.

GUI node consists of a binary group &lt; interface state, task list&gt;. The interface state describes the basic information of the GUI node. The task list holds information about the tasks that the GUI node needs to perform.

Task represents by a binary group &lt; action, GUI node&gt;, indicating that the action is executed only under the GUI node.

GUI jump consists of a binary group &lt; task, GUI node&gt; which is used to describe the jump relationship of GUI nodes. The task is a task in the task list of precursor node, and the GUI node is the destination node to jump to after executing the task. GUI directed graph consists of a binary group &lt;GUI node set, GUI jump set&gt;. GUI node sets constitute all vertex information in GUI directed graph, and GUI jump sets constitute all edge information in GUI directed graph.

The process of building our GUI traversal model is the process of dynamically extending GUI directed graph. After entering the application, the first interface corresponds to the starting GUI node of the GUI directed graph, and the
# Security and Communication Networks
# 4. Interface Widget Tree Optimization
Each interface corresponds to a widget tree. If we exhaust the simulation of all the actionable widget events on the widget tree, not only will the traversal space swell, but also this is not allowed in the detection time. For example, when we traverse to a slidable page that contains a news list, it would take a lot of time to click on each piece of news. However, in reality, these widgets trigger the same network link only with different parameters. Second, improper handling of widgets can also cause the traversal aborts. For example, when a prompt box pops up on the interface, the prompt box will get the window focus, so that the interface widget behind cannot be clicked. At this time, if the pop-up box cannot be closed correctly, it will directly jump out of the interface to be tested and terminate the traversal. Finally, when there are many types of events on an interface, such as input box, selection box, button, and so on, it is especially important to establish the sequence of event triggers. To deal with the problems above and to trigger as many effective network request events as possible in our system, we propose an optimization strategy of the widget tree according to the interface categories.

After manually analyzing 200 runtime screenshots of applications, we have divided the interface into six categories: welcome interface, popup interface, list interface, detailed interface, input interface, and other interfaces from three aspects of interface area, widget tree structure, and specific widgets. Table 1 describes the feature information of each category of interfaces. During the application running process, the interface category is identified by feature matching and different widget tree optimization strategies are conducted to trigger as many effective network requests as possible to cover the suspected SSL vulnerability points. The following Strategies 1 to 6 correspond to the six categories of interfaces, respectively. At the same time, after each kind of interface is processed, all the actionable widget events in the optimized widget tree are cropped according to Strategy 7 and Strategy 9, and the action sequence is built according to the specified priority.

# Strategy 1
When the interface is identified as the input interface, widget nodes such as EditText, SearchView and CheckBox are searched in the widget tree to obtain information such as text, content-desc, and resource-ID of the widget, so as to identify the type of information that the node needs to input. The input library we built is just several XML configuration files, including various information such as mobile phone number, e-mail address, gender, and search keywords. The input library is then matched to generate input actions expressed as a triple &lt; widget ID, “input action,” “input contents” &gt;. Simultaneously search for the sibling node of the widget, the parent node, or the sibling node of the parent node of the widget, then match the corresponding button node according to the context information, generate &lt; widget ID, “click” &gt; button action, and encapsulate the two actions into combined action.

# Strategy 2
When the interface is identified as a list interface, we first build a path set from the root node to all the leaf nodes. The path set consists of a sequence of widget types, such as “framelayout-viewpager-listview-framelayout-text-view.” Then we filter out the paths that contain the scrollable ListView, RecyclerView, and ExpandableListView nodes from the path set. And those path sets which have more than 10 the same paths will be also filtered out. Finally, the same paths in the list path set are filtered, and only the Actions of one of the multiple child nodes under the list widget are generated.

# Strategy 3
When the interface is recognized as a pop-up box, we will carry out text matching analysis on the prompt message of the interface. If the text prompt is to update or download information, select the reject button such as “cancel.” For AD pop-ups, select the “close” button. For menus and other system prompt boxes, we generate the actions in turn according to the hierarchical traversal order of actionable widgets.

# Strategy 4
When the interface is identified as a detailed interface, we search the “return” widget on the interface or add a return action and directly return to the previous interface, without processing other widgets on the interface.

# Strategy 5
When the interface is recognized as a welcome interface, we generate sliding actions on the interface, including left sliding, right sliding, up sliding, and down, to make it jump to the real initial interface.

# Strategy 6
When the identified interface is other interfaces, generate an action sequence just according to the hierarchy traversal sequence of the interface widget tree.

# Strategy 7
Set the processing priority of different actions on each interface: combined action &gt; click action &gt; sliding action.

# Strategy 8
Set the priority of the same action processing on each interface according to the hierarchy traversal sequence of the interface widget tree.

# Security and Communication Networks
# Strategy 9.

When the “clickable” property of both parent and child widgets in the interface widget tree is “true” and the child widget overrides the parent widget, we crop the parent widget and only generate the action of the child widget.

# 4. Interface State Similarity Calculation.