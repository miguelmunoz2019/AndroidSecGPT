Amandroid is primarily focused on data flow analysis. It calculates points-to information for each instruction in the control flow graph, storing it in a Points-to Analysis Results (PTAResult) hash map. It also keeps track of ICC invocations in a summary table (ST). Amandroid then produces an Interprocedural Data Flow Graph (IDFG) for each component, which combines the Interprocedural Control Flow Graph (ICFG) with the PTAResult for that component. It then generates an Interprocedural Data Dependency Graph (IDDG), which contains the same nodes as the IDFG, but the edges are the dependencies between each object’s definition to its use. Finally, a DDG for the entire application is created by combining each component’s IDDG and the ST.

Amandroid uses the DDG to perform taint analysis. Given a set of taint sources and taint sinks, Amandroid marks the sources and sinks in the DDG and computes the set of all paths between them. The list of paths from sources to sinks is stored in a Taint Analysis Result (TAR) structure. Amandroid allows the user to define sources and sinks via text strings of method signatures in a configuration file.

Cardpliance analyzes how applications handle credit card information entered by the user into text fields. Applications access this text via the TextView.getText() method. However, Cardpliance needs to determine which TextView objects correspond to the UI widgets that collect different types of credit card information. To acquire a TextView object, the application calls Activity.findViewById(R.id.widget_name), where R.id.widget_name is a unique integer managed by the application’s resource R class. Therefore, Cardpliance uses Activity.findViewById(int) as a taint source. The analysis will taint the returned TextView and the subsequent string from TextView.getText(). Furthermore, since the DDG contains points-to information, the PCI DSS tests can use Amandroid’s ExplicitValueFinder.findExplicitLiteralForArgs() method to determine the integer value passed to the taint source. It then uses the resource IDs of credit card information widgets identified by UiRef  to determine the types of information flowing to each sink.

However, applications frequently call Activity.findViewById() to assess many different UI widgets. Therefore, simply defining it as a taint source will cause Amandroid’s taint analysis to needlessly compute taint paths for many irrelevant sources. To address this problem, Cardpliance implements a custom source and sink manager that refines the taint sources to just those Activity.findViewById(int) instructions that are passed an integer in a list precomputed by UiRef. This process involves using the PTAResult hash map while marking taint sources. In doing so, we significantly reduce the time to analyze applications.

Additionally, since one of Cardpliance’s tests uses View.setText() as a taint sink, we perform a similar optimization in the custom source and sink manager. In this case, we backtrack in the DDG to the definition site of the View object and identify the corresponding call to Activity.findViewById(int). We then similarly resolve the integer resource ID. If the ID is in a predefined list (defined via a heuristic for the test), the call to View.setText() is defined as a taint sink.

Finally, we had to patch Amandroid’s control flow analysis to properly track the use of View objects obtained in OnClickListener callbacks. We found that many applications declare the OnClickListener of a View as an anonymous inner class. In such cases, Amandroid did not capture the data flow initiated by the button click. We fixed this issue by adding a dummy edge from the point where the OnClickListener was registered to the entry point of the corresponding OnClickListener.onClick() method.

# 4 PCI DSS Tests
At a high level, Cardpliance uses Amandroid’s taint analysis result (TAR) to identify potential PCI DSS violations. However, the TAR does not consider context at the sources and sinks, or all different paths between the sources and sinks. Cardpliance uses the DDG to identify specific instructions as sources and sinks based on constant values available from the PTAResult hash map. It then calculates all paths between those specific source and sink instructions, determining if specific conditions occur (e.g., calling an obfuscation method).

# 4 Analysis Approach
The DDG is a directed acyclic graph (V, E) where the set of vertices V are program instructions and the set of edges E represent def-use dependencies between vertices (v, v ). We say there exists a path between vs and vk (denoted vs vk) if there is a sequence of edges (v, vs+1), (vs+1, vs+2), . . . (vk−1, vk). We refer to a specific path p from vs to vk as vs p vk.

Each PCI DSS test is defined with respect to instructions invoking three sets of methods: source methods (S), sink methods (K), and required methods (R). S and K are traditional sources and sinks for taint analysis. Whereas Amandroid’s sources and sinks are method signatures, some of Cardpliance’s sources and sinks are context-sensitive. For example, an instruction that calls Activity.findViewById(int) is only a source if the argument is an integer from a list of resource IDs identified by UiRef as requesting credit card information.

In contrast to S and K, R places requirements on the data flow path. Informally, R defines a set of methods that should be called on the data flow path (e.g., a string manipulation method that could mask characters). If no methods from R exist on the path, then a potential violation is raised.

We now describe the general template used by each test to generate sets of potential violations. For simplicity, we say that instruction v ∈ V is in S, K, or R if the instruction v calls a method in one of those sets, potentially parameterized with the correct constant values. Then, for vs, vk, vr in V, the test produces paths as potential violations as follows:
{(vs p vk)|vs ∈ S, vk ∈ K, vs p vk ∧ (6 ∃vr ∈ p|vr ∈ R)}
That is, even if vs vk, it is not a violation if all paths include an instruction vr that is in R. Note that not all tests use R and therefore the logic for these tests skips the second term in the conjunction. However, this is logically equivalent to R = /,0 which will cause the term to always be true.

# 4 Test Implementation
The remainder of this section describes our six PCI DSS tests with respect to S, K, and R. In doing so, we reflect on the relevant requirements described in Section 2. We also describe implementation-specific considerations for each test. An overview of the tests is provided in Table 2.

# Test T1 (Storing CHD)
Requirement 1 in Section 2 states that storage of cardholder data (CHD) should be limited, and if it is stored, there should be a mechanism to delete if after a period of time. Determining all of the ways in which persistent data can be deleted is not practical to detect using static program analysis. Therefore, Test T1 takes a security-conservative approach and identifies whenever CHD is written to persistent storage. As such, Test T1 is more of a warning than a violation of PCI DSS. However, it is useful as a coarse metric and can bring potentially dangerous situations to the attention of a security analyst.

Test T1 captures a key program analysis primitive that is needed by the other tests: data flow analysis from specific UI inputs. Amandroid provides a Taint Analysis Result (TAR) structure that contains a superset of all of the paths identified in all of the tests. Test T1 filters the TAR based on the sources and sinks listed in Table 2. Note that Test T1 only considers the sources that call Activity.findViewById(int) with resource IDs corresponding to CHD. We further reduce the text input source to just the credit card number (PAN), as there is the potential for ambiguity when identifying the other fields (e.g., cardholder name vs. another name field). The custom source and sink manager described in Section 4 only limits the analysis to credit card related data, which includes both CHD and SAD. Therefore, we again use Amandroid’s ExplicitValueFinder, but within a different phase of the analysis. The data persistence method (DPM) sink methods listed in the table do not require special consideration. Once these concrete sources and sinks are identified, we traverse the DDG to identify all paths between them.

# Test T2 (Storing SAD)
Requirement 2 in Section 2 states that sensitive account data (SAD) should never be written to persistent storage, including logs. From the mobile application perspective, the only SAD that users will enter into text fields is the three or four digit CVC code written on the physical card. Therefore, Test T2 only needs to consider Activity.findViewById(int) sources that are passed resource IDs corresponding to CVC-related fields. The remainder of the analysis is identical to Test T1. Note that unlike Test T1, the existence of a data flow path directly represents a PCI DSS violation.