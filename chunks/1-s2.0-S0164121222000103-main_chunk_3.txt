Then, Q6 − Q7 aimed to collect information about the developers’ perception of security weaknesses. For these questions we provided a predefined list of possible factors to check, with the possibility of specifying additional factors. For Q6, the predefined list included: Skill level required to exploit it, Motivation to exploit it, Chances for a successfully exploit, Number of agents needed for the exploit, Ease of discovery, Technical difficulty of the exploit, How well-known is the weakness, and How likely is the exploit to be detected. Concerning Q7: Confidentiality, Integrity, Availability, Accountability, Brand reputation, Business profits, and Privacy violation.

Q8 and Q9 aimed to validate/complement the taxonomy defined as output of the manual study, with Q8 focusing on the most frequent and Q9 on the most dangerous security weaknesses experienced by developers. Both these questions required an open answer. Two authors read each answer and assigned the CWE-ID(s) needed to describe the security weaknesses mentioned in each answer. A third author merged these tags and solved conflicts arisen for 15 answers (18%).

Since a respondent might have answered the same for Q8 and Q9, duplicates among these answers were removed to avoid counting twice the same security weakness mentioned by the same developer.

Finally, Q10 asked developers how they detect security weaknesses and whether they are supported by any tool.

We used convenience sampling to invite developers from companies we know to participate in our survey. Also, the link to the survey was shared in social media. We collected answers for ten days, with a total of 43 participants that completed our survey from nine countries (i.e., Argentina, Canada, Colombia, Germany, Hungary, Italy, Macedonia, Poland and USA). On average, the participants had ∼6 years of overall programming experience and approximately 3 years of Android development experience (see Fig. 1). The average testing experience is close to two years. Regarding their job position, 21% of participants are B.Sc. students, 7% M.Sc. students, 4% Ph.D students and 67% professional Android developers having different job positions in the industry (e.g., Senior Android developer, Technical leader, Project Management Engineer, Director).

# 2. Testing the generalizability of our taxonomy
Once obtained the final taxonomy including both categories defined through the mining-based study as well as those complemented by the developers’ survey, we assessed its generalizability. We used all 64 Kotlin-related commits we did not manually analyze while building our taxonomy and a sample of 186 Java-related (again, among those we did not analyze). Then, we asked two Master students both having experience in Android development and not involved in the taxonomy definition and unaware of its structure, to perform the same manual analysis previously described. Each of them independently evaluated all instances. Conflicts arisen in 68% of cases were solved through an open discussion between the two students and the first two authors of this work. The final output is a taxonomy of security weaknesses affecting Android apps, that we can compare with the taxonomy we defined to assess its stability. While in principle more Kotlin-related commits would be needed, we labeled all those we found by mining several datasets of Android apps.

# 2. Data analysis
We start by presenting the taxonomy of types of software security weaknesses output of our mining-based study. Then, we discuss how the developers’ survey helped in validating/complementing the obtained taxonomy. Finally, we report about the results of the generalizability study. The data used in our study are publicly available (Mazuera-Rozo et al., 2021).

# 3. Results
The taxonomy is derived by a total of 400 commits (200 for Java and 200 for Kotlin) we manually validated. However, there are 14 commits that were grouped in the Unclear category since in these cases, while it was clear the intent of fixing a security flaw, we were unable to derive the type of fixed security weakness. Each category in Fig. 2 is accompanied by one, two, or three numbers. The two numbers with white background represent the number of instances of the corresponding security weakness type we found in Java (top number) and Kotlin (bottom). The one with gray background represents the number of developers that mentioned the type of security weakness in our survey. Categories added to our taxonomy as the result of the survey (e.g., CWE-625: Permissive Regular Expression), only have a gray-background number.

It is worth noting that some categories have only been found in a few commits or have only been mentioned by developers (but not found in the mining-based study). Concerning the first case (i.e., low number of commits related to the category), we preferred to still include those categories since, thanks to the numbers attached to them, it is easy for the reader to assess their relevance. In other words, it is clear from our taxonomy that, for example, the prevalence of CWE-691 vulnerabilities (78 overall instances) is much higher as compared to CWE-779 (3 overall instances). Concerning the latter case (i.e., categories only mentioned by developers), they increase the comprehensiveness of our taxonomy; the fact that we did not find them in the analyzed sample of commits does not make them less relevant for our study. Indeed, while we analyzed a substantial set of commits (400), it is reasonable to expect that we did not encounter specific types of vulnerabilities in our study (as we will also show in Section 3).

In addition, it is worth mentioning the hierarchical organization of the categories, moving from the most general categories (i.e., the root nodes, such as CWE-710), to more specialized ones (e.g., CWE-1164) down to the leafs (e.g., CWE-1069). The sum of instances for all child categories of a given node is lower or equal than the number of instances reported in its parent node. For example, CWE-1069 and CWE-561 are the two child categories.

A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.

The Journal of Systems & Software 187 (2022) 111233
5
# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.

# The Journal of Systems & Software 187 (2022) 111233
of CWE-1164 (top-left corner of Fig. 2). CWE-1069 and CWE-561 have 1 and 11 Java-related instances, respectively, while their parent category CWE-1164 has 18 Java-related instances. This is due to the labeling process since we assigned to each commit the most specific security weakness type we could derive from the manual inspection. Thus, for 12 of the 18 commits belonging to CWE-1164 we managed to provide a more specific categorization, resulting in the two child categories, while for 6 of them CWE-1164 was the most detailed label we could assign. Finally, some categories are not linked to any CWE-ID. These categories are either (i) aggregating some sub-categories for better visualization, or (ii) created by the authors since they did not find a proper type within the CWE dictionary to classify an instance (See Table 2).

We start by discussing the categories output of the manual analysis (Section 3), presenting then the main differences between Java and Kotlin-related security weaknesses (Section 3), and then discussing how the developers survey validated/complemented our taxonomy (Section 3). Finally, we present the results of the further manual validation performed by two Master students to test the generalizability of our taxonomy. We use icons to highlight parts related to implications for researchers and practitioners.

# 3. Mining-based study
(1) Improper Control of a Resource Through its Lifetime (145 instances - 36%). It includes security weaknesses related to not maintaining or incorrectly maintaining control over a resource throughout its lifetime of creation, use, and release, leading to potentially exploitable states. A strongly represented type in this category is CWE-557: Concurrency Issues, being prominent in both Java (29 instances) and Kotlin (40).

Another common weakness related to the improper control of resources is CWE-668: Exposure of Resource to Wrong Sphere, with 11 instances found in Java and 8 in Kotlin. CWE-668 arises when a resource is inadvertently exposed due to insecure permissions or unexpected execution scenarios. Fig. 4 shows Kotlin code in which the developer sets the FLAG_SECURE to a window showing a password in the app.

The added flag asks the window manager to disable screen recording/capturing when the showPassword method is executed. The usage of this flag in windows containing sensitive information is recommended in the official Android documentation. Also in this case, techniques can be developed by researchers to automatically identify features in code that (i) deal with sensitive information that can be detected through simple keyword matching mechanisms (e.g., looking for words like “password”), and (ii) are in charge of displaying windows. Then, a simple automatic addition of proper flags can avoid potential points of attack. Such a security issue is also documented in Stack Overflow.

This suggests the potential usefulness for developers of recommender systems able to point out them to relevant Stack Overflow discussions while writing code (e.g., Prompter Ponzanelli et al., 2016). Making the developer aware of such issues at coding time can avoid the introduction of the security flaw in the first place.