# Performance
For comparison, we applied the MalloDroid, SMV-Hunter and GLACIATE to the entire dataset. Since MalloDroid and SMV-Hunter only detect SSL/TLS-related flaws (i.e., flaw 2 in this paper), we limited GLACIATE to detect flaw 2 (736 flaws in total) in this test. From the results we computed the precision, recall and F1 over the entire dataset for each tool.

TrustManagers are responsible for managing the trust material that is used for deciding whether the received public key certificates should be accepted. Besides the vulnerable TrustManagers detected by MalloDroid, GLACIATE also finds three new types of vulnerable TrustManagers, namely BlindTrustManager, InsecureTrustManager and AllTrustingTrustManager. Apps with these vulnerable TrustManagers suffer from flaw 2.

# GLACIATE: Further Analysis of Performance
In comparing the detection performance of GLACIATE and MalloDroid, we find that MalloDroid fails to correctly analyze apps that implement authentications across different classes, which means MalloDroid is unable to analyze method invocation relationships and cannot extract inter-component communications in apps. Furthermore, comparing the results for GLACIATE and SMV-Hunter, SMV-Hunter relies on user inputs to trigger the recognition of authentication flaws. However, it is a challenge to generate accurate inputs to trigger the procedures.

GLACIATE did fail to analyze some apps. Since GLACIATE is built on top of Soot, each app has to be decompiled using Soot. In total, Soot was unable to decompile 184 apps, failing in “Soot.PackManager”. This method runs the
# Finding Flaws from Password Authentication Code in Android Apps
# 4 GLACIATE: Large Scale Analysis of Password Authentication
For this analysis, we downloaded 16,387 free apps at random from Google Play and used our ground truth to build our detection model for further analysis. We first checked whether our collected apps implemented any password authentication protocols. In total, 13,747 apps were successfully analyzed, and 5,667 (41%) of them implemented BPAP. Further analyses were performed on those 5,667 apps. Apps failed to be analyzed by GLACIATE are unable to be decompiled by Soot.

Based on the detection report generated by GLACIATE (see Table 3), we find that 4,542 apps establish secure password authentication protocol by using at least one protection protocol. Among the apps with at least one protection protocol, we observe that 3,738 implemented BPAP over SSL/TLS, which indicates that SSL/TLS is the most common protection mechanism in practice. We also identify 385 apps with both protections, i.e., BPAP over SSL/TLS and timestamp-based password authentication protocols. By further analyzing those apps with multiple password authentication protocols, we find that some apps implement multiple login schemes (e.g., Facebook login, Wechat login, Tencent login), and their developers import external authentication libraries directly to implement those login schemes. The library providers offer a variety of password authentication protocols.

The password authentication protocol is supposed to be securely implemented. To our surprise, a large portion of apps have flaws discussed in Sect. 2 in their authentication code (shown in Table 4). Only 1,562 apps in our dataset implemented secure password authentication protocols. GLACIATE reports that passwords in 1,125 apps are not well-protected. For these apps with Flaw 1, we note that the exception, “ERROR heros.solver.CountingThreadPoolExecutor - Worker thread execution failed: Dex file overflow”, was posted in March, 2018. Soot might solve this problem in its next version.

Observe that some of them use MD5 hash functions with a constant salt, which is easy for attackers to find collision. However, most passwords are transmitted in plaintext over an insecure HTTP channel. As SSL/TLS is the most common mechanism used to protect BPAP, SSL/TLS-related flaw is also the most common one, i.e., flaw 2 (i.e., Insecure Server Connection). We also investigate whether apps have multiple flaws. In what follows we discuss further insights gained from this analysis.

# Flaw 2: Insecure Server Connection
This is the most common implementation flaw presented in 2,684 apps; that is, nearly 47% of the apps with password authentication meet this authentication flaw. This result indicates that developers are security conscious and understand that secure communication (e.g., SSL/TLS) should be used for transmitting passwords. However, they seem to be unaware of the importance of validating certificates and hostnames of the server, and the consequences of accepting invalid certificates and mismatched servers, or they decide not to validate certificates and hostnames with the aim of improving the app’s run-time performance.

# Certificate Validation
In total, GLACIATE identifies 2,417 apps suffers the flaws of accepting invalid certificates. A certificate validation includes two aspects: signature validation and a certificate expiration check. The authentication code is insecure unless both checks are executed. Based on the trusted CAs provided by Android, we classify invalid certificates into certificates signed by invalid CAs, self-signed certificates, and expired certificates. Table 5 lists the number of apps with these types of certificate flaws. Those certificate validations are incomplete in that 1,298 apps only verify whether certificates are signed by valid CA but neglect to check whether they are self-signed or expired, and 185 apps only verify two of the necessary checks of certificate validity. Almost 35% of the apps with flaw 2 do not have any certificate validation at all.

# Hostname Verification
2,059 of apps with flaw 2 accept all hostnames. Comparing this result with the result of certificate checking, a smaller number of apps suffer from this, since more aspects are required to be checked when validating certificates, i.e., expiry date and signature.

8 The list of trusted CAs can be found in https://www.digicert.com/blog/official-list-trusted-root-certificates-android/.

# Finding Flaws from Password Authentication Code in Android Apps
# Flaw 3: Repeatable Timestamp
Most apps with timestamp-based password authentication are securely implemented, but nevertheless 250 out of 804 apps used a repeatable timestamp.

# Multiple Flaws
We also collected information about apps which were found to have multiple violations. For the apps that used both protection mechanisms, GLACIATE identified 37 apps suffering from two types of authentication flaws. Authentication code in 29 apps accept all certificates and generate repeatable timestamps. 8 of them implement the authentication protocol as accepting all host names and generating repeatable timestamps. Additionally, GLACIATE detected 15 apps that violate all the authentication requirements, that is, accepting all certificates and all hostnames, and use repeatable timestamps. These results suggest that the capability of analyzing multiple password authentication protocols in the same app is essential for a complete identification of vulnerabilities.

# 5 Related Work
In the following, we first discuss detection techniques that are rule-based and attack-based. We then discuss fully-automated approaches that use machine learning algorithms.

# 5 Rule-Based Techniques
Most existing techniques detect vulnerabilities by using pre-defined rules/templates . CRYPTOLINT  detects cryptographic misuses in Android apps. According to the manually predefined cryptographic rules, CRYPTOLINT computes a super control flow graph for each app and uses program slicing to identify the violations. MalloDroid  is a detection tool for checking whether the SSL/TLS code in Android apps are potentially vulnerable to MITM attacks. By checking the network API calls and Internet permissions, MalloDroid determines whether the code has vulnerabilities, including accepting all certificates.

# 634
# S. Ma et al.

accepting all hostnames, trusting many CAs, and using mixed-mode/no SSL. However, because it only analyzes the network API calls, MalloDroid is unable to identify all the potential flaws due to its inability to extract the inter-component communications. Instead of performing code analysis, HVLearn  is a black-box learning approach that infers certificate templates from the certificates with certain common names by using an automata learning algorithm. It further detects those invalid certificates that cannot be matched with certificate templates. However, this approach can only be applied to the certificates with specific common names.

Besides these static analysis techniques, some dynamic approaches have been proposed without analyzing the code . Spinner  is a tool that uses a dynamic black-box detection approach to check certificate pinning vulnerabilities which may hide improper hostname verification and enable MITM attacks. Without requiring access to the code, Spinner generates traffic that includes a certificate signed by the same CA, but with a different hostname. It then checks whether the connection fails. A vulnerability is detected if the connection is established and encrypted data is transmitted. However, some unnecessary input will be generated while applying a fully automated approach.

To address the limitations of dynamic analysis, some approaches use a hybrid analysis (i.e., static and dynamic analysis) . SMV-Hunter  simulates user interactions and launches MITM attacks to detect SSL vulnerabilities. However, its detection performance relies on how well user inputs were created, and some vulnerabilities cannot be identified since they are not triggered by the MITM attacks.

Compared to these techniques, GLACIATE is a fully automated tool that does not require any manual effort. Instead of summarizing detection rules manually, we use machine learning to learn those rules automatically.