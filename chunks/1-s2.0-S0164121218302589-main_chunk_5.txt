(communicatee(cm, cv) ∨ communicate(cm, cv))i ∧ (appcv=appcm) ∧ ∃communicate(cx, cv) ∧ (appcv = appcx)i
Unauthorized Intent receipt is an ICC attack in which a malicious component intercepts an implicit Intent by declaring an Intent Filter that matches the sent Intent . In such an attack, a malicious component can access all enclosed data in the intercepted Intent and, possibly perform a phishing attack (Felt and Wagner, 2011).

There are three different forms of unauthorized Intent receipt based on the type of the malicious component (cm in Definition 5) : (1) Broadcast theft in which cm can read the content of broadcast Intents without interrupting the broadcast, (2) Activity hijacking in which cm is launched instead of a legitimate Activity, and (3) Service hijacking in which cm is bound to/started instead of a legitimate one. In case a hijacking attack is successful, cv may also be a victim of false response attack  in which cm can return a malicious result to cv.

As a concrete example of unauthorized Intent receipt attack, consider a legitimate application that processes financial payments. When a user clicks on a “Pay” button, the application sends an implicit Intent to start another Activity that processes the payment. If a malicious Activity hijacks the implicit Intent, then the attacker could receive sensitive information from the user (e.g., card number, billing address, and payment amount).

cious component cm that it does not expect communication from. Since Activities provide GUI interfaces, this attack can be an annoyance to the users. Successfully launching the cv Activity can cause cv to change data in the background using the data enclosed in the malicious Intent sent by cm. (3) Malicious Service launch is similar to malicious Activity launch except that the interaction between cm and cv occurs in the background. If a malicious Activity launch or a malicious Service launch attack is successful, cv may return sensitive information to the malicious component cm.

As a concrete example of Intent spoofing attack, consider an application that contains an advertisement (ad) library. Once a user clicks on an ad, the application sends an implicit Intent to an Activity, referred to as AdActivity here, which displays details of that ad on a web page. In this case, a malicious component can exploit an Intent spoofing attack by sending a carefully crafted implicit Intent to the AdActivity. If the AdActivity does not properly handle the received implicit Intent, the malicious component can deny the service of AdActivity and crash its app resulting in an inter-process denial-of-service (IDOS) attack. Moreover, if the AdActivity blindly trusts the incoming implicit Intent, a malicious component can redirect the user to a web page with malicious JavaScript code resulting in a cross-application scripting (XAS) attack. We refer the interested readers to Garcia et al. (2017) for more details on these kinds of Intent spoofing attacks.

By applying Definition 6 to the MDM representation of the system’s architecture, DelDroid identifies communications that may result in Intent spoofing ICC attack. Applying the Intent spoofing rule (Definition 6) to the LP architecture of Fig. 5 reveals that the communication between LevelUp and Sender satisfies the Intent spoofing rule. Since both LevelUp and Sender belong to different apps and also there is a communication between Composer and Sender, two components that belong to the same app. However, since this communication is already marked as potential privilege escalation attack via applying the Privilege escalation rule (Definition 4), DelDroid will not raise another warning for this communication.

It is worth mentioning that all violations to the determined LP architecture are recorded and accessible to the security architect through an Android app that we have developed, not shown in Fig. 2 to reduce the clutter in the figure. This app allows a security architect to understand the running system and adjust the architecture as needed.

# 4. Step 5: LP enforcer
modeling and analysis tools (Abiteboul et al., 2000; Ceri and Fraternali, 1997; Bry et al., 2006), and web technologies.

Since the identified LP architecture will be stored and monitored in resource-constrained mobile devices in terms of a set of ECA rules, it is significantly important for such rules to be efficient in a way that would minimize the number of required ECA rules. A naïve approach for generating ECA rules that capture an LP architecture of n rows and m columns would result in n × m ECA rules, where each cell is captured by an ECA rule. However, such an approach results in the generation of a large number of rules, many of which are very similar.

DelDroid generates ECA rules more efficiently. As for ICC ECA rules, i.e., the rules that capture the explicit and implicit communication domains of an LP architecture, if a component has no legitimate reason to communicate with any component of another app, DelDroid generates only one ECA rule that entirely prevents that particular component from communicating with that app. This, in turn, reduces the number of generated ECA rules from the number of components in the target app to merely one ECA rule. Similarly, if no component of an app is allowed to communicate with any component of another app, DelDroid generates just one ECA rule that prevents all components of the former app from communicating with components of the latter app. Generating ECA rules in this way not only reduces the number of generated rules but also makes the search process for an ECA rule governing a specific component or a specific app faster. Once DelDroid finds a coarse-grained ECA rule, i.e., a rule that restricts one app from communicating with another app, DelDroid stops the search and executes the action specified in that ECA rule.

In the case of resource access ECA rules, i.e., ECA rules that capture the Permission Granted Domain, DelDroid generates resource access ECA rules only for the granted permissions, i.e., ECA rules that capture only the “1”s in the Permission Granted Domain. It is worth mentioning that, in Android, it is possible for one permission to protect more than one system resource. In such a case, DelDroid generates more than one resource access ECA rule per granted permission. For example, the android.permission.READ_PHONE_STATE permission is required to request CARRIER_CONFIG_SERVICE in order to access the carrier configuration values, and the same permission is required to request the TELEPHONY_SERVICE to access the TelephonyManager, which provides access to information about the telephony services on a device.

This step regulates component interactions by enforcing the LP architecture at runtime. DelDroid efficiently transforms the LP architecture to a set of Event-Condition-Action (ECA) rules suitable for rapid evaluation as the system executes. It then relies on two components, i.e., ICC Monitor and Resource Monitor, within the Privilege Manager layer that we have added to the Android runtime environment, as shown in Fig. 2.

# 4. Efficiently generating ECA rules
Event-condition-action (ECA) rules allow the system to automatically perform actions in response to events given that the stated conditions hold. Each ECA rule reads as follows: “when an event occurs, check the condition, if it holds, execute the action”. ECA rules make the system efficiently adapt while the rules are stored in a single rule base instead of encoding them in many modules, thus improving the maintainability and the manageability of the system. ECA rules have been widely used in the literature, including self-adaptive systems (Huebscher and McCann, 2008; Bencomo et al., 2012; Kramer and Magee, 2007), databases (Widom and Ceri, 1996; Paton and Díaz, 1999), business process.

# 4. ICC monitor
This component extends the capabilities of the Android framework by intercepting each ICC transaction passed to the ActivityManager—an Android component that administers the ICC transactions—to check whether the transaction is allowed to run or not. Specifically, DelDroid extends the ActivityManager to send the ICC transaction’s information to the ICC Monitor component and executes the action provided by ICC Monitor. In case an ICC is prevented, ICC Monitor records the transaction for further inspection by a security analyst.

For example, the following ECA rule is produced, from the LP architecture shown in Fig. 4, to prevent the LevelUp component from communicating with the Sender component:
Event: i ∈ ICC occurs
Condition: i.senderP kg = FunGame ∧ i.senderComp = LevelUp ∧ i.receiverP kg = Messaging
Action: prevent
M. Hammad, H. Bagheri and S. Malek / The Journal of Systems and Software 149 (2019) 83–100
At runtime, when LevelUp tries to communicate with Sender, line (17) in Listing 2, the Android framework passes the request to the ActivityManager which sends the ICC transaction’s information (sender, receiver, and the Intent’s attributes) to the ICC Monitor component. After that, ICC Monitor vets the ICC transaction in light of the stored ECA rules. If a matched ECA rule is found, ICC Monitor prompts the ActivityManager to execute the associated action (prevent the communication in this particular example).