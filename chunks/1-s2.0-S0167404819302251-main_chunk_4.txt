J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
Sr5 &lt;android.os.Build: java Hlang String BRAND&gt;
Sz0 virtualinvoke Sr5.&lt;java lang String: boolean equals(java lang Object)&gt; generic" );
Szo = 1
520I= 0 Sz0
TRUE System exit(0);
FALSE
Sr5 &lt;android.os Build: java lang String BRAND&gt;;
Sz0 virtualinvoke $r5.&lt;java lang String: boolean equals(java Hang Object)&gt; generic_X86");
Jiang, 2012). Such components are called by Android when the event for which the component subscribe occurs. Therefore, the suspicious code present in these components may not execute during dynamic analysis. Android 8 supports 191 different broadcast actions and 26 different service actions. Simulating these large number of events during dynamic analysis is not practical and acceptable. Only the events relevant to app under analysis can be simulated. AppsPlayground  artificially raises few system events like boot completed event by using a fast reboot of VM. However, the approach causes system inconsistencies and it is not possible to simulate all events artificially.

One solution for this is proposed in Dynodroid , which instruments Android SDK for observing the system events registered by app. The instrumented SDK is loaded along with emulator which observes broadcast receivers and system services. Thereafter, the appropriate intent along with random data is serialized and events are triggered by modified Activity Manager tool (am). The modifications are done to add support for all types of arguments, which were missed in original am tool. The principal limitation of DynoDroid  is that for finding system events registered by app and thus the components registering these, SDK modification is required, which is not generic for all versions of Android. In contrast, EspyDroid+ gets the name of these components and corresponding events through previous steps and then instruments the code for sending intent to each of the component class in UnlinkedStates in Jimple. The intent for a specific component is constructed with a specified action and corresponding intent data with valid random values. This data is used in constructing putExtra and putString calls.

The selection of instrumentation point is done based on the type of unlinked component. The intent for receivers and services are added in launcher state while the intent for activity is placed in final state. This is because non-GUI components work in background through launcher without affecting the app’s original functionality. While linking activity may affect the app’s original functionality therefore, we add intent for unlinked activities in final state, which has path from launcher. The preference is given to the final state, which is not having any outgoing transitions to preserve the app’s original flow. However, if no such final state is found then any final state with the least number of outgoing transitions is selected. For the example of Fig. 1, explicit intent is added as shown in Fig. 8 by the dotted arrow from state 1 to state 4. The overall effectiveness of RGSS depends on relevancy of app code with respect to analysis target.

# 3. Intelligent UI exploration
We leverage Intelligent UI exploration module from our earlier work  along with some improvements. The approach is black-box developed by extending the Robotium framework . The exploration time depends on the complexity of app GUI. The average exploration time for the experimental data-set of 40 apps as measured in  was 6 minutes. In comparison, when the same dataset’s
# 8
J. Gajrani, U. Agarwal and V. Laxmi et al. / Computers & Security 90 (2020) 101688
sliced apps by EspyDroid+ were used for testing, the average exploration time reduced to 3 minutes.

In , we compare our earlier Intelligent UI testing approach with Android Monkey in terms of Class, Method, Block, and Line coverage using Emma tool EMMA on 40 open source apps from F-Droid (Free and Open Source App Repository, 0 0 0 0). We selected F-Droid dataset for comparing coverage of dynamic analysis as Emma requires source code of apps undergoing testing. The average coverage on 40 apps in percentage for Class, Method, Block, and Line by Monkey is 55, 47, 33, and 35 (42) while for our approach, the coverage is 58, 50, 42, and 40 (47) which shows improvements of our dynamic analysis over Android Monkey.

We could not compare with most relevant and contemporary dynamic analysis framework Harvester  results on same dataset as Harvester is not available in public domain and the apps are not open source. DROIDPF , another relevant work presented dynamic analysis results in terms of exploration time and property violation and not especially focused on coverage of reflection APIs.

The main objective of this work was to improve precision of dynamic analysis presented in our earlier work . We improve the Intelligent UI Exploration in two ways. First, we do not want app to terminate execution if proper text inputs are not given. Therefore, we propose to generate validation complaint text input e.g., email-id, date, phone number, etc. Instead of generating completely random input, we provide domain specific input by maintaining database of valid inputs corresponding to possible labels/hints available for these inputs in app. Second, we employ error detection and handling module. In earlier works, no consideration was given to UI exploration terminating due to any error encountered in app. This resulted in many prematurely terminated unsuccessful runs in dynamic analysis. We augment a solution to detect errors and start the exploration again taking care that erroneous inputs are not repeated. The widgets which cause abnormal app termination due to invalid input or event, insufficient data etc. during execution are recorded and it is ensured that erroneous views are ignored in subsequent runs. This avoids unnecessary and unsuccessful execution of apps.

From implementation point, we create SharedPreferences for the app under test and store the information of all widgets causing termination in that. The reason of choosing SharedPreferences is because it does not require any permission. The SharedPreferences is created with values initially set to null during first run. Each time before performing any action on any widget, it is confirmed that the widget is not present in the SharedPreferences. Before exploring particular widget, the necessary information to identify that widget is printed to the system logs. If the app terminates with exception then the information from logs is stored to SharedPreferences so that the same can be ignored in next execution. The execution of app starts again with the updated SharedPreferences file.

# 3. Reform reflection APIs
This phase constructs the code statements that use reflection by their semantically equivalent non-reflection way (traditional Java calling) and instrument these in the original app . The automated instrumentation is done in Soot’s intermediate representation Jimple using dynamically obtained parameters. The non-reflection calls are simple Java calls to these methods constructed with the obtained values of corresponding parameters. The instrumented code before reflection call A of activity A is as shown in Listing 1. The instrumentation allows off-the-shelf static analyses tools such as FlowDroid , IC3  to correctly interpret originally obfuscated behaviors, which were missed by these tools while analyzing original apps. The original reflective calls are not removed while instrumenting new calls.

# 4. Implementation and evaluation
RGSS is implemented on top of Soot . Step 1 finds ICC transitions by leveraging DialDroid  which is also based on Soot. We design a parser module to process and store the results of DialDroid as Maps (key-value pairs) having caller component name + method name + (i.e., instruction) as key and callee as value. Both Pruning of Irrelevant Transitions (Step 3) and Constraint Handling (Step 4) use Jimple Transformation Pack (jtp) of Soot during instrumentation. We performed all the evaluation on Intel E5-2420v2 2 GHz processor with 80 GB memory.