Considering both sets of apps and focusing on those with their parameters successfully recovered by OPTool, we further analyze the 1,520 (1,061 + 459) apps with open ports in the next two subsections.

# D. Detection of Open-Port SDKs
Out of these 1,520 apps, we are able to detect 13 open-port SDKs that affect at least three apps each in our dataset. Table III lists their details, including the class pattern (we use “%” to represent obfuscated fields), the Android Logcat tag (if any), raw open-port parameters, and the number of affected apps. Note that the app number here is the number of apps that actually invoke the SDK code, because some apps may embed an open-port SDK but never invoke it. For example, we found a total of 1,110 apps embedding Facebook Audience Network SDK  but only 897 of them triggering the SDK code.

These SDKs are invoked in 1,018 apps (a few apps embed multiple SDKs), and only 581 open-port apps are not affected at all. In other words, 61% of the 1,520 open-port apps are solely due to SDKs, among which Facebook SDK is the major contributor. Even after excluding the impact of Facebook SDK, we could still count 117 (16%) open-port apps that are solely due to SDKs. These results indicate that SDK-introduced open ports are significant and should be considered seriously in terms of their necessity as we will discuss in Sec. VI.

We take a closer look at Table III to see what kinds of SDKs introduce open ports and whether it could raise an alarm to developers. We find that only three SDKs, the UPnP SDK from CyberGarage  and two mobile push SDKs , , are networking related. The others are about advertisements , , ,  (e.g., Facebook and Yandex), Javascript generation , , ,  (e.g., App Inventor and PhoneGap), gaming engines  and map navigation . Hence, we argue that developers could hardly realize the existence of these open ports by simply examining their functionality.

# E. Identification of Insecure API Usages
We further analyze the 581 apps whose open ports are not introduced by SDKs, and their corresponding 869 open ports. We find that 515 port constructions did not set the IP addr parameter and 96 ports set it as “null”. Hence, the default setting of addr, i.e., the ANY IP address, is automatically used for these ports. In total, these convenient API usages account to 611 open ports from 390 apps (67%). Furthermore, 164 of these ports (coming from 120 apps) have their port parameter set as random, which has nearly no chance of being able to accept external connections and thus binding to the ANY IP address clearly increases their attack surfaces. This translates to a (lower bound) estimation of 26% of the 611 convenient API usages being insecure, and correspondingly 20% (120/581) open-port apps adopting convenient but insecure API usages.

Such an insecure coding practice is not limited to app developers but also SDK producers. In Table III, six SDKs make a random port yet using the default addr parameter binding the port to ANY IP addresses. Hence, Google may reconsider the design of ServerSocket APIs to enhance its security at the API level.

# V. SECURITY ASSESSMENT
In the last phase of our pipeline (Fig. 1), we perform comprehensive security assessment of open ports in three directions: vulnerability analysis in Sec. V-A, denial-of-service attack evaluation in Sec. V-B, and inter-device connectivity measurement in Sec. V-C.

# A. Vulnerability Analysis of Open Ports
According to our experience of analyzing open-port vulnerabilities over more than two years, it is easy for open-port apps to become vulnerable, especially for TCP open ports that do not provide system networking services as UDP open ports (as explained in Sec. III-C1). Therefore, instead of developing tools to detect individual vulnerable open ports, we attempt to uncover vulnerability patterns in popular apps that are usually more representative and more difficult to detect. Hence, our vulnerability analysis is quite different from the previous work  that uses pre-defined pattern for vulnerability detection. Instead, we explore all possible ways in which an open port could become vulnerable, as long as they fit our threat model discussed in Sec. II, by performing in-depth reverse engineering via the state-of-the-art JEB Android decompiler  and extensive dynamic testing.

Table IV summarizes the five vulnerability patterns we have identified. The first two have been reported in , while the third is a new variant of the crash vulnerability mentioned in the traditional Android app security research . The last two have not been reported and they are specific to open ports.

# TABLE IV: Vulnerability patterns identified in open ports.

# P1: No or insufficient checks for information transmission.

One major usage of (TCP) open ports is to transmit data to the connecting parties. However, apps may employ weak authentication or even no authentication, which allows unauthorized access to sensitive contents. We identify this type of vulnerabilities in ES File Explorer, Cloud Mail.Ru, and a popular photo/video hiding app called Vaulty. For example, Cloud Mail.Ru’s TCP port 1234 leaks users’ videos at http://127:1234//filename, where the name can be leaked by eavesdropping Cloud Mail.Ru’s broadcast messages . Similarly, Vaulty leaks users’ sensitive videos and pictures to a remote adversary through port 1562, and the adversary does not even need to know the target filename because only an integer starting from one is required. ES File Explorer’s always-on TCP port 59777 performs some security checks by validating the IP addresses of incoming requests with a white list. However, there is also an implicitly exposed  Activity component for adding a remote adversary’s IP address to the white list.

A particularly interesting example is Samsung Gear and other built-in apps based on the Accessory service  mentioned in Sec. III-C. Samsung Accessory provides an automatic (service) discovery feature via TCP port 8230, but replies with sensitive information, e.g., GT-I9305;samsung;UserName(GT-I9305);SWatch;SAP_TokenId(omitted), to any connecting party. Generally, it is important, yet challenging, to return only appropriate information in such UPnP-like apps (e.g., 19 apps using CyberGarage UPnP SDK; see Table III).

# P2: No or insufficient checks for command execution.

Another usage of open ports is to execute commands sent by authorized clients. We can see such open-port usage in Tencent XG Push SDK for executing push commands and the Coolpad V1-C phone’s vpowerd system daemon for shutdown and reboot commands. However, the command interfaces in both cases are not well protected.

We also notice that some open ports are used as a debugging interface. For example, MIT App Inventor  and Titanium SDK  in Table III use open ports for instant debugging or the so-called living programming . This debugging interface, however, must be disabled in release versions; otherwise, sensitive debugging information could be leaked. For example, Baidu Root, a popular rooting app in China, suffers from this vulnerability in its TCP port 10010 (bound to the host IP address).

# P3: Crash-of-Service.

Apps could crash when receiving malformed inputs from their open ports — we call this Crash-of-Service (CoS). Traditionally, Android apps suffer from CoS due to inter-component communications . Now open ports provide a new channel for launching CoS. For example, we can crash Instagram by sending it an invalid HTTP URL via the open ports. We also find that SIP VoIP apps (e.g., built-in apps using the standard VoIP port 5060 as discussed in Sec. III-C) could be victims of CoS attacks. Here we analyze Skype voice/video calls’ VoIP-like mechanism — it uses one UDP port for receiving control messages from a Microsoft Azure server, and another UDP port for exchanging media data with the other Skype user in a P2P mode. Unfortunately, a remote adversary can terminate the ongoing Skype session by just sending two packets to the first UDP port. This leads to a very effective CoS attack without even involving application-layer packets.

# P4: Stealthy data inflation.

Many open ports are for caching purposes (or as connection proxies in VPN apps). For example, Facebook SDK uses its open ports to cache video-based advertisements. Individual apps, such as Instagram, can also build their own cache servers upon an open-source library called AndroidVideoCache . Since these apps typically support opening arbitrary URLs via the open ports, one can easily launch stealthy data inflation attacks. Specifically, an adversary can send special URLs, e.g., an URL pointing to a large file, to maliciously inflate victim apps’ cellular data usage in the background. This process is fully stealthy without catching user attention, and the data usage is attributed to the victim app.