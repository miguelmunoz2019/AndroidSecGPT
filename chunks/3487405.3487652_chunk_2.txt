Another category of events is system events, also called broadcast actions. This could for example be "new picture", where each app can sign up for to be notified when a new picture was taken. The signin for around 300 of such broadcasts was formerly required be stated in the AndroidManifest.xml of each app. Currently, apps can also dynamically signin for broadcasts during runtime. These broadcasts trigger methods which are usually never reachable during interaction via the app’s UI. For comprehensive dynamic app analysis, the different registered broadcasts should be triggered and the app’s behavior observed.

# Dynamic Android App Vulnerability and Privacy Analysis
# EICC, November 10–11, 2021, Virtual Event, Romania
Since the intention is to build app stimulation, which repeatedly tests applications, it is desirable that the observed results and therewith the interaction sequence remains constant for the same app version. Additionally, a record and replay functionality would be useful to be able to also manually inspect analysis results (hinted as "Interaction Logger" in Figure 1).

# 3 App Behavior Monitor
We leveraged OWASP Mobile Top 10 (W) and the Appicaptor Security Index (W) to identify common vulnerabilities of apps. By far the most common security vulnerabilities are unprotected communication such as http instead of https access, faulty certificate validation in self implemented trust managers used in SSL/TLS communication or insecure encryption usage. For the aspect of privacy it is relevant to check the usage of data stored on the phone such as: contacts, messages, call history, . . . but also device properties such as: GPS location, connected WiFi/Bluetooth networks, . . . or installed apps. The usage of these properties needs to be tracked during behavior monitoring and in a second stage evaluated.

During UI stimulation, one needs measures to observe what the app actually does in the background. Therefor, different points of action exists. Like shown in Figure 1 the Android system has a layered architecture and in-between each layer there is the possibility to intercept the function calls. The higher the layer, the more abstract the function calls become. The highest layer is the Java API. For example the current GPS position can be requested via the API function locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER). Thus, intercepting this function would exhibit GPS usage and one could for example even read the GPS position and see if this location is sent over the network later on. The data identification can be accomplished since the provided data like address book entries or provided GPS location are set or known during the automated device interaction. Since data can internally be converted into other representations, like base64, hex and different hashing functions, the intercepted data would also need to be checked against these alternative representations.

The native libraries reside below the Java API. These libraries are compiled to the target CPU architecture and give a slightly abstracted interface to kernel functionalities as libraries. This also allows C/C++ app-libraries to run on Android through the Java Native Interface (JNI). However, using sensors through JNI takes a lot of boilerplate code to initialize the sensors compared to the Java interface and some sensors (GPS) are not covered through JNIW. In conclusion, intercepting native library calls is necessary to observe functionality of apps partly written in C/C++ but it can not replace Java API interception.

On the bottom layer is the hardware abstraction layer (HAL) and the kernel consuming so called system-calls. These system-calls handle for example threads, user rights management, file and file system interaction and sockets. Reading sensor data comes down to reading a specific file and configuring the sensor to write data to a file. Thus, calls to the Java API or native libraries are reflected in several system-calls. It is not possible to filter or log all system calls due to the immense call frequency. Thus, we don’t recommend intercepting system-calls or make it very selectively and carefully.

# 3 Network Monitor
Even though network traffic could also be observed through API calls in the operating system, it might not be the most convenient way. Using for example a proxy server as network monitor lets one easily observe called addresses, the content of the transmission and if the requests are protected. It is also fairly easy to check for the usage of faulty trust managers, since certificates can easily be exchanged. As described in Section 3, it is also necessary to decode data in different data formats.

# 3 Control Logic
The control logic is thought of as the central element controlling the others. The control logic should on the one hand trigger the app stimulation and on the other hand set up appropriate hooks in the API and Network Monitor to observe the behavior triggered by the app stimulation. At the end of the interaction, the different logged information about app stimulation and API calls have to be correlated and security vulnerabilities or privacy frauds detected.