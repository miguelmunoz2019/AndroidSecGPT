At a high level, we can see that game (A) verifies the payment receipt from payment providers locally with API validator.Validate (line 11). Note that this API uses the public key of the payment provider (acquired by GooglePlayTangle.Data() at line 7) to verify the signature of the receipt.

# 3 Challenges and Insights
In this study, we focus on two vulnerable in-game purchases: lack-of-verification (i.e., no-verification) and local-verification. Since in both cases it refers to how data is used, obviously we need to leverage the meanings from the APIs to infer the semantics of the data use of the receipt as well as its propagation. For instance, as shown in Figure 4, we can easily detect the receipt is validated locally if the app uses Validator.Validate, it is logged if Debug.Log is invoked, it is sent to the server if it is passed to API UnityWebRequest.Post, and so on. Therefore, we have to solve at least two challenges: (i) pinpointing specific APIs in the game binary, and (ii) tracking the data flow  of the payment-data.

# (I) How to pinpoint target APIs in game binaries.

APIs are crucial to infer the meaning of the data use. However, unlike with source code where we can see the names of variables and APIs and easily infer the semantics of data-use, for binary analysis, the input is often just hexadecimal code and data, and there are no symbol names as they can be stripped. Therefore, we have to reconstruct the high level abstraction from the binary code and recognize the specific APIs of our interest. Interestingly, due to the nature of how Unity binaries are compiled and executed, it has surprisingly made the symbol recovery easier. Specifically, the association between the method name including APIs and the entry address has actually been recorded into the metadata file (i.e., global-metadata.dat), which keeps all the missing symbols including even class names that are optimized by the compiler of Unity SDK. Although the metadata file is not directly readable, we can parse it with tool Il2CppDumper  to extract the information we need. The details of how we extract the function and classes metadata is presented in §4.

# (II) How to identify the payment-data definition, use, and their propagation.

Apparently, we need a payment-aware data flow analysis to identify the data-definition, propagation, and data-use of the payment receipt returned by the app store. While the use of P-Code has made the development of our analysis easier, we still have to locate the instructions that define the payment data, the propagations of the data (including through JSON object parsing and creation as shown in ...

USENIX Association 31st USENIX Security Symposium 3097
# Address Function Name
# Address Machine Code Disassemble P-Code Output Opcode P-Code Input
# Index Tag Type Class Tag Index Tag Type Class Tag
# Shadow Memory at {1} GCT Shadow Memory at {2} GCT
To identify the payment data definition, we can rely on the key APIs such as args.purchasedProduct.get_receipt. While directly identifying the payment data propagation inside JSON parsing functions is challenging, we can skip the detailed analysis inside these functions and instead use the API summary (an approach that has been widely used in many other applications such as symbolic execution ). To infer whether a class field (typically organized as an abstract base address plus an offset) stores the payment data or its prop-agations, we can design a taint-tracking algorithm for class field based on the taintedness of return values or arguments of well-defined APIs. Finally, to infer whether a field belongs to a particular class, we can use backward slicing  to iden-tify the base address of the class, and then identify the class types using the argument types of functions extracted from the metadata. The details of how we perform our payment-aware data flow analysis is presented in §5.

Also, note that due to the nature of how game binaries are generated with Unity SDK, we have all the symbols of binary functions and classes, and we do not face the hard problems as in traditional binary analysis such as the aliasing. In particular, since the game binaries are translated from C# to C++ and there is no global variable in C#. The only data flow is through the access of fields of classes. For example, in Figure 4 (C), the field m_LastReceipt of class unityInAppPurchase_LS has been assigned with the payment receipt at line 8, and the
3098 31st USENIX Security Symposium USENIX Association
# data flow should continue from any other instructions that read this field. Since we have the symbols and their types, we can pinpoint exactly the class name of each variable in all the functions. As such, we can simply locate variables that are of type unityInAppPurchase_LS and continue analyzing from there to find out which instruction accessed field m_LastReceipt through a lightweight type-based data flow analysis.

# 4    Metadata Extraction
Since a game built with Unity contains rich information in file global-metadata.dat about its function signatures (types of arguments and return value) and class definitions (including fields offset and their types) of the final executables due to the use of IL2CPP, we can leverage this information to facilitate our payment-aware data flow analysis. In the following, we describe how we extract such information.

# Extracting function metadata.

The metadata of a function includes the starting address of the function, the type of the return value, the number of arguments, and the corresponding type for each argument. All of this information can be retrieved from global-metadata.dat. There is also a function name associated, and this name reveals both the original C# Class and function, from which this function was translated. As mentioned earlier, while global-metadata.dat cannot be directly read, we can use tool IL2CPPDumper  parse it. Since the function address is static, we store the extracted functions and their types in a global function table GFT, indexed by the address.

With the extracted function argument type, it makes our interprocedure analysis much easier. More specifically, assume we have identified a class type of our interest, then we can directly scan our GFT to locate all of the functions that have an argument referencing this class, and these functions are all possible callees. Meanwhile, we also scan all functions to identify each possible caller that has invoked these callees. The instructions of both identified callers and callees will be iterated again to identify whether there is any data-use of the payment data (and its propagations), as well as propagation of the payment data to any other class objects if there are any.

Some examples of the extracted functions and their types can be found in the top half of Figure 5. For instance, in running example (B), the function at address 0x02509f9c is UnityEngine.Purchasing.Product.get_receipt. From this function name, we can easily identify that this function was translated from the C# function get_receipt of C# Class UnityEngine.Purchasing.Product and the type of its return value is System.String.

# Extracting class metadata.

Unlike function’s metadata where we can extract the function’s address, class’ metadata is just the abstract definition of the class, and there is no concrete address associated. What we can extract only includes the class name, the field offset, and the field types. We use the class name to index them, and store the extracted class types in a global class table GCT, which will be updated to record the taintedness whenever a class field stores tainted data.

# 5     Payment-Aware Data Flow Analysis
In order to identify the vulnerable payment verification, we need to first identify where the payment data is defined (§5), how it propagates (§5), and whether the propagated data is sent to the server (for server-side verification), or used by local-verification APIs, or no-verification at all (§5). In this section, we present the details of our lightweight payment-aware data flow analysis.

# 5      Identifying Payment-Data Definition
Since we need to track the data flow of the payment receipt, our taint sources should be the APIs that receive this data. After systematically examining the documentation, we found that UnityEngine.Purchasing.Product.get_receipt is the only API that can be used to access the receipt. As such, we focus on this API exclusively as the taint source. More specifically, we first find the address of this function by checking the extracted metadata in the global function table. For example, in Figure 5 (A), by looking up the corresponding GFT, we find its address is 0x02212258. Then we locate the callers of this function by traversing the call graph of the game binary. There might be several callers and each of them will be located. At each call site, the variable assigned with the return value (i.e., receipt) of this function call is the source of the payment-data.