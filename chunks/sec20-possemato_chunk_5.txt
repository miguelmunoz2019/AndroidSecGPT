# Domain example.com and Invalid Digests
Another peculiar configuration comes from apps using the domain example.com within their policy. We identified this interesting configuration from a cluster of 41 apps. However, there is, of course, no need for an app to protect this domain since this example.com domain is clearly not relevant. Thus, we looked for similar apps and we found out that in total, other 58 apps use this domain, 48 of which come from 7 different clusters. We then found that these policies are copied verbatim from the Android Developer website and from StackOverflow. We tracked down the original policies combining both the domain name and the unique digests defined in some of the policies. These policies define certificate pinning on example.com or with invalid digests formed by “B” repeated 44 times (see the Appendix for the complete policies). We believe that there are two possible explanations to justify the adoption of these (useless) policies. In the first one, the developer wants to define one specific feature of the policy: she then copies an existing policy that contains both the requested feature and the unique configuration of certificate pinning. In the second one, this policy might have been used by a developer who was looking for a certificate pinning implementation and she copied the first available policy. While copying security policies that contain “dummy” domain names such as example.com is not a security problem per se, we believe that these policies may create a false sense of security in the developer’s mind: the developer may wrongly believe that certificate pinning is correctly implemented in her application, while, in fact, it is not.

# Certificate Pinning
Certificate pinning increases the security of the communication ensuring integrity, confidentiality, and authenticity. Thankfully, implementing certificate pinning via
NSP is now much simpler than it was in the past. However, we found that only 102 applications enforce it through the policy. Out of these 102 apps enforcing certificate pinning, an interesting cluster is constituted by apps that implement pinning but then mistakenly override it. We identified 9 apps that specify one or more pin-set, but set the overridePins attribute to true, making the various pin-set useless. We argue that it is very likely that the developer is not aware of it, otherwise she would not have specified any pin-set entry. We believe Android Studio (or other IDEs) should flag this kind of policy as potentially misconfigured.

# Invalid Attributes
We identified a group of apps defining attributes that are not specified within the official documentation . For example, we identified two apps defining the usesCleartextTraffic attribute in the policy (even if this is only valid in the old version of the NSP), or two apps defining the cleartextTrafficPermitted attribute within a wrong node. We also found one app declaring the hstsEnforced attribute, which is not mentioned in the official documentation. However, by looking at the source code of the policy parser, we notice how this attribute is actually recognized as valid. This attribute allows a developer to define HSTS for the WebView component of her application (which would “force” the WebView to always contact via HTTPS websites sending the HSTS header ). We note how the concept of HSTS significantly overlaps with the cleartext aspect of the NSP. We investigated the reason why this attribute is still available within the NSP and we found out that it may exist because older versions of the WebView were not enforcing the cleartextTrafficPermitted attribute  (but were enforcing HSTS instead).

# TrustKit
The cluster of policies defined using TrustKit is formed by 53 apps. Among these apps, 10 define a reporting-endpoint to use when a pinning failure is identified, while 16 apps explicitly disabled this feature. To conclude, 46 apps define certificate pinning within the policy.

# Remaining Apps
Our methodology based on clustering and targeted queries allowed us to systematically group a vast portion of our dataset. However, as we mentioned, 311 apps did not fit any cluster. We then manually inspected them all, to look for additional interesting patterns. Among these, we identified 98 apps that define a very unique policy in terms of domain nodes used with the policy. The other 46 apps shared a specific policy that did not take advantage of the “wrapper nodes” like pin-set or domain-config: for each of the domains, these apps opened a new domain-config node each time instead of defining all the domains within one node. We also found 44 apps that specify more than one custom certificate. Another interesting configuration comes from apps whose policy appears very verbose and that could have been reduced. We noticed how 32 applications specify a default “allow cleartext” for the entire app and, on top of that, configured a very detailed list of domains and subdomains with the same exact policy. 21 applications defined additional text (like comments or left-over in between nodes) that is then removed by the system during the parsing process. To conclude, the remaining apps defined very unique and complex policies that do not belong to any of the aforementioned groups, but that, from the security perspective, do not represent anything special.

# Dataset Evolution
Starting from November 1st, 2019, all apps must target at least API level 28 . This means, from a NSP perspective, that all the new apps, by default, will forbid cleartext. Since our dataset was crawled before November (see Section 5), we decided to repeat some of the measurements, this time on a dataset downloaded after this new mandatory requirement. Our goal is to investigate how the apps evolved after the introduction of the new default value that forbids the usage of any cleartext protocol. We started a re-crawl of the same initial dataset, starting from the 125,419 package names. These apps were re-crawled from April to June 2020. We were able to download 86% of the initial dataset, for a total of 108,542 apps. Of the remaining apps that we could not re-download, 15,749 apps were removed from the Google Play Store and 1,128 apps moved from a free to "paid" download or introduced in-app purchases not available in our geographical region. The apps that we were able to re-crawl are distributed as follows: the 14% of the apps (15,531) target an API level 29, the 46% (50,191) instead target a level 28, 9% (10,351) the level 27, 12% (13,795) level 26 and the remaining 17% (18,674) target an API level 25 or lower.

Unsurprisingly, the number of apps defining a NSP increased: 33% of the apps (36,165) now specify one of the two types of NSP. Among these apps, the 65% (23,718) still adopts the first version of the NSP through the AndroidManifest, while the remaining apps (15,492) opted for the new and more recent version. Interestingly, 8% of the apps (3,045) use both versions of the policies.

We then looked for how many apps effectively adopted the new default of forbidding cleartext protocols for the entire application: surprisingly, approximately the 33% of the entire dataset (35,789 out of 108,542) enforced a default configuration that does not permit cleartext protocols. Out of these apps, 419 used the first version of the policy. The remaining 67% of the apps still configure a NSP that permits cleartext traffic. From this 67%, the 32% (23,229) still adopt the first version of the policy. However, what it is interesting to notice is that 58% (42,353) of apps allow cleartext due to default configuration, dictated by the API level. To conclude, we note how only a small portion of apps, the 0% (349), allow cleartext as base configuration and also define a set of domains for which they allow only encrypted connections.

These results somehow highlight an ecosystem-wide problem that affects Android apps: even if Google provides a simple and easy way to configure the SSL/TLS for an app (the NSP), and even though it explicitly changed the defaults to force the usage of cleartext protocols, a significant portion of apps still opt to stick, for one reason or another, to plain and unencrypted networking protocols: while the community is making progress, we are not there yet for a full adoption of HTTPS by Android apps.

# 5 Android Networking Libraries Adoption
So far, this section has focused on the exploration of how apps adopt NSPs. However, we did not tackle the aspect of enforcing these policies. The NSP is simply an XML configuration file, and it is then up to the various network libraries to properly honor (and enforce) what is specified by such configuration file.