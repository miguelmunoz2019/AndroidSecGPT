Communication infrastructure, which is indispensable to banking apps . It establishes a channel to communicate with remote bank servers. However, communication infrastructure is likely to be attacked, and hence it can undermine the security of these apps. The core functionalities in communication infrastructure include certificate verification, cryptographic operation, and host authentication. To accurately identify the functional code for communication infrastructure, we summarize all invocation patterns of multiple Android APIs for each functionality. Taking hostname verification as an example, if there is an invocation sequence {new X509HostnameVerifier, setHostnameVerifier of class HttpURLConnection}, we consider that the app uses hostname verification during communication. We further check its implementation to determine whether it implements correctly. We have 12 groups of API invocation patterns in total for function identification in communication infrastructure. We reverse-engineer banking apps, locate the invocations of these relevant Android APIs, and
# An Empirical Assessment of Security Risks of Global Android Banking Apps
ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
use call graphs and component transitions to determine their call relation in between. Finally, we can identify the functional code for communication infrastructure of banking apps.

# Security weakness detection.

Given a banking app, we attempt to find whether it contains any weaknesses listed in Table 1 and reduce false positives by employing the two strategies: (1) a forward data-flow analysis to determine whether there exists sensitive data flowing into insecure sinks by leveraging sensitive data tagging and taint analysis; (2) a backward control-flow analysis to check whether the vulnerable functional code identified by API invocation patterns in communication infrastructure is feasible based on call graphs and Activity transitions.

We carry on a forward taint analysis on top of Soot  to support intra- and inter-component communication analysis based on the tagged sensitive data. These data are regarded as sources, and the sinks are the Android API list we defined. During the process of functional code identification, we can obtain all vulnerable code (i.e., incorrect implementation) that exists in communication infrastructure. However, noise may arise because the dead code for testing purpose cannot be executed during runtime. Reaves et al.  found that the dead code may bring false positives to the detection results. We perform a backward control-flow analysis, and extract all reachable call sequences according to call graphs and Activity transitions. If the vulnerable code is reachable, we determine it is a valid weakness, otherwise, it is a false alarm.

We highlight the following three strategies to reduce false positives. (1) Ausera reduces the size of our extracted keywords from 124 to 70, which effectively reduces ambiguity of the keywords (e.g., “info” and “status”), and hence can identify sensitive data more accurately. (2) Ausera utilizes newly-defined sources and sinks, which are relevant to weaknesses of sensitive data leakage. (3) Ausera identifies the vulnerable code and checks its reachability to eliminate weaknesses in dead code by call graphs and Activity transitions.

# 2 Implementation of Ausera.

To implement Ausera, we combine static program analysis and sensitive data tagging to identify sensitive data in banking apps, and associate them with the corresponding variables in XML/Java code. Ausera relies on Apktool  to extract resource files from apks. It then uses parts-of-speech (POS) tagger of OpenNLP-1  to parse the text labels in TextView and EditText, thereby identifying keywords included. We manually check on these keywords to retain the ones that are sensitive and relevant to the core functionalities of banking apps. After that, we employ Word2vec to supplement the keyword database.

To accomplish the detection, we summarize 12 groups of patterns (e.g., AES/ECB/NoPadding) to depict the communication weaknesses. Then we employ pattern-based static analysis to find the possible vulnerable patterns in code. We check three aspects for certificate authentication: whether the client side 1) allows all hostname requests; 2) bypasses hostname verification; 3) fails to implement anything in the server verification method (checkServerTrusted). The weakness “hard-coded encryption key” is determined by first checking whether an encryption key is embedded in code, and examining whether it is used to encrypt sensitive data to reduce false positives. The banking sensitive data are encrypted with the DES or Blowfish algorithm. Using either of the encryption mechanisms is viewed as a weakness . The AES forbids ECB mode because it does not provide a general notion of privacy . The padding of AES and RSA is always improper, such as NoPadding and PKCS1, though AES/ECB/NoPadding is very frequently used. The function SecureRandom should not be seeded with a constant. The hash functions MD5 and SHA-1 are insecure.

# 2 Evaluation of Ausera.

We randomly selected 60 banking apps (12%) in our dataset and manually checked the detection results to evaluate Ausera’s precision. Note that, we cannot evaluate the false negatives when assessing banking apps due to lack of weakness benchmarks of banking apps. False positive (FP) refers to weakness that are detected during static analysis but actually infeasible at runtime or detected by mistake. As a result, we only found 6 false positives (corresponding to five weakness types, i.e., Shared Preference Leakage, Logging Leakage, SD Card Leakage, Text File Leakage, and Hard-coded Key) from the identified 341 weaknesses of these 60 banking apps, achieving an average precision of 98%.

Consequently, 5 out of 6 false positives belong to sensitive data leakage. The reason is that Ausera matches variables (e.g., “pkg-name.txt,” “login_fragment,” “loginpager,” and “spinnerGender”) inaccurately with the keywords in our database. The remaining one FP belongs to Hard-coded Key type, because the extracted variable is relevant to the exception parameters (i.e., “KeyPermanentlyInvalidateException”).

# 2 RQ1: Tool Evaluation and Data Collection
Banking app collection. As shown in Figure 1, we collected 693 banking apps2 in total from various Android markets such as Google Play store and APKMonk . Note that we only collect multiple versions of some apps from APKMonk to conduct the longitudinal analysis (cf. Section 3) since APKMonk maintains the full versions of apps, while Google Play store only maintain the latest version. The collected apps range across 470 unique banks, where some apps have multiple versions. They originate from both developed and developing countries across five continents (see breakdowns in Table 3). Table 3 indicates that 48% of the banking apps are from Asia, considering the largest population proportion all over the world. Only 3% of apps are from Oceania, considering its smallest population proportion all over the world. The 24 banking apps of American developing countries all originate from South America, while 16 apps of Oceanian developed countries originate from Australia and New Zealand. 16 apps of Asian developed countries.

2 Apart from the 693 apps, we have filtered out apps with packer techniques (49 apps in total) and with decompilation failure since they are out of scope in this paper.

# ICSE ’20, May 23–29, 2020, Seoul, Republic of Korea
# S. Chen, L. Fan, G. Meng, T. Su, M. Xue, Y. Xue, Y. Liu, and L. Xu
originate from Singapore, Japan, and South Korea. To our knowledge, this is the largest banking app dataset taken into study to date.

# Comparison with the state of the practice
We compare the detection results of Ausera with 4 industrial and open-source tools, including Qihoo360, AndroBugs, MobSF, and QARK. We randomly select 60 banking apps in our dataset for comparison and run each tool 3 times to stabilize the detection accuracy. Table 4 shows the results. Ausera outperforms other tools in both precision and time cost, achieving 98% precision in 1 minutes per app. The precisions for these tools are obtained by manual validation through filtering out all false positives. We also conduct a cross-validation of detection results across different authors. We can see that all comparisons of the detection results comply with the weaknesses baseline. Ausera outperforms other tools with higher precision and less time. Ausera manages to scan each app within 1 minutes on average, much faster than the other tools.

In particular, we show several specific cases to explain how false positives are incurred. Sensitive data disclosure through logging can be detected by MobSF, however, MobSF just matches the following APIs if used (e.g., Log.e(), Log.d(), and Log.v()), without further determining whether the output data is sensitive or not. There is no doubt that it would incur a large number of false positives. If the data is not sensitive, such as “menu_title,” it is very normal for developers to output it in the terminal or write messages to understand the state of their application. The risk is that some credentials (e.g., PIN and password) are also leaked by logging outputs. A syntax-based scanning tool may provide an incomplete and incorrect analysis result due to the influence of dead code. For example, Qihoo360 detected three code blocks violating server verification, e.g., do nothing in checkServerTrusted. In contrast, Ausera aims to minimize the influence of dead code. Two key strategies to eliminate such false positives are: (i) checking whether invalid authentication is in a feasible path in call graphs; (ii) checking whether the Class has been instantiated in Activity transitions.