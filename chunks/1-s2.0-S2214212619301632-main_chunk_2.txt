Although in-app payment is pervasive on Android and iOS, the process of how an app fulfills a transaction via third-party payment service is often obscure due to several reasons. First, implementation variation of in-app payment is significant. Different third-party payment service providers (cashiers) regulate different in-app payment processes and release their own SDKs for app to integrate. Implementation aspects of third-party payment services such as used web APIs, integration style of SDKs, and the parameters required differ greatly from each other. Second, cashiers often release documents and samples to app developers. However, our review illustrates that most of these documents are ambiguous and may confuse the app developers. Some code samples even conflict with the process regulated by the documents. Only by reading cashiers’ documents and studying their sample code is not adequate to conclude the exact payment process, and we will give our result in Section 5. Third, testing the in-app payment not only involves actual payment with money expending, but also requires some franchises and relevant documents only granted to verified identity such as registered companies. Many analysis efforts lack such qualifications and therefore are impeded.

To demystify the details of in-app payment process, we first give a brief description of participants involved in payment process. Then, we choose four popular cashiers: WexPay (in-app payment service provided by Wechat Wallet) , AliPay (Alipay Wallet) , UniPay (Unionpay Wallet)  and BadPay (Baidu Wallet)  and analyze their documents and code samples. We also reverse-engineer popular apps with in-app payment to understand the details of payment implementation. After this reverse engineering work, we gain a panoramic view of in-app payment process: two representative payment process models that cover necessary transaction steps for four cashiers are concluded.

# 2. Definitions
In a typical third-party in-app payment process, user browses, selects and buys commodities in a merchant app (MA). Implemented by the merchant, the MA and the merchant server (MS) interact with each other. Information such as users information, commodities provided, and order information are stored in databases on the MS.

To support payment in app, an MA integrates one or more third-party payment SDK (TP-SDK) released by the third-party cashier. In a checkout process, user chooses a third-party cashier in the MA and makes a payment to the cashier. The cashier server (CS) records the payment information and status, and informs the merchant the completion of the payment. The complete payment information is then stored to the CS.

Since cashier is the third party between user and merchant, the detail of the merchant order (e.g., unit price about the commodities) is not the necessary information for cashiers due to the privacy issue. Therefore, Apple’s IAP (In App Purchase) is not a typical third-party payment. Apple, as a cashier, requires merchants to register all the content and its price on its website. Merchants need to offer their merchandises through the cashier rather than by themselves throughout the transaction process. Thus, only the cashier is actually involved in the Apple’s IAP payment process. In addition, the strict restriction on the goods type regulated by Apple...

# 2. Unveiling payment process
To unveil the payment process, we conducted a systematic study against mobile payments in mainland Chinese market as our research target for the following reasons: First, it is the world’s largest smartphone and mobile payment market: about 890 million users in this market use mobile devices to purchase goods and services (by the end of 2018, according to research from the China Internet Network Information Center). In the year of 2018, China’s third-party mobile payment tools handled transactions worth more than 200 trillion yuan (29 trillion US dollar), much more than any other countries in the world. Second, unlike the mobile payment market in the U.S., where most mobile transaction is settled via credit card through web or Apple Pay, a large portion of apps use third-party in-app payment services in China. Third, instead of a single payment standard, most apps adopted a variety of payment schemes provided by different third-party cashiers simultaneously. Due to its sophisticated characteristic, mobile payments in mainland Chinese market is a very representative target and is worth being studied.

Another important fact for the mobile ecosystem of mainland China is that the official app store of Google (i.e., Google Play Store) is unavailable. As a result, many Chinese companies or developers chose to publish their apps on domestic app markets. Therefore, we also collected our app samples from these markets. We collected Android apps from Myapp , the largest Android app store in China . This market also provides strict ‘official’ certification service, which requires publishers to submit a series of materials to prove their copyrights . In addition, to collect iOS apps we have to address the encryption issue of the Apple’s official App Store (all apps downloaded from the App Store are encrypted and the analysis of such an app needs a decryption first). Fortunately, we found 25PP, a third-party iOS app market1 have collected decrypted version of most popular iOS apps. We therefore crawled this market to obtain the samples needed.

Note that in our study we did not download all apps in both Android and iOS app markets. The main reason is that only apps with larger number of users and transactions would integrate mobile payment services. We thus only chose those apps with either large download numbers or a relatively high impact. In particular, we download 7145 most popular Android apps with at least 100,000 users for each from Myapp, and 10,000 most downloaded iOS apps from 25PP. We argue that these apps are prevalent and representative samples for our study.

We choose four popular cashiers as our research targets: WexPay, AliPay, UniPay and BadPay. Each of them has at least 100 million users. Merchant can register to all four cashiers on two mobile platforms (Android and iOS) as long as it owns a legitimated company registered to the Chinese Commerce and Industry Bureau. For every cashier, we get the TP-SDK and auxiliary materials of Android and iOS including code samples and relevant documents. The documents describe not only interfaces of TP-SDK but also the suggested payment process and Web APIs of cashier server. Code samples illustrate simplified implementation for client app and server. Through studying the documents of four cashiers, reverse-engineering TP-SDKs and downloaded apps with static and dynamic analysis, monitoring the network traffic of the transaction process, and implementing sample code to real app and server, we have two observations about the in-app payment: (1) how prevalent is the third-party in-app payment on mobile platform; (2) which payment process model does merchant need to comply with when integrating third-party in-app payment function. We detail these observations in the following sections.

# 2. TP-SDK identification
In order to find out which app uses third-party in-app payment, we adopt feature based identification strategy to detect apps with TP-SDK. We reverse-engineer TP-SDKs of four cashiers on two platforms and extract their unique features. We observe that if an MA uses a TP-SDK, it needs to invoke a specific interface and passes parameters, hence we make use of these interfaces as the feature of TP-SDKs. For instance, if an Android MA uses TP-SDK of AliPay, it must pass the payment order information to AliPay SDK through a certain interface And for iOS apps, Alipay payment SDK also provide such interface For other three TP-SDKs, there are also similar features. Note that the name of interface is not always an available feature. Developers may use code obfuscation tools such as ProGuard / ios-class-guard  to obfuscate the function names in Android/iOS apps. Therefore, we manually pick a combination of special strings in every TP-SDK that are seldom used elsewhere as extra features. For instance, we find that WexPay uses specific strings,4 to label transaction data of payment request in its SDK, which are unique and can hardly be found in other SDKs. Similarly, UniPay always has such strings as5 in its SDK. Utilizing those features, we build static analysis tools to scan apps of Android and iOS respectively. Our tool is based on AndroGuard  for Android apps and Radare2  for iOS apps. The result is listed in Section 5.

# 2. Process analysis
After studying the documents and sample code of four cashiers, we registered as a merchant to cashiers and developed proof-of-concept apps and corresponding servers to better understand the payment processes adopted by the four cashiers. Besides, we even downloaded and analyzed several popular merchant apps and their servers statically and dynamically. We reverse-engineered the client apps (with IDA  for iOS apps and Android native code, with JEB  for Android apps), monitored the network traffic between apps and servers (with Burp Suite  for HTTP/HTTPS message, and Wireshark  for TCP/UDP-based protocol), hooked specific methods or functions to retrieve/modify runtime data of merchant apps (we have developed Xposed  and Frida  plugins for Android and iOS apps, respectively), and constructed customized network requests to cashiers and merchant servers.