# Defragmentation
Fragmentation can affect our inspection of network traffic because the standard MTU  of IP datagrams over Ethernet is 1500 bytes (same as in the WiFi interface ). Therefore, any IP datagram over 1500 bytes will be fragmented. As a result, we will not find PII values (if exist) that are split between multiple packets. To overcome this problem, we defragment to recover the original data of the fragmented TCP packets, and use the dpkt  library to parse TCP and UDP traffic data.

# Identifying encrypted data
We extract ciphertext values from cryptographic APIs (e.g., Cipher) and search them in lists created for all categories (i.e., HTTP, HTTPS, non-HTTP, file). If a ciphertext value is found in the content of any of the lists, we add its cryptographic parameters to a new list with the same name and an additional encrypted suffix. Apps can send the ciphertext in chunks. Therefore, we split the ciphertext into 18 bytes chunks (assuming 128-bit blocks), which reduces the chance of getting identical blocks by covering more than one block of a cipher text, prior to searching them in the lists pertaining to different categories.

# Search strategy
The content in the network traffic can be transformed into different forms. It is also possible that one (e.g., capitalize, upper case, lower case, Base64) or more (e.g., md5-hex — creates an MD5 hash with hex encoding, sha1-hex, sha256-hex, md5-raw, sha1-raw, sha256-raw) of these transformations are applied to the content. Therefore, we compile a set of values (e.g., PII, list of keywords, cryptographic keys and fillable content), and apply the mentioned transformations to each value in the set, and save them in a separate list, which we then use to search and identify privacy/security issues.

# Detecting insecure cryptographic parameters
We use apk-tool  to unpack APK files, and search the collected keys in different encoding formats (plain, Base64, hex case-insensitive) over all the unpacked content of APK files, to determine if any of the fixed keys are hard-coded (see Sec. 3). Thereafter, we collect the keys of the traced ciphertexts in the network communication or files. If we detect hard-coded/fixed (i.e., reused) keys from the network communication in multiple runs, and on the same or different devices, we mark them as insecure keys.

# App and system traffic separation
The captured traffic from tcpdump and mitmproxy may contain traffic from system processes running on a device, which is separate from the app traffic. To ensure that we only analyze the traffic of the target app, we filter the captured network packets using the collected network tuples by API hooking and their timestamps. We hook the process ID of the target app, to ensure system/app traffic separation — all hooks are at the app level.

# 5 RESULTS
In this section, we summarize our findings on privacy and security issues of Android apps that use non-standard and covert communication channels. Instead of choosing top-downloaded apps, which may not cover various app categories, we selected apps from Androidrank  for our evaluation. Androidrank ranks Google Play apps in 33 categories based on various metrics such as total downloads, total number of user ratings, average user ratings. We collected all available 15,522 unique free apps for our evaluation from all categories (note that there are overlaps between app categories). This dataset contains apps that are highly popular globally (e.g., 1B+ installs), but also apps that are top-ranked (within top-500) in a specialized app category with a relatively small number of installations (e.g., 10K+). ThirdEye could download 15,327 apps, and successfully analyzed 12,598 apps; the remaining 2729 apps failed for various reasons, e.g., app incompatibility with Android 12, geo-blocking, unknown reverse engineering protection, and app-crashing due to the use of Frida method hooking. We ran our experiments between Nov. 25, 2021–Jan. 6, 2022. We used two Android devices (Pixel 4 and Pixel 6) running factory images with Android 12, and a desktop running Ubuntu 21, Core i9-10900, 64GB RAM, 2TB storage. Most apps finished their execution (i.e., all their UI interactions were completed) within 5 minutes; we terminated the execution of 1329/12,598 (10%) apps at the 5-minute threshold. For a summary of our results, see Tables 1 and 2. We also provide several examples of prominent privacy/security issues from our findings in Sec. 7. We report some additional details on app installation statistics, app interaction duration, encryption types, weak ciphers, and network security results in the extended version of this paper.

We categorize privacy-sensitive data into Device, Network, Network Location, GPS Location, and User categories; see Table 1. We also label the likely use of the available data into Persistent ID, Short-term, Profiling, Location Data, and User Assets. Items labeled as Persistent ID and Short-term are generally used for tracking; Persistent IDs do not change with time, and Short-term items can identify a user for a short duration (can be used for long-term tracking if combined with other items). Profiling items can identify a user, or a user-group to a varying degree, the accuracy of which improves when combined.

# 5 Characteristics of encrypted communication
Prevalence of the use of encryption. We found that 6075/12,598 (48%) apps triggered encryption/decryption related calls from our Frida API hooking. From these apps, we identified 2887/6075
# NetworkGPSCCS ’22, November 7–11, 2022, Los Angeles, CA, USA
# Sajjad Pourali, Nayanamana Samarasinghe, & Mohammad Mannan
# Device Network User Assets Location
(47%) apps send network traffic, and use file storage with data originating from the hooked encryption/decryption calls; the remaining apps possibly use such calls for internal/local purposes. We found 4 apps that used two nested layers of encryption, although no relevant traffic was observed during our test window; e.g., com.mci.balagh (Ministry of Commerce of Saudi Arabia) app, hard-coded its remote server address in an encrypted form (nested), and subsequently decrypted twice. In terms of encryption type, we observed 2597, 598, 119 apps used symmetric, public key, non-SDK encryption, respectively.

Encrypted communication content. To identify the type of content sent over encrypted channels, we created a list of keywords (see the Data Type column in Table 1): device information used for tracking (e.g., network operator, build fingerprint), network information (e.g., device MAC), GPS coordinates in different accuracies, network location (e.g., via own/neighbor router info), and user assets (e.g., contact list, SMS). We also extract authentication tokens and session IDs embedded in JSON, XML, HTTP headers, form-urlencoded, and form-data data structures, besides authentication passwords (see the User Credentials column in Table 2). We did not verify the tokens used for User Credentials (except a few selected ones for manual verification, e.g., com.peppermint.livechat.findbeauty). Apps also exchange symmetric encryption keys over HTTP/HTTPS and non-standard channels: 82 apps sent and 10 apps received such keys over HTTP; 154 apps sent and 71 received such keys over HTTPS; and 8 apps sent such keys over non-HTTP.

Encrypted communication channels. To understand information leakage between different transmission channels, we categorize such channels into the following four categories. We consider that an app transmits a leaked item (e.g., Device ID) through a Regular channel, if the app shares the item using HTTP/S; the app may also apply custom encryption for this transmission (e.g., to the same or different hosts). For Custom Encrypted, the leaked item is shared via at least one channel after processing the item with one or more additional encryption layers; the same item may also be shared via Regular channels. We use Custom Encrypted for Some Hosts for apps that share the leaked item with one or more distinct remote hosts, only under custom encryption; this leakage will be missed by other tools (although the same information leakage will be detected for other hosts when shared via Regular channels). If an app uses only custom encrypted channels for sharing the leaked item, which is not shared via Regular channels, we count such app under Only Custom Encrypted; existing tools cannot detect any leakage from this category. See Table 2 for overall results for these channels, and Sec. 7 for prominent examples.

Recipients of encrypted traffic. 1291 and 786 unique remote servers with registered domain names and subdomain names, respectively, were contacted by the 2887 apps that used additional.

# Hidden in Plain Sight: Exploring Encrypted Channels in Android Apps
# CCS ’22, November 7–11, 2022, Los Angeles, CA, USA
layers of encryption. Some destinations may receive several on-device information items (e.g., appsflyer receives items such as WiFi ESSID, WiFi MAC, operator, device email, build fingerprint, advertisement ID, device ID), and other destinations may receive very basic items (e.g., scorecardresearch.com receive only advertisement ID). More importantly, 22 apps sent users’ GPS coordinates to these domains: 10 apps to appsflyer.com (3 only under custom encryption), 8 apps to supersonicads.com, 3 apps to batch.com (2 only under custom encryption), and one app to pangle.io. Appsflyer.com also received search terms from two applications (ru.labirint.android and com.lotte), and the user-entered phone number from another app (vn.gapo.app).