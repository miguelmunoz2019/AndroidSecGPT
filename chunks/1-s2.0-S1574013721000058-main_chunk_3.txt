# 2. Digital signature mechanism
Digital signature is a prerequisite for an app to be hosted on Google Play Store. It is generated by private key certificate allocated by a certifying authority thus ensuring the integrity of the app and authentication of its developer. Developers use verified certificates to validate app updation and other sibling apps developed by the same developer. If an APK is modified by an attacker, it needs to be re-signed for validation, which is only possible if the private key of the original publisher is known to the attacker.

# 2. Sandboxing
Android runs each app in an insulated kernel level sandbox environment with its memory and resources. This approach protects developer apps and system apps from malicious ones. As the sandbox is at the kernel, all above software (OS libraries, applications, framework) runs within the sandbox. Apps are restricted from interactions. If an app X tries to read application Y’s resources, it is prevented because of the lack of user privileges. If an app has the permission of a resource (e.g., Contacts), the
# V. Sihag, M. Vardhan and P. Singh
# Computer Science Review 39 (2021) 100365
app process is assigned to the corresponding resource access id. As apps are digitally signed with the developer’s private key, apps with same developer’s certificate are assigned the same UID (i.e. sandbox) for resource and permission sharing. Thus malware authors with developer’s key can design an app with the same certificate to access private resources of other sibling apps developed by the same developer.

# 2. Encryption
User data in Android device is encrypted using symmetric keys to provide confidentiality and authorized access. All disk write operations on user data follow after encryption and corresponding read operations precedes decryption. An unauthorized access to data, expose the real file content. Android employs two types of encryption methods to ensure confidentiality.

- File Based Encryption (FBE): Files in FBE are encrypted using different keys, which can be accessed independently. Using Direct Boot feature FBE enabled devices can boot straight to the lock screen without the requirement of user credentials.

- Full Disk Encryption (FDE): In FDE user data partition /data is encrypted on block level using a single key generated by user credential. During boot time the encrypted device is detected and prompted for the password, which is then used to decrypt the user partition. FDE used 128 Advanced Encryption Standard (AES) with cipher-block chaining (CBC) for encryption.

# 2. App manifest
The Android application contains a mandatory manifest configuration file (AndroidManifest.xml). It specifies essential attributes about the application to Android OS. Some of these essential attributes are App’s package name, its components, permissions requested and required set of hardware & software features. A sample manifest file is shown in listing 3. A manifest file values are configured at compile time and cannot be differed at execution. Following are the important characteristics specified in a manifest file.

1 &lt;?xml version = " 1 " encoding = " utf -8 " ?&gt;
2 &lt;manifest
3      xmlns: android =
4           " http :// schemas . android .com/apk/res/ android "
5      package = " com. example . helloworld "
6      android : versionCode = " 1 "
7      android : versionName = " 1 " &gt;
8      &lt;uses - permission android :name=
9           " android . permission . SEND_SMS " .../ &gt;
10      &lt;uses - feature android :name=
11           " android . hardware .sensor . compass "
12          android : required = " true " .../ &gt;
13      &lt;application ... &gt;
14          &lt;activity android :name=
15             " com. example . helloworld . MainActivity " ... &gt;
16          &lt;/activity &gt;
17          &lt;service android :name= " . TestService " .../ &gt;
18      &lt;/application &gt;
19      ...

20 &lt;/manifest &gt;
Listing 3: A sample manifest file.

Package name. Once an APK is compiled, the package attribute represents an app’s universally unique application ID, as it is used to identify an app in the system and Play Store. Listing 3 presents a sample package element name where com.example.hello world is the action string.

App components. An app is composed of multiple components declared as corresponding XML elements in the manifest file are discussed below:
- Activity: An activity is a user inference component to interact with the user. Multiple activity components can be declared in the manifest file. Each activity is allocated a window on the screen for its UI, which can be of variable size and floating on other windows. One activity is specified as ‘‘main’’ activity displayed during app launching.

# V. Sihag, M. Vardhan and P. Singh
# Computer Science Review 39 (2021) 100365
then may be followed by other activities based on user interaction. A sample activity "com.example.helloworld.MainActivity" declaration is shown in listing 3.

- Service: A Service component performs operations in the background without the user interface, even when the user switches to a different application. Application components also use services to interact with the app and perform inter-process communication (IPC).

- Broadcast Receiver: It is a component which allows apps to register for application or system generated events. Once registered, the receiver for an event is notified by Android runtime upon its occurrence. For example, application registered for BOOT_COMPLETED system event will be notified after completion boot process.

- Content Provider: Content provider is a standard interface to access structured data from within or outside an app. It is primarily intended to be used by other apps using provider client object for inter process communication and secure data access.

String and meta-data information in Android manifest file have also been used for malware detection.

# 2. Inter Component Communication (ICC)
ICC, a key feature of Android is an analogue of Inter Process Communication (IPC). It allows a component of an application to access data from another component within the same application, other application within the same device or an external service. Applications can depend upon others for third party services by borrowing services. For instance, a package delivery application can depend upon Google Map’s for user’s geolocation thus aiding developers.

Intents and intent filters. Activities, services and broadcast receivers, the core components of an application are invoked through an asynchronous messaging system called intents. An Intent object principally is a bundle containing information about action to be taken, data to act on and event that has been announced. Separate mechanisms exist for intent delivery to each type of component. Fig. 7 depicts starting of an activity using intent.

Intents can be divided into two types:
- Explicit intents are designed for the fixed target component. Only the component name in intent is considered to identify the target component.

- Implicit intents are not for a fixed target and are often used to actuate components in other applications.

Listing 4 declares an activity with an intent filter to receive an ACTION_SEND intent for text datatype.

&lt;activity android:name="ShareActivity"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.SEND"/&gt;
&lt;category android:name="android.intent.category.DEFAULT"/&gt;
&lt;data android:mimeType="text/plain"/&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;
Listing 4: Sample activity with intent filter in manifest file to receive ACTION_SEND intent
The intent filtering mechanism cannot be relied on for security. While implicit intents are tested against intent filters for targeting components, the explicit intents can name the components as the target. An explicit intent should be used for starting a service and developers should prevent from declaring intent filter for service components. Using an implicit intent to start a service is a security hazard . Intent filters have been used for malware detection. Refs. [28–30] have evaluated effectiveness of Android intents (explicit and implicit) alone or in combination with other features such as permission for identifying malicious applications.

# 2. Permission model
Android uses permission-based security model to restrict application’s access using APIs to system resources. Requested permissions to access resources are specified using &lt;uses-permission&gt; tags in the manifest file as depicted in listing 3. Android permission model defines four access levels for permissions.

- Normal permissions are required by an app to access data or resources outside its sandbox to isolated application level features, but with negligible privacy or security risk. For example, ACCESS_NETWORK_STATE is normal permission.

- Dangerous permissions are higher risk permission that request exposure to user’s private data or device control. Explicit consent from user during installation is required for them. For example, ability to access calendar and phone book are dangerous permissions.

- Signature permissions are used by developer to share resources among its sibling apps. It is used to access resources between apps signed by the same developer certificate. For example, INJECT_EVENTS allows an application to forcibly stop other applications.

- SignatureOrSystem permissions are required to change system setting and installation privilege. These are generally given to apps signed by the same developer certificate as of system image. For example, WRITE_SETTINGS allows an application to alter system settings.