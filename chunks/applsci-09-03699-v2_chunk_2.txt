STOWAWAY , COPES , and PScout  have addressed the permission gaps in Android apps. They first build a permission map that identifies what permissions are needed for sensitive data access (i.e., API calls) and then use static analysis on the apps to identify the permissions they may invoke at running time. Felt et al.  used STOWAWAY to study more than 900 apps. They found that about one-third of the apps were overprivileged. Wu et al.  used the permission map provided by PScout to study apps on 10 different devices, the result showing that more than 85% of apps were overprivileged. In this paper, we use the permission map provided by PScout.

# 2. Improving the Android Permission Model
Many works have attempted to improve the Android permission model. These works can be divided into three categories:
- Modifying the current Android permission model. For example, Reddy et al.  advocated to replace the app-centric permission model with the original resource-centric model, which provides more flexibility. Other approaches like Apex  propose a new policy enforcement framework for Android that allows a user to selectively grant permissions to apps.

- Rewriting the apps to perform fine-grained permission access control. For example, Jeon et al.  inserted additional methods before the API methods that require a permission. Those added methods will check if users grant permission or not, and if not, the permission-related API methods will not be invoked. Similarly, Liu et al.  used the same principle to perform fine-grained access control on third-party libraries.

- Information flow-based fine-grained policy enforcement. TaintDroid  is a representative work that tracked the sensitive data (taint source) flows during app execution at runtime. A number
Appl. Sci. 2019, 9, 3699 4 of 17
of studies extended the system to track information flows. TISSA , MockDroid , and AppFence  propose to replace sensitive information with fake data. CleanOS  proposes to modify TaintDroid to enable secure deletion of information from application memory. Kynoid  extends TaintDroid with user-defined security policies such as restrictions on destination IP addresses to which data are released. Wang et al.  extended TaintDroid to enforce fine-grained access control based on the purpose of permission use in Android apps.

• Crowdsourcing-based methods. Some approaches  attempt to utilize crowdsourcing to recommend suitable permission settings for an app for different kinds of users. These methods are able to free the users from having to understand the mechanics behind permissions.

As we can see, most existing methods deal with the issue from the user’s perspective, without considering how developers can help during the process. Typically, these methods either need to modify and repackage the app or modify the Android framework or the operating system. The existing approaches face several important challenges:
• Many approaches need to instrument and repackage apps if they want to modify their behaviors. However, repacking apps will not always succeed. Repackaging apps will change the signature of the original app, and if the app checks its signature for integrity, it will refuse to run. Actually, many popular apps (e.g., WeChat) have already applied runtime signature checks, and doing so will be more and more popular in the future.

• Modifying the Android platform, on the other hand, is also not practical and is potentially dangerous. Introducing new permission models or frameworks in practice must have a user either install a whole new system or run them on a rooted device, which will lead to security vulnerability.

• Typically, mobile apps are the carriers of permission-related issues. However, no matter how hard we have tried to fix the issues after the apps are released, it is impossible to enforce a complete control on all instances of a particular app. We can only solve these issues completely at its very beginning or in the development phase of an app.

# 2. Android Permission from Developers’ Perspective
According to the analysis above, we argue that it is more efficient and practical to solve permission-related issues from the perspective of app developers. What concerns a developer most is whether the app he/she develops functions well and meets the requirement of the targeted users. However, this does not necessarily mean that developers have no motivation to solve permission-related issues in their apps. Actually, some permission-related issues will cause the app to behave in an undesirable way (i.e., app crash or security breach). These are detrimental to the popularity of the app. Thus, any permission-related issues that may influence the functionality and robustness of an app are also important concerns for developers.

Generally, fixing permission-related issues at the development phase will have the following advantages:
• To analyze released apps, one has to decompile the app to bytecode to perform further analysis. However, at the development phase, the analysis can be conducted on source code directly, which potentially has more information than bytecode. At least, source code at the development phase will not be obfuscated, which has become a common obstacle in analyzing Android bytecode.

• Compared to app users, app developers have a much better knowledge of the functionalities and behaviors of the apps they are developing. App developers without malicious intentions will not purposely write codes that behave maliciously or contain security vulnerabilities. With the help of an automated tool, the developers can express their intentions correctly in the code snippets. It is also true that some permission control tools are also efficient enough to assist app users. However, users know little about Android permission specifications. Therefore, it is possible
that users unjustly regard a normal permission usage as inappropriate. Developers, on the other hand have better understanding of the Android permission model and are less prone to making such mistakes.

- It is always better to solve a problem at the earliest stage, instead of postponing it to later. If all permission-related issues are solved at the development phase, all users will enjoy the functionality of the app without any concerns about permission uses. Otherwise, every user of the app will have to experience the bad effect of those issues.

There are already several studies that explored research questions relevant to mobile app developers. For example, Balebako et al.  explored how app developers make decisions about privacy and security. They examined whether any privacy and security behaviors were related to the characteristics of the app development companies. They interviewed 19 and surveyed 228 developers about their privacy and security behaviors. Their findings suggested that smaller companies are less likely to demonstrate positive privacy and security behaviors. Besides, developers are not aware of the data collected by third-party libraries. Wang et al. [41 – 43] analyzed the privacy behaviors of app developers and found that more than 70% of apps with severe privacy risks are created by 1% of developers.

The work of Bello-Ogunu et al.  and Vidas et al.  were the closest to us. They both developed plugins for the Eclipse IDE to guide developers on the set of required permissions when creating Android applications. In particular, they detected if permission overprivilege existed in the app and recommended appropriate permission settings. In comparison, our work not only deals with permission gaps, but also detects permission-related bugs in apps. Our paper is the first work to check the permission underprivilege and unprotected API issues in the form of an IDE plugin, and we separate the permissions used in third-party libraries during analysis. Secondly, we not only design an efficient tool for developers, but also present a comprehensive study on permission-related issues from the developer’s perspective.

# 3. A Taxonomy of Permission-Related Issues
Android has thousands API methods that require permissions . It is impossible for developers to remember all these API methods. Usually, developers would refer to the official Android API documentation provided by Google or debugging information in the IDE, which costs considerable time . To make the problem even worse, studies show that about 16,000–28,000 undocumented APIs require permissions for different versions of Android . Thus, it is challenging for developers to declare a precise set of permissions that they use in their apps. Developers who are not familiar with Android permission specifications are likely to make permission-related mistakes. Even for developers with advanced expertise, they would still make mistakes due to carelessness or incorrect API documentation. Developers may then need further efforts to recheck their permission declaration to avoid mistakes. Some mistakes (i.e., typos) are too subtle to identify, and this becomes another hard and time-consuming task.

In this section, we summarize several permission-related issues that are important concerns for Android developers.

# 3. Concepts and Definitions
We first define the following concepts related to Android permissions, which will be used throughout this paper.

- A declared permission set (DPS) contains all the permissions declared in the Android Manifest file of an app by the developer.