# Implementation in software development:
Specifically, 1) When set mode to MODE_WORLD_READABLE, the third-party app can view the file, resulting in leakage of sensitive information; 2) When setting the mode to MODE_WORLD_WRITEABLE, the third-party app can delete and change the file, potentially introducing malicious code.

# Repair suggestions:
Developers should set the mode of the getSharedPreferences() method to MODE_PRIVATE.

# Malicious unzip (MU):
The Android app will take ZipInputStream and ZipEntry when decompressing/compressing zip files, while it will be considered malicious if the file name contains special symbols.

# Implementation in software development:
The ZipEntry provides getName() to read the name of the zip file. If the file name has a special string like ../ when decompressing the file, it will produce a code smell.

# Repair suggestions:
Recommend developers filter the upper directory string and check the file name when decompressing.

# SD visit (SDV):
Android apps store public data in shared external storage by invoking getExternalStorageDirectory() without encrypting will be considered nonstandard.

# Implementation in software development:
Developers store sensitive information on an external SD card without encryption.

# Repair suggestions:
Recommend developers to prohibit getExternalStorageDirectory(), store sensitive information in the private directory of the app and encrypt the sensitive data.

# Unsecure random (UR):
The SecureRandom is for obtaining random numbers in Android encryption algorithm. By default, the random number list is generated by dev/urandom, and the result is hard to predict. However, when setting the seed, the random number is generated based on a fixed algorithm and seed, so it can be easily predicted.

# Implementation in software development:
When calling class SecureRandom, generating random seeds with the following method is considered a smell: SecureRandom.SecureRandom(byte[] seed), SecureRandom.setSeed(byte[] seed) and SecureRandom.setSeed(long seed).

# Repair suggestions:
1) Recommend developers not to generate random numbers by Random class; 2) Do not set a seed when using SecureRandom.

# Detect Android code smell
We developed DACS to detect 15 targeted Android smells in source code. Android code smells are fine-grained method-level code structures and must be identified by analyzing the source codes, so DACS completes the detection based on ASTs from source codes. DACS designs detection rules for each Android code smell and independently realizes the detection submodule to output the targeted smell results. As depicted in Figure 2, the detection method mainly
# Output
# Input
# Android Code Smell
# Detection Algorithms
(A)
(B)
F I G U R E 2 Detect android code smell (DACS) detection method. (A) Detection preparation module; (B) DACS’s code smell-Specific detection.

contains two modules: (i) convert the Apps source code into ASTs under ESTree standard, and design smell library based on the definitions, then realize the specific identification algorithms, and (ii) collect the ASTs set and search the AST by specific Android code smell detection algorithm, and count the occurrences of each code smell based on the matching rules.

AST facilitates code smell detection in apps by abstracting the syntactic structure of source codes in the form of trees, with the relationship nodes representing lexical information and syntactic structure. Then, DACS traverses the AST following the detection algorithm and counts the number of identified code smells. Specifically, (1) depending on the specific definition, summarize the detection keywords; (2) taking the method level as the detection cell, match the keywords within each method body to determine whether the method contains the code smell; (3) calculate the total number of code smells present in the app.

The 15 code smells are detected by matching rules to complete the detection, and the implementation method is similar. We take a specific code smell–WCA as an example to show the detection process in detail, as shown in Algorithm 1. The algorithm’s words roughly as follows: First, according to the definition in Section 3, extract the keywords for detecting WCA smells. Then, at the method level, match the keywords within each method body to determine whether there are code smells present. Finally, count the total number of WCA in the class. The input to the algorithm is a Java class, and the output is the number of WCA. We detect code smells in each .java file, accumulate the number of code smells, and ultimately output the number of each code smell present in each class.

# 3 Statistical analysis of impact quantification
DfeDIQ proposes a fault counting model to quantify the relationship between Android code smells and the app’s fault count (no association, positive association, negative association, or combined association), providing insights for repair priority. We verify whether code smells and their combinations matter to the fault counts by two-sided hypothesis testing, determine the rejection domain threshold value according to the set significance level, and then determine the model parameters. The discrete regression relationship is established to illustrate which code smells are of no concern to developers and which ones should be paid special attention to and repaired in time. Among them, the Android code smells are selected from Section 3; the fault information is extracted from the history submission data of practical open-source Android apps.

# 3 Fault statistic
The software testing community has different definitions and conceptual descriptions of software problems. DefDIQ focuses on a broad definition of fault, and in this paper, the following issues are widely defined as fault, including (1) fault, describing the incorrect program design in software; (2) vulnerability, representing the static defects in software; (3) error,
# Algorithm 1. wca detection algorithm
1:  Initialization:cnt ← 0
2:  repeat
3:       method ← pClassBean.getMethods()
4:       content ← method.getTextContent()
5:       if content.contrains(“MD2”||“MD4”||“MD5”||“SHA-1”||“RIPEMD”||“DES”||“AES∕ECB”) then
6:            cnt ← cnt + 1
7:       else if content.contrains(“RSA”) then
8:            if !content.contrains(“RAS/ECB/OAEPWithSHA256AndMGF1Padding”) then
9:                 cnt ← cnt + 1
10:                 macher ← pattern.matcher(content)
11:                 while matcher.find() do
12:                      if  Integer.parseInt(matcher.group(2)) < 512 then
13:                           cnt ← cnt + 1
14:                      end if
15:                 end while
16:            end if
17:       end if
18:  until pClassBean.getMethods() is null
Ensure:       cnt //code smell number
describing the error results from running defective software; (4) failure, referring to the external software failure behavior observed by users; (5) bug, indicating the general description of software failures and errors; (6) defect, which can cause various bugs. These problems affect quality from different perspectives, including performance, security, memory, energy consumption, portability, and efficiency.

Fault data sources are a critical factor affecting fault counting models. Researchers use data warehouses to collect faults, and these data warehouses can be broadly classified into three categories: private/commercial warehouses, partial public/free warehouses, and public warehouses. Among them, public repositories are adopted by most researchers as a rich and valuable source of fault data (e.g., Bugzilla, JIRA, PROMISE). However, Android apps rely on third-party libraries and update so quickly that no available public data repository has yet emerged. Due to the limitation of traditional manual time-consuming and labor-intensive, researchers mainly collect faults data in large datasets by the method of Zimmermann.

Android apps on GitHub are diverse, with some in multiple development versions, some in only one version, and others even incomplete. To collect reasonable faults data, we focused the research on the same development version of the Android app and counted the faults by keyword matching. The specific rules for the app version selection are as follows:
- Incomplete version: search the first complete executable project from the original commit and record the faults between this commit and the latest commit.

- One version: record the faults between this version and the latest one.

- Version number ≥2: record the faults between the latest version and the last committed one.

DefDIQ categorizes the apps by version, locates the commits that contain all fault keywords in the “open” and “closed” problems, and counts the faults. The method is summarized as follows:
- Find commits with the “fail,” “vulnerability,” “error,” “failure,” “defect,” “bug,” “mistake,” “fix(ed),” and “update(d)” in the committed and resolved problems. In particular, ignore the case of the keyword while matching.

- Due to the irregularity by the developers, many commits with faulty keywords are not purely faulting repairs. Therefore, it is essential to manually review the commits that successfully match the keywords. Due to massive faults, random sampling detection may be a great choice.

1097024x, 2023, 11, Downloaded from https://onlinelibrary.wiley.com/doi/10/spe by <Shibboleth>-member@javeriana.edu.co, Wiley Online Library on [11/08/2024]. See the Terms and Conditions (https://onlinelibrary.wiley.com/terms-and-conditions) on Wiley Online Library for rules of use; OA articles are governed by the applicable Creative Commons License
2306 ZHONG et al.

# Application fault counts
We obtained the statistical information about the app fault through the above steps, and all of the raw fault data is available at https://github.com/strongcat0325/Fault-Data.git, as presented in Figure 3. The original fault counts do not obey the normal distribution with a significant degree of dispersion, and most apps’ fault counts are 0.