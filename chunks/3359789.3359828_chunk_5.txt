R3: Retry Attempts. As the number of allowed attempts is not suggested by RFCs, we consider apps that allow more than five attempts to be insecure. AUTH-EYE first requests a valid OTP from the server to test this property. It then generates a fake OTP by using ‘0’ to replace all the digits in the valid OTP (or using ‘1’ if the valid OTP happen to be all-zeros). The fake OTP value is used for testing the existence of a retry limit. AUTH-EYE then submits the incorrect value five times and analyzes the five responses sent back from servers. Since the error message is not shown as an SMS message,
AUTH-EYE relies on Burp Suite  to collect responses from each server and store them in a log file for further parsing.

To identify the limitation on retry attempts, AUTH-EYE compares the five error messages without considering the values in the messages. If the five messages are identical, it implies that the validation system may not limit the number of attempts. In that case AUTH-EYE sends the fake value repeatedly to confirm whether there is any limit. AUTH-EYE terminates this procedure under two circumstances: 1) a different message is received, such as “Too many errors”, or 2) AUTH-EYE has made 20 attempts7. The first circumstance implies that there is a limitation, and the number of attempts so far performed by AUTH-EYE is the maximum allowed attempts. The second case indicates that the validation system may allow unlimited attempts.

If the five error messages are not the same, AUTH-EYE then identifies the word describing attempts from these messages. AUTH-EYE searches for the format as a value followed by the word “time”, which refers to how many more attempts may be made. Setting a time delay is a possible additional protection mechanism for retry attempts. Given the five error messages, AUTH-EYE first searches for the word “delay” and then finds the format as a value followed by a time-related word (i.e., “second/s”, “minute/min”, or “hour/h”). The value found is extracted as the required delay before another attempt.

# R4: OTP Consumption
To identify whether the validation system of OTP authentication accepts a re-used OTP, AUTH-EYE first requests and consumes a valid OTP. It then attempts the consumed OTP again. If the validation succeeds for the second time, it indicates that the implemented OTP authentication does not check or remember the provided OTP for each authentication session, and permits repeated use of OTPs across multiple sessions.

# R5: OTP Expiration
Given response messages, AUTH-EYE searches for the word “expire” and extracts the value after this word, that is, the validation time of the received OTP. To measure the expiration interval, we set a timer in AUTH-EYE. Once the OTP message is received, AUTH-EYE starts the timer and repeatedly sends the OTP to the server for validation until it expires. If AUTH-EYE can be validated successfully, a violation is detected (i.e., the server does not check the expiration of the OTP adequately).

# R6: OTP Renewal Interval
To identify apps that violate this rule, AUTH-EYE provides a valid OTP at times corresponding to different time intervals. Because the RFC recommends 30 sec as the optimal time interval, we set the time intervals to [0, 30s], [30s, 60s], [60s, ∞]. In our test, AUTH-EYE first uploads the OTP immediately after it was received (i.e., within 30 seconds). Then, AUTH-EYE requests a new OTP and submits the value within 30 to 60 seconds. If the request succeeds, AUTH-EYE asks for another OTP value and resubmits it after 60 seconds. AUTH-EYE repeats this test with the renewal intervals of [1min, 5min], [5min, 10min], [10min, 30min], [30min, 60min], [60min, 24h], and [24h, ∞] until it is rejected by the server (or finds a still available OTP after 24 hours). If a server accepts an OTP with a lifetime more than 30 seconds, AUTH-EYE considers it as an insecure one.

# 5 EVALUATION
Our evaluation has two goals. The first is to assess the effectiveness of AUTH-EYE in automatically analyzing the implementations of OTP authentication protocols in Android apps and verify that their implementations comply with the OTP rules. The second is to use AUTH-EYE to gain insights into the frequency of violations of OTP rules in real-world Android apps.

# 5 Dataset
We built our app dataset by downloading 3,303 top list apps from both Google Play and Tencent MyApp markets (986 from Google Play and 2,317 from Tencent) between February and April 2019. The dataset contains apps in 21 categories including Beauty, Books & Reference, Communication, Education, Entertainment, Finance, Health & Fitness, Lifestyle, Map & Navigation, Medical, Music & Audio, News & Magazine, Parenting, Personalization, Photography, Productivity, Shopping, Social, Tool, Travel & Local, Video Players & Editors. We selected from each category the recommended apps (about 150 apps in each category, and the most active one has around 3 billion downloads).

We observed that many apps also provide the option of login via a third party (e.g., OAuth). Note that in this paper we only assess apps with customized OTP authentication protocols, and those which use third-party authentication services with open-authentication are out of the scope of this paper.

# 5 OTP Login Activity Recognition
The first task of AUTH-EYE is to create an OTP list, i.e., a list of apps implementing SMS OTP. Among the 3,303 apps in our dataset, AUTH-EYE is able to analyze 1,364 apps, while other apps adopt app protection measures (e.g., code packing and code obfuscation) to hinder the decompilation and code analysis of AUTH-EYE. We manually inspected the apps that AUTH-EYE failed to analyze to gain some insights:
648 apps are protected using code packing against decompilation, in which their “.class” files are encrypted. These files will only be decrypted during app execution. Since we cannot extract the source code from encrypted apps, AUTH-EYE is unable to locate their login Activities and cannot execute them.

AUTH-EYE are not able to analyze 1291 apps because 1) 695 of them use code obfuscation to prevent the code from being analyzed and 2) 596 apps are unable to be executed due to potential anti-debugging code.

We argue that AUTH-EYE could also adopt advanced analysis technique such as unpacking to handle these issues, but this often involves manual efforts (e.g., patching anti-debugging code) and is not scalable. More importantly, we observe that apps developed by large companies (e.g., Microsoft, Alibaba, Tencent, Baidu) seldom adopt code protection due to stability and compatibility requirements. Therefore we leave the analysis of protected apps as a future work and only focus on those unprotected apps.

AUTH-EYE identified 1069 (78%) with declared login Activities in successfully analyzed 1,364 apps, and the top-10 commonly used login Activity names are listed in Table 1. It is clear from the list that developers do prefer to use the word “login” to describe a login Activity. Given the list of apps with identified login Activities, AUTH-EYE then further identified how many implement OTP authentication. In total, 544 (58%) app adopt OTP authentication. Among these 544 apps, 354 use two-factor authentication (both password authentication and OTP authentication), while 190 apps only contain OTP authentication. In this study, we only discuss the validation OTP authentication and leave the evaluation of password authentication protocols as future work. Hence, our discussion focuses only on the apps in the OTP list, i.e., 544 apps implementing SMS OTP authentication. Note that for apps with password authentication involved, we manually registered an accounts in those apps and typed in the combination of username and password.

# 5 Results
# 5 Rules Violations
R6: OTP Renewal Interval. A large number of apps, 536 in total, violated this rule, making it the most frequently violated OTP rule. Only eight apps follow the requirement proposed by R6. Further inspection revealed that in 165 apps, the OTP validation systems did not require OTP values to be renewed. For the remaining failed apps (i.e., 371 apps), the intervals to renew OTP values set by their validation systems are shown in Figure 2. Most validation systems (122 apps) are set to renew OTP values at intervals between 5 minutes to 10 minutes. The validation systems of 112 apps generate new OTP values within the time interval of one minute to five minutes. Even worse, AUTH-EYE identified that the validation systems in 15 apps accept OTPs that have been delayed for 24 hours. This design results in the TOTP authentication protocol behaving no better than a normal OTP authentication protocol. The developers of these apps might deliberately choose this option since accepting a large range of delays as valid is much more user-friendly.