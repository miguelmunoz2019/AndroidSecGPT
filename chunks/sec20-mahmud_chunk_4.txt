# Test T3 (Masking Credit Card Number)
Requirement 3 in Section 2 states that the only time the application should display the full credit card number (PAN) is when the user is entering it in the text field. All other times the credit card number is displayed, it should be masked, showing at most the first six and last four digits of the number.

Test T3 requires additional sophistication in the static program analysis algorithm. First, it includes R, the set of required methods. Recall that a violation does not occur if all paths from the sources to the sinks include an instruction that invokes a method in R. In this case, we define a set of PAN masking methods (PMM), listed in Table 2, that represent different ways in which the application developer may have masked the credit card number. While the developer may choose to use other string manipulation methods, this set is conservative and will raise an alarm for manual review by a security analyst. Of course, this set can be easily expanded as additional string manipulation methods are discovered.

Second, Test T3 considers not only textual user input as taint sources, but also input from the network. For example, an application may retrieve the credit card number from the server and display it for the user. Such cases should also be masked. However, in this case, it is nontrivial to detect which input data is the credit card number. While the semantics of JSON key-value fields could potentially be used, we elected to use a simpler heuristic that filters tainted paths at the sink. Specifically, we extract a list of all resource IDs of UI widgets that exist on a UI screen that also contains the text “Credit Card.” Our intuition is that mobile application UI screens are generally purpose-specific and the other displayed information is likely related. This classification allows
Data Persistence Methods (DPM) = java.io.OutputStream.write(), java.io.FileOutputStream.write(), java.io.Writer.write(), java.lang.System.out.println(), android.content.SharedPreferences.Editor.putString(), android.util.Log.i(), android.util.Log.d()
PAN Masking Methods (PMM) = java.lang.String.replace(), java.lang.String.substring(), java.lang.String.concat(), java.lang.StringBuilder.append()
Obfuscation Methods (OM) = javax.crypto.Cipher.update(), javax.crypto.Cipher.updateAAD(), javax.crypto.Cipher.doFinal(), java.security.MessageDigest.digest(), java.security.MessageDigest.update()
The static program analysis to only consider View.setText() methods as taint sinks if they correspond to objects that were retrieved using findViewById() and a resource ID from that set. As mentioned in Section 4, we leverage the Explicit-ValueFinder within the custom source and sink manager to perform this refinement. We, therefore, leverage the View.setText() sinks in Amandroid’s TAR structure, knowing that they have been refined as such.

Once Test T3 has filtered the TAR with respect to the sources and sinks described above, it computes all paths between them using the DDG. We then remove paths that contain a method from R. The resulting set of paths are potential violations of the PCI DSS and are made available for manual review.

# Test T4 (Storing Non-Obfuscated Credit Card Number):
Requirement 4 in Section 2 states that the credit card number (PAN) should always be protected if it is stored by the mobile application. The PCI DSS standard has some flexibility in how the number is protected, but it offers suggestions including one-way hash functions and cryptography. Requirement 4 refines Requirement 1 specifically for the credit card number, and since our Test T1 only considers the credit card number, and not the other CHD values, it might seem that both Test T1 and Test T4 are not needed. However, we wanted to include both, because Test T1 will capture all cases when the credit card number is written to persistent storage, whereas Test T4 only raises an alarm when there is not an obfuscation method on the data flow path. Put another way, Test T1 is designed to be a warning for closer inspection, whereas Test T4 is designed to detect violations.

Given the similarity to Test T1, Test T4 follows the same implementation pattern. However, Test T4 includes a set R of required obfuscation methods (OM), as listed in Table 2. These methods include calls to common encryption and message digest functionality in Java, as listed on the Android developer’s website . Similar to Test T3’s PAN masking methods, we do not seek to enumerate all possible cryptography libraries. Nonstandard libraries should be reviewed and can potentially be added to the list in the future. For the Cipher.doFinal() method, we validate that the Cipher object is initialized with an ENCRYPT_MODE. In the future, additional cryptography checks  could be incorporated. Note that false negatives resulting from this limitation of Test T4 would still raise a warning for Test T1, which reports any write to storage, obfuscated or not. Finally, Test T4 uses the same strategy as Test T3 for ensuring all paths from the filtered sources and sinks contain a method from R.

# Test T5 (Insecure Transmission):
Requirement 5 in Section 2 states that mobile applications should always use TLS/SSL when transmitting cardholder data. There are two ways in which an application can fail to properly use TLS/SSL: (1) send data via HTTP URLs, (2) invalidate certificate checks when sending data via HTTPS URLs.

As shown in Table 2, Test T5 uses OutputStreamWriter.write() and OutputStream.write() as taint sinks to filter the TAR. However, these sinks may also be used for file writes. Unfortunately, the URLConnection object used to create the output stream will not be on the tainted path for the credit card number (so R cannot be used). Therefore, we separately walk backward on the DDG from the taint sink to find the URLConnection object used to create the output stream object. We then use Amandroid’s ExplicitValueFinder to determine the argument passed to the corresponding URL initialization method (URL.init(String)). We then determine if the string is an HTTP or HTTPS URL. If an HTTP URL is used, an alarm is raised.

If an application has an HTTPS URL as a taint sink, we also check if the application contains a vulnerable TLS/SSL configuration. To do so, we leverage Amandroid’s existing API Misuse module, which has a configuration option for.

USENIX Association 29th USENIX Security Symposium 1523
# 5 PCI DSS Compliance Study
Our primary motivation for creating Cardpliance was to analyze whether mobile applications are mishandling payment information. The goal of this study is to gauge the impact of PCI DSS non-compliance on real-world users. In this section, we use Cardpliance to analyze popular applications from Google Play for potential PCI DSS violations and present case studies based on our findings.

As Cardpliance uses static analysis to vet application’s compliance of PCI DSS requirements, it is subject to the same limitations as static analysis. In particular, static analysis may provide an over-approximation of application behaviors that may result in false alarms. Therefore, we manually validate data flows that Cardpliance flags as potential PCI DSS violations to determine whether the application is actually violating PCI DSS requirements. Note that the goal of validation is to determine whether the application is violating PCI DSS requirements, not to comprehensively determine whether every data flow identified by static analysis is a true positive or false positive. Therefore, a true positive denotes that the application contains a PCI DSS violation while a false positive denotes that none of the data flows flagged by static analysis were valid due to errors in the underlying tooling.

# 5 Dataset Characteristics
To select our dataset, we downloaded the top 500 free applications (“top_selling_free” collection) across Google Play’s 35 application categories in May 2019, which resulted in an initial dataset of 17,500 applications. To determine which applications request payment information, we disassembled the dataset and performed a keyword-search on the resource files for terms that describe payment card numbers (e.g., credit card number, debit card number, card number). The list of terms was obtained from the synonym list in UiRef  for “credit card number.”2 This keyword-based triaging flagged 1,868 applications as potentially requesting credit card information, which reduced the dataset by 89% (15,632/17,500). Note that this triaging may provide an under-approximation of the total number of applications requesting credit card numbers due to the comprehensiveness of the keyword-based list. However, since this keyword list was used by prior work  to identify 4,433/50,162 (8%) applications in Google Play were asking users for credit card information, we believe it is suitable for our study. We leave it as future work to construct a comprehensive multi-language vocabulary of terms that refer to credit card numbers.

As discussed previously, simply containing a string that matches a credit-card related keyword does not imply the application accepts credit card numbers from the user. Therefore, we use UiRef to determine when an application takes credit card numbers as input. We ran UiRef on the refined dataset and found that 807 applications failed during reassembly due to errors in ApkTool UiRef failed to extract layouts from an additional 110 applications. Of the remaining 951 applications, UiRef identified that 442 applications containing input widgets that request credit card numbers.