At the beginning of paragraphs, we observe that a key sentence is often used to summarize the meaning or functionality of an element or attribute. As such, we utilize this context to improve the constraint extraction by identifying the subject and object from the first sentence of the paragraph (taking sentence dependencies into account). Of course, not all paragraphs provide contextual information in the first sentence, and non-manifest related information may be mistakenly generated. For example, in the documentation of the android:backupAgent attribute under the <application> element, the first sentence says ‚ÄòThe name of the class that implements the application‚Äôs backup agent‚Äô. Although the sentence merely indicates that the attribute is associated with a backup agent class in the source code, the context information may be mistakenly extracted as backupAgent. As a result, when we later encounter the sentence ‚ÄòThe name must be specified‚Äô in the context of android:backupAgent we may identify the child to be ‚Äòname‚Äô but mistakenly identify parent as backupAgent, which is not a valid manifest entity. Hence, it is vital for utilizing the knowledge we extracted about manifest file to filter out these non-manifest constraints to avoid mistakes in the schema.

# Detecting and Measuring Misconfigured Manifests in Android Apps
# CCS ‚Äô22, November 7‚Äì11, 2022, Los Angeles, CA, USA
extract a constraint that says ‚Äò<activity> must be in <activity>‚Äô, which is of course incorrect. As such, we need to filter out these erroneously-extracted constraints, and have designed five rules as shown in Table 1 to filter out the non-manifest constraints at three levels: context, sentence, and word.

# Context Filter
The context filter uses the contextual relationship between the parent and child entity to filter the non-related constraints. There are three rules used by this filter:
- R1: When extracting constraints from broken phrases and sentences that do not contain any manifest entities, our recognizer may treat both the parent and child as missing and extract them from the context. However, there may be sentences completely irrelevant to manifest constraints where both parent and child entities are mistakenly inferred from the context. Hence, we need to focus on sentences containing at least one entity explicitly related to manifest (not inferred from contexts). As such, the constraints where both the parent and the child are extracted from contextual information need to be filtered out.

- R2: As we focus on manifest-related constraints, it is natural that we force all identified parents and children to be contained in the manifest dictionary.

- R3: In addition, we need to further ensure that extracted child is within the valid children list of the extracted parents. For instance, if a parent is action and a child is <intent-filter>, this is not a valid manifest constraint because we know from manifest dictionary that <intent-filter> cannot be a child of <action>.

# Sentence Filter
On top of contextual information, the sentence structures also provide hint for improving the accuracy. Particularly, in rule R4, we use sentence structure to filter sentences with noun (acl) or adverbial clauses (advcl) that voids occurrence constraints in main clauses such as ‚Äòmust have‚Äô. For example, in ‚ÄòYou should always declare this attribute if you want to configure [...]‚Äô, although it seems to be a minimal constraint because this is an imperative sentence with a phrase should always, the adverbial clause ‚Äòif you want to configure‚Äô have voided such minimal requirement because it indicates that the attribute is mandatory only when the developer wants a certain configuration to be effective, whereas it is optional if developers do not want the configuration. Thus, the attribute mentioned in such a sentence is still optional in the manifest file.

# Word Filter
We also utilize words in sentences to reduce errors in occurrence constraint extraction, both for minimal and maximal constraints. On one hand, model verbs that carry strong tone like ‚Äòmust‚Äô have to appear to clearly convey the minimal constraints (‚Äòmust have‚Äô constraints). Therefore, we systematically checked all the modal verbs, and found only must and should conveys such strong tone, whereas other modal verbs can merely convey suggestions or predictions, such as will and may. On the other hand, numerical modifiers, when accompanied by model verb, help identifying maximum constraints. For example, in ‚ÄòOnly one instance of the <compatible-screens> element is allowed in the manifest‚Äô, the manifest entity <compatible-screens> has a numerical modifier one. Therefore, it specifies that the maximum of the element is 1. As such, the word filter filters out non-manifest constraints with a set of modal verb keywords and the numerical modifier dependency nummod (R5).

# 4 Schema Generator
With positional constraints and quantitative constraints extracted and reformed into structured data, we then generate the XSD file for validation. In particular, the positional constraints are transformed by declaring each element with xs:element and then listing its child elements in <xs:element> and attributes in <xs:attribute>, respectively, e.g., in the declaration of <intent-filter> at line 1 in Figure 2, it contains references to child elements such as <action> at line 4, and attributes such as android:autoVerify at line 8 (which is declared at line 11). With the structure of elements and attributes being constructed in XSD, quantitative constraints are generated by setting minOccurs and maxOccurs for elements, and required for attribute (no maxOccurs for attributes as they are unique by nature). For example, the minimum occurrence of <action> is 1, and therefore the minOccurs of <action> is set to 1.

# 4 Manifest Validator
With the generated XSD schema, our Manifest Validator validates an app manifest file by detecting three types of misconfigurations: missing, misplaced, and unexpected. Missing entities are identified when the validator finds an element or attribute missing. Misplaced and misspelled entities, however, are both reported as unexpected keywords, so we need to compare the related element or attribute name with the manifest dictionary. If the entity is a valid manifest name, it is considered misplaced; otherwise, the entity name is misspelled. However, although our validator can detect all the unexpected attributes and elements, they are not always misspelled by developers. For example, compilers may add attributes to provide information of the compiler, and there may be system-only elements and attributes that do not appear in the documentations. As such, to avoid false-positives of identifying these manifest entities as ‚Äúmisspelled‚Äù, we only focus on the following three types of misspelling errors:
- Prefix Errors: This error occurs when developers forget to add or mistakenly add the android: prefix for an attribute (e.g., android:package v.s. package, and android:name v.s. name). To identify this type of error, we remove the android: prefix of the encountered attribute name and compare the attribute name to attributes names in the manifest dictionary (R6).

- Capitalization Errors: A capitalization error occurs when the name of an element or attribute is mistakenly capitalized (e.g., meta-data v.s. Meta-Data). To identify such errors, we match the lowercase prefix-free strings of unexpected names to names in the manifest dictionary (R7 and R8).

- Typos: To identify misspelled element or attribute names (e.g. meta-data v.s. mata-data) we compute the Levenshtein edit distance between an unexpected name and names in the manifest dictionary and check if it is below a certain threshold ùõº, indicating the two words are highly similar (R9 and R10). This threshold must be larger than 0, because no typos will be identified otherwise. However, if this threshold is set too high, it may introduce a large amount of false-positives (e.g., the distance between unexpected name tag and a valid manifest element name data is 3, and hence if the distance is set too high, our tool will regard the tag as a misspelled). To minimize possible false-positives, we set ùõº = 1 as default value for our tool, though it can be configured by users.

# 5 EVALUATION
We have implemented ManiScope in Python. For documentation parsing, we used the lxml  and BeautifulSoup4  libraries. To extract grammatical structures from sentences, we used the NLTK CoreNLP Parser 3 . We evaluated ManiScope on 1 million Android apps downloaded from Google Play between January 2020 and May 2020, and 0 million pre-installed apps collected from 4,580 Samsung firmware (released between September 2011 and January 2020) from SamMobile . We used axmlparserpy  to decode the binary manifest file of each APK into plain-text XML. Our experiments were carried out on a laptop running Ubuntu 18 with 8 GB RAM and an Intel Core i7-8500U CPU. In this section, we first present our evaluation results of schema extraction in ¬ß5. Then, we present our findings with regard to misconfigurations in ¬ß5. Lastly, we provide statistics on security-related misconfigurations in ¬ß5.