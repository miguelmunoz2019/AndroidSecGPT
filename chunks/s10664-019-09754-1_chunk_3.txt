# Recruitment of Developers
We invited the original programmers of the 2752 open-source apps we considered in the mining study. We first extracted all the GITHUB public repository addresses of the developers contributing to the considered apps. Then, we selected those contributors who participated in the development of a single app with at least 5 commits. While 5 may be a small number, we selected this threshold as done in previous works  with the only aim of excluding occasional developers or newcomers. Following this process, we invited a total of 1622 original developers, receiving a reply from 73 of them: the response rate was therefore close to 4%, which is similar to the one achieved by other survey studies (Palomba et al. 2014, 2018a, b; Vassallo et al. 2018). The questionnaire was created and distributed to participants using GOOGLE FORMS. 3 It was first available from September 15th to November 1th, 2018; then, it was open from January 20th to March 20th, 2019. The link to the questionnaire and a short introduction were sent to every recruited developer via e-mail. We estimated a completion time of 15 min. The questionnaire included a pre-survey section in which we asked developers about their profession, experience, and number of mobile apps developed so far. From the reported answers, the participants in the study were mostly professional developers, 53% specifically working in the mobile field, and 36% as software developer in general.

1 https://f-droid.org
2 https://www.optimizely.com/statistics/
3 https://www.google.us/intl/en/forms/about/
Empirical Software Engineering (2020) 25:2341–2377 2347
The others (11%) declared to be non-professional developers. Most of the developers (46%) have been developing mobile apps for more than 5 years. Only a few of them (9%) had an experience of less than 1 year. Moreover, the number of apps developed is more than 5 for 63% of participants.

# 2 Data Mining Process
To answer RQ1 and RQ2, we first needed to extract data from various sources. Therefore, we devised a data mining automated process, based on different components and operations. Our main aim was to collect the information regarding: (i) when the version of a library declared in a project changed, i.e., library update; (ii) when that library was upgraded by its developers, i.e., library release update. Collecting this data, we were able to compare the version change events with the releases of libraries, thus answering the research questions. Figure 1 shows the process we applied for each considered app, consisting of the following points (indicated with the same number in the figure):
1. Dataset parsing: the F-DROID repository data, provided as a single eXtensible Markup Language (XML) file, was parsed in order to retrieve the public repository address of the source code. As for the apps coming from ANDROID TIME MACHINE, they were available in a Neo4j graph-based database 5 which was queried to extract the public repository address of the apps.

2. Source code repository cloning: once established the public address of the repository, we performed a full repository GIT cloning (i.e., project downloading, including all the commits) in our local storage.

3. GIT commits extraction: we iterated through the list of commits by using the git checkout operation, and saved the files belonging to each single snapshot in separate directories. It allowed us to physically reproduce the status of the app source code during its entire development history.

4. GRADLE libraries parsing: we explored the commit directories and parsed the build.gradle files to retrieve the declarations of third-party libraries dependency for each app. The libraries were reported with the general pattern: &lt;configuration&gt; &lt;group&gt; :&lt;name&gt; :&lt;version&gt;. It is worth noting that the GRADLE definition language allows expressing library version declarations in different syntax ways, thus we included other patterns in the parsing operation. In particular, GRADLE allows the user to indicate the version of the libraries also in a dynamic way. For instance, 1.+ would mean that the targeted version is anything available at compile time that respects the declaration, whose first part is explicitly specified (1.) and the last dynamically (+). Being this pattern often present within the analyzed dataset, we dealt with it by considering the nearest available version at the time of the commit, reproducing a reasonable compile scenario. In this way, we collected the employment of the libraries, reporting the versions during the history of each observed app project. In this step, we had to discard 3292 apps from the ANDROID TIME MACHINE dataset because GRADLE files were absent or were not syntactically valid for the majority of the commits.

5. Dependencies mining: once we collected the list of libraries and the specific versions for each commit, we queried the most used repositories for Android libraries,
# Empirical Software Engineering (2020) 25:2341–2377
e.g., MAVEN, JCENTER, BINTRAY, looking for the release dates of those versions. We performed a “trial and error” process to find the repository having that piece of information. In some particular cases, the libraries were released as a GITHUB open source project, thus we queried the list of releases to retrieve the dates. For the Android Software Development Kit (SDK) libraries, we directly queried the GOOGLE servers and retrieved the release dates as HTTP content publishing dates. However, this process did not work out for 2678 apps of the ANDROID TIMEMACHINE dataset. Indeed, for these applications the declared third-party libraries were no longer available, thus not allowing us to process them.

# 6) Data storing:
As a final step, using a PYTHON script we grouped all the information on the library version changes and releases for each app in the form of a Comma-Separated Value (CSV) file containing the following four columns: (1) the “group”, i.e., the suffix of the library name, to which a certain library belongs, (2) the “name”, i.e., the actual name of the library, and (3) the “version”, i.e., the label of the library used in a certain moment, (4) the “date”, i.e., describing the date of the event, following the ISO-8601 format.

As final output of the data mining process, we could correctly collect information for 2461 apps of ANDROID TIMEMACHINE and 291 of F-DROID, for a total of 2752 apps. The data extraction process took approximately 9 weeks, using 4 Linux workstations, each having 8 cores CPU and 8 GB of RAM. The main reason behind the considerable amount of time is that we had to process all the available apps, namely 1181 from F-DROID and 8431 from ANDROID TIMEMACHINE, for a total of 9612 apps. In particular, we cloned all the GIT repositories and iterated over all their commits. Unfortunately, only during the last phases of the process we could exclude part of the apps, which did not respect the requirements, and save some time. It is worth remembering that the CSV files obtained at the end of the mining process are publicly available in the online appendix.

# 2 Methodology and Analysis Method
In the following we illustrate the methodologies and analysis methods we employed to address the research questions.

# 2 Technical Lag Methodology (RQ1)
Once completed the data extraction process, we started addressing RQ1. Firstly, we computed the number of times the version of libraries were changed, i.e., considering how many times the declaration of the library in the build.gradle file changed over time, with respect to the number of times a new version of the library was issued. In this way, we were able to understand whether the uses of such libraries are updated or not in the subject apps.

Secondly, we characterized whether the observed version changes referred to “upgrades”, i.e., a version change made to catch the latest release update of a library, or “downgrades”, i.e., version change to restore an old version of a library. To distinguish between the two categories of version changes, we mined the version history of the libraries available in the MAVEN repository, analyzing which of them were used by a certain mobile app during its history. Specifically, starting from the first commit on the repository until the end of the observed history, we iteratively considered commit pairs (Ci, Ci+1) and compared the build.gradle files in the two snapshots. For each library Lk used by an app, if the release version declared in the build.gradle of Ci+1 was higher than the release version declared in the build.gradle of Ci (according to the version history on MAVEN), then we considered it as an upgrade of Lk. Otherwise, if the release version of Lk in Ci+1 was lower than the release version of Lk in Ci, we counted a downgrade for Lk. In Section 3i we reported the distribution of the number of upgrades and downgrades for the investigated apps.

As for RQ1, we computed the technical lag affecting the apps in our dataset. Broadly speaking, technical lag has been defined by Zerouali et al. (2018, 2019) as the time between the availability of a new version of a third-party library and the usage of such version within an application.