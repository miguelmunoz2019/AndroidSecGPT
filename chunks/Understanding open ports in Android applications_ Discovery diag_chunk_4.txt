IV. DIAGNOSIS VIA STATIC ANALYSIS
While crowdsourcing is effective in discovering open ports, it does not reveal the code-level information for more in-depth understanding and diagnosis. To understand how open ports are actually constructed at the code level and its security implication, our pipeline includes a diagnosis phase through OPTool, a static analysis tool we develop specifically for the open-port diagnosis. Note that the goal of our diagnosis is not to rediscover (and analyze) all open ports identified by our crowdsourcing as we have shown that crowdsourcing is more effective for port discovery. Instead, we aim to understand the major open-port usages by enhancing typical Android static analysis with open-port context and semantics.

# IV. Open Port Analysis
as similar to OPAnalyzer , since UDP open ports have much more fixed usages (mainly for providing system-level networking services) as we have seen in Sec. III-C. In addition, overcoming the common difficulties in existing Android static analysis (e.g., dealing with dynamic or reflected codes) is also not our focus.

In this section, we first cover the background of code-level open port construction and the objectives of our analysis (Sec. IV-A), and then present the details of our static analysis tool OPTool (Sec. IV-B). Finally, we present the experiments we have performed (Sec. IV-C) and the diagnosis results (Sec. IV-D and Sec. IV-E).

# A. Open Port Construction and Our Analysis Objectives
At the code level, an open port on Android could be constructed in either Java or C/C++ native code. The native construction is similar to the traditional server-side programming by calling socket(), bind(), listen(), and accept() system calls sequentially, while the Java construction is to simply initialize a ServerSocket object and call the accept() API. The first objective of our static analysis is to trace each construction to (i) differentiate if the construction constitutes a “live port” or a “dead port,” and (ii) determine if a third-party SDK is on the call hierarchy. Such understanding is important because we want to filter out false positives of open-port constructions, and Android apps usually include various SDKs , especially the advertisement or analytics SDKs , , which could introduce open ports without developers’ awareness. This analysis is challenging because many networking libraries included in the app may contain open-port code that is never invoked by the host app. We therefore need a backward slicing analysis that can accurately trace back to every node on the call hierarchy. Such analysis has to be sensitive to the calling contexts, class hierarchy, implicit flows, and so on.

After digging deeper into the Java constructions, we find a total of 11 open-port constructor APIs shown in Listing 1. These ServerSocket APIs were originally from Java SDK, and have been directly ported over to Android. A convenient way of invoking these APIs is to pass only the port number parameter, and the APIs will automatically assign the addr and backlog parameters. The default setting of addr, interestingly, is the ANY IP address instead of the local loopback IP address. Moreover, if addr is set to null, the ANY IP address is also used by default. This legacy design in the original Java SDK might be appropriate for open ports on PCs but not for mobile — as we saw earlier in Table I, many Android open ports are designed for local usages. We consider this kind of “convenient” usage potentially insecure in the sense that they could inadvertently increase the attack surface.

In view of such potentially insecure use of the APIs, we come up our second objective of identifying the precise parameter values of all open-port constructions, so that we can evaluate the extent to which Android developers adopt such convenient but potentially insecure Java APIs. Note that these parameters might evolve across different objects, fields, arrays, and involve arithmetic operators and Android APIs. We need to understand all these semantics and calculate a complete representation of the parameters (instead of just capturing isolated constants in SAAF ). Last but not the least, it is important for our analysis to be efficient and scalable with a large number of Android apps.

# B. OPTool’s Design and Implementation
We design and implement a new static analysis tool called OPTool to specifically handle these challenges. Instead of generating traditional slicing paths, OPTool uses a structure called backward slicing graph (BSG) to simultaneously track multiple parameters (e.g., port and addr) and capture a complete representation of the parameters. On the generated BSGs, OPTool performs graph traversal and conducts semantic-aware constant propagation. We also include a preprocessing step in OPTool to quickly search for open-port constructions to improve its scalability.

Locating open-port constructions. This can be done by searching for the accept() API of ServerSocket and ServerSocketChannel classes, which are the only Android APIs to open TCP ports in Java. To enable fast searching and to handle the multidex issue (where Android apps split their bytecodes into multiple DEX files to overcome the limit of having a maximum of 65,536 methods ), we use dexdump  to dump (multiple) app bytecodes into a (combined) plaintext file and then perform the searching. Additionally, for the native code, OPTool searches each .so file for the four socket system calls.

Backward parameter slicing via BSG. After locating the open-port constructions, we apply backward slicing on their parameters to generate BSGs. Each BSG corresponds to one target open-port call site and records the slicing information of all its parameters and paths. The BSG not only enables OPTool to track multiple parameters in just one backward run, but also makes our analysis flow- and context-sensitive, e.g., the process of constructing BSG naturally records the calling context when analyzing the target of a function call so that it can always jump back to the original call site. OPTool is also sensitive to arrays and fields. With the help of forward constant propagation shown below, our backtracking just needs to taint both the instance field (or the array index) and its class object. Handling static fields does not need the extra help, but requires us to add their statically uninvoked <clinit> methods (where static fields get initialized) into the BSG.

# 30%
A notable challenge for Android backward slicing is to deal with implicit flows and callbacks. OPTool builds in support of class hierarchy, interface methods, asynchronous execution (e.g., in Thread, AsyncTask, and Handler), and major callbacks in the EdgeMiner list . Furthermore, we support backtracking across (explicit) inter-component communication (ICC) , and model Android component lifecycle.

# Semantic-aware constant propagation
After performing the inter-procedural backward slicing, we calculate the complete parameter representation in a forward manner. Besides the instruction semantics as in the typical forward propagation , we handle the following semantics:
# Maintaining object semantics
To determine the correct object for each instance field, we perform points-to analysis  for all new statements in the BSG. Specifically, we define an InstanceObj structure and initialize a unique InstanceObj object for each new statement. We then propagate the InstanceObj objects along the path and update their member fields if necessary. As a result, whenever a target instance field is to be resolved, we can retrieve its corresponding InstanceObj and extract its value. Array and ICC objects can be treated similarly with our modeling of the Intent APIs for updating/retrieving the ICC object fields.

# Modeling arithmetic and API semantics
We model not only the five major arithmetic operators, +, -, *, /, and responding statement in Java code, but also mathematical APIs, e.g., Math.abs(int) and Math.random() (via a special constant “RANDOM”). We also model all other encountered Android framework APIs, which include IP address APIs, Integer and String APIs, and SharedPreferences APIs. There are also a few APIs that are statically unresolvable, e.g., retrieving values from user interface via EditText.getText() and from database via Cursor.getInt(int). We save these cases to the final results without resolving their parameters.

# Removing dead ports and resolving SDK names
An important feature in OPTool is the removal of “dead ports” that are never executed. We analyze the port liveness in three steps of OPTool. First, during the backward slicing, we perform reachability analysis to exclude slices that cannot trace back to the app entry functions. Second, in the forward propagation, we consider ports with unresolvable parameters as dead ports. Among the remaining 258 (25%) apps, 110 of them implement open ports via dynamic code loading, and the rest of 148 apps are likely equipped with advanced code obfuscation (e.g., multiple anti-virus apps, such as Avast shown in Table I, appear in this set). For the 671 apps analyzed by OPTool for open-port parameters, it successfully recovers the parameters of 459 apps and identifies 48 statically unresolvable cases (e.g., values from EditText). Other cases are mainly due to the complex implicit flows (e.g., , ) that OPTool currently cannot address, even we have adopted the state-of-the-art methods , ,.

# TABLE III: Open-port SDKs detected in our dataset, and the number of apps affected by them.