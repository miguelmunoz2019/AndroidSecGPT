f) Finding the root cause: Having determined that syscalls to access the internal storage always succeed in the Samsung browser (independent of Android permissions), we injected a compiled module into the app to print its effective permission. From this, we found that the Samsung browser is in the group sdcard_rw, finally explaining why access to the internal storage is granted. However, it remained unclear how the app obtains membership of the sdcard_rw group.

To understand that, we repacked the app numerous times, each time removing one component and checking if group membership was removed. We started with removing native C libraries, then app components, and lastly classes and libraries in the app’s source code. We found that neither native C libraries, including the Terrace engine, nor app components affect access to internal storage.

However, we identified a specific metadata entry called “SDP” in the Android manifest of the application that grants the sdcard_rw permission to the Samsung browser.

&lt;meta-data android:name="sdp" android:value="enabled"/&gt;
We found that Secure Data Protection (SDP) is a Samsung Knox SDK component that can provide protection of sensitive data within an app.

g) Exploiting SDP to bypass storage permissions: It appears that any app can request the inclusion of SDP and its SDK through a simple metadata setting, both are used in the Samsung browser. To verify that, as a proof-of-concept we cloned the code base of the Samsung browser app, but changed its package name and self-signed the binary. This process is complex for an app with a large code base like Samsung browser, because it requires changes in several places (classes, directories and metadata) and because the authority names of app components must be altered as well. Taking this into account, we successfully created an independent app with a distinct name that uses SDP and has access to the internal storage. The app does not interfere with and can be installed alongside the original Samsung browser. Because it has a distinct package name, the cloned app can also be published to Google Play.

Alternatively, one can also include the SDP configuration in any other app. Thus, an adversary who can trick the user into installing a malicious app (e.g., disguised as a game or similar) can exploit this issue to exfiltrate the internal storage even though the user did not grant the Android storage permission. We reported these issues to Samsung on October 30, 2020 and February 9, 2021. They assigned two CVEs as follow: CVE-2021-25348 for bypassing the security check in the browser, and CVE-2021-25417 for the underlying privilege escalation issue in Samsung’s Android variant. At the time of reporting, both issues affected Android 10. Samsung has patched the issues on December 1, 2020 and June 8, 2021, respectively, with the Samsung browser version v13.

# Issue #3: Regardless of Android permission, the Samsung Knox SDP gives any app access to the internal storage without user approval.

# IV. DISCUSSION AND MITIGATIONS
Our case studies show that, even though the general topic has been extensively studied, handling of local URI schemes in mobile browsers still suffers from substantial oversights. Thus, we conclude that currently used test methods are insufficient to detect complex issues, especially those that are caused in interaction with external components, e.g., the Knox SDK or IME keyboards. Similarly, more principal mitigations appear to be required for the issues pointed out in this paper, especially those related to JavaScript and data URIs.

a) Mitigating self-XSS via the JavaScript scheme: As shown in Section III-A, hooking paste events is not sufficient to capture all sources of input into the address bar (other than the user typing): IME keyboards are third-party components and do not expose APIs for event listening (e.g., paste events), nor does Android provide a generic interface for this. The issue cannot be resolved through changes to the IME keyboard code, as the Android guidelines state that IME keyboards are not responsible for sanitising their output.

Apart from that, new input methods might be introduced in the future that could also bypass the existing address bar sanitisation logic. Google thus sought a solution that fundamentally prevents future similar issues but still allows manual typing of URIs with local schemes (like JavaScript). We thus propose a generic multi-character handler for Android that solves the issue. Our solution is based on the fact that user-typed text appears character-by-character, whereas pasted text (be it from normal or IME keyboard clipboard) is inserted as a block. Android keyboard uses the commitText() method to send text to a designated input field. If the sent text is a single character, it is sent as it. Otherwise, the keyboard sends a special key event along with the text in a block. Therefore, to intercept paste events, we can override the address bar’s onTextChange() method and inspect the number of inserted characters: if a multi-character insertion is detected, this indicates a paste event (from any source) that can be blocked.

We implemented this approach as a proof-of-concept and confirmed that it was able to intercept paste events from both the context menu and the IME keyboards. Alternately, instead of overriding the address bar’s onTextChange() method. It its possible to attach a TextWatcher to the address bar and override its onTextChange() method to achieve the same results. Google’s security team considered and our proposed solution. They adopted and deployed a fix using TextWatcher.

b) Standard approach to avoid phishing with data URIs: While most browsers adopt the correct approach to display the beginning of an URI, rather than its end, we found that Samsung browsers did not follow this behaviour: the prefix data URI scheme for long URIs is hidden as shown in Figure 4, enabling an adversary to create phishing URIs that appear to be hosted on legitimate origins. To resolve this issue for data URIs (and also other schemes), we propose that the community defines a standard approach to correctly and securely display URIs in browser. For example, such a standard could mandate to always show the start of the URI as implemented in most browsers (and also how Samsung patched the issue after our report).

c) Preventing permission system bypass on Samsung Android: The issue presented in Section III-C cannot be fully prevented at the browser level, as the underlying reason is rooted in Samsung’s modifications to Android. Because SDP does not authenticate apps that utilise it, any app may publicly subscribe to it and obtain access to internal storage. Therefore, an OS update or an update to the Knox SDK are required to patch the vulnerability. While Samsung informed us that the issue has been resolved for Android 10, we did not receive information on their mitigation strategy. However, recently, we noticed that SDP is deprecated in the latest Knox SDK patch v3.

d) Limitations: Our work is based on manual inspection of the most common local schemes in the most popular mobile browsers. Automating (parts of) our analysis and extending it to other browsers and schemes is an interesting research area that we leave for future work. We note that such automation is challenging: the found issues are related to complex interactions between UI components (e.g., text fields) and data entry methods (e.g., IME keyboards) or OS-specific configuration options.

# V. CONCLUSIONS
In this paper, we demonstrated several security issues in local URI schemes, affecting major mobile browsers including Google Chrome, Edge, Opera, and the Samsung browser. We show that a lack of proper sanitisation of JavaScript URIs can lead to self-XSS attacks, while data URIs can be abused for spoofing origins in phishing attacks. Finally, an issue in file URIs led us to discover a much deeper design flaw in Samsung’s Android, giving an arbitrary app access to the internal storage without user consent and bypassing the dedicated Android storage permission. Our results highlight that, even though the overall attack surface is well-understood, testing methods and tools to (semi)automatically detect URI handling issues in mobile browsers are still lacking and motivate future work in this direction..