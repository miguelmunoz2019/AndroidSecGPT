We further checked whether the MSs of the 9 Android apps and 4 iOS apps verify the signature properly. We got the notification message format according to cashiers’ documents, forged the message with incorrect signature and sent it to the Notify URL address of the MS. The result is that two of the nine Android and one of the four iOS apps’ servers still accept the payment. It indicates that even if the KEY is not leaked, attackers can still buy products without paying for it.

# 5. Flaws of network communication
Since Apple introduced “App Transport Security”, which defaults apps to requiring an HTTPS connection, we only detect the insecure network communication on Android apps. We manually test 87 most popular Android MAs chosen from the 2679 Android apps with embedded TP-SDKs to evaluate the security of their connections to the MS during the payment. The result is also shown in Table 4. There are 45 apps using HTTP connection and 42 apps using HTTPS connection. Among 42 apps who use HTTPS connection, four of them fail to validate SSL certificate properly. In addition, although we do not find proprietary protocol used by MA to communicate with the MS, some apps adopt home-brewed encryption schemes to protect the content in HTTP connection. Since those encryption schemes generally lack a mature session key management, we regard them as insecure without further investigating the security of their encryption. In all, these 49 vulnerable apps increase the risk of suffering Order Substituting Attack.

Although we did not test all the 2679 apps due to the inaccuracy of automatic analysis (see details and explanation in Section 4), the result of the 87 samples through manual work shows that a large proportion of merchants are still not cautious in implementing secure network communication. It is an astonishing result that there are still so many popular apps use insecure HTTP channel even if all of them are related to financial transaction. Note that the tested samples are the most popular apps with larger user amount and stricter security audit. We believe that those samples with less user amount may perform worse on building secure communication. Moreover, we find that cashiers only request the merchant to adopt HTTPS communication in the MA as an optional requirement rather than a mandatory enforcement. So merchants may ignore the request and implement insecure network communication.

# 5. Root cause inquiry
In our opinion, cashier as well as merchant should be blame for the vulnerabilities of in-app payment in mobile platform. For cashiers, they once released ambiguous, confusing and self-contradictory documents and sample codes (although they may correct some of them afterwards). Even the official sample code violates several security rules. As a result, merchants who follow these samples codes suffer our proposed attacks. Also inappropriate implementation of cashiers’ TP-SDK may expand the attack effect along with other flaws (as we mentioned in Section 3). For merchants, developers didn’t update their app in time when some of the cashiers correct their vulnerable sample code. In addition, merchant introduced their in-app payment functionality without fully understanding the third-party mobile payment model, along without necessary security testing and auditing.

We also have some interesting findings after reviewing the sample codes as well as manually checking the documents of the four TP-SDKs, Even though all of the four TP-SDK documents claim that the KEY needs to be kept in secret, their sample codes implement the process of message signing in their client apps, leading
W. Yang, J. Li and Y. Zhang et al. / Journal of Information Security and Applications 48 (2019) 102358  11
to the KEY leakage, except UniPay. It can be used to explain that so many MAs commit vulnerabilities when using WexPay, AliPay or BadPay (while become secure using UniPay). For example, the sample code released by WexPay directly commits Local Ordering, which obviously conflicts with its official process. We also find that the figure describing the process of the payment released by AliPay defines that the order should be signed in client app and so does the sample code, but the code comment in the sample says that the signing step should be in MS. We hypothesize that the contradiction between documents and sample code confused merchant developers a lot, leading those developers who follow the sample during their development to commit these mistakes. Only the sample code of UniPay implementation keeps consistent to their documents, making the order generating and signing in the MS code, so in our detection none of the APPs are flawed when using UniPay. Also, we find that UniPay provide very detailed materials to instruct developers to deploy their certificates and test development environment, etc. It shows that the cashier is the key factor to the security of merchant implementation. In addition, since the KEY of WexPay can be modified to any string as long as merchant notifies cashier, we find that some leaked keys, which are supposed to be random strings, are modified to a weak key such as 12345678912345678912345678912345, or just the name of merchant, which may suffer brute-force dictionary attack, or social engineering.

We also try to discover the incentive of flawed MSs. We find that not all cashiers release the sample code of MS, thus merchant needs to implement it without example by themselves. Even if there is sample code for MS, server implementation varies a lot compared with the client. Merchant may implement their servers by using Java, PHP, .NET, Python or even native language, which are out of the language scope of sample code released by cashier. Even though cashiers suggest merchants to do these validations in documents or some even implement them in sample code if it has, merchant may also ignore it during the code transplant or without existing correct code examples.

Although the third-party in-app payment involves financial transaction and should have high security level, none of the cashiers emphasize the security in particular. Some cashiers just mention it (e.g., suggesting the merchant to implement the network communication in HTTPS in the end of the documents), which is easy to be ignored by merchants. Not to mention the fact that improper designed TP-SDK and incorrect documents/sample codes released by cashiers. Previous work [1–4] mainly focus on the security of the merchant. Acar et al.  ascribe Android code insecurity to informal documentation such as Stack Overflow, while official API documentation is secure but hard to use. However, our work shows that when it comes to the mobile third-party in-app payment, even official documents/sample code released by cashiers lead to the code insecurity, which may be helpful to improve the security of the whole ecosystem of third-party payment.

# 5. Case studies
We choose several flawed merchant apps to perform real attacks. It shows that these detected violations of security rules can directly lead to serious consequence including financial loss in real world. binary analysis framework that supports iOS app binary code instrumentation . We have implemented an Frida script to tamper the amount money to only one yuan in the order information and re-signed the message. Then the TP-SDK successfully accepted the order information, asking for paying this appointment with one yuan. After we paid, the app in the MA showed that we successfully make an appointment to the doctor with the registration fee paid with the original price (30 yuan). Even when we went to the doctor afterwards, our “less paid” registration fee did not attract any awareness, which indicates that the merchant fails to confirm the notified order details. We then reported this vulnerability to the merchant and helped update the app in a week.

# 5. Order Tampering in iOS app
The first case is an iOS app used by patients to make appointments with doctors. This app requires the patients to pay the registration fee while making an appointment. However, the app violated Security Rule 1, signing the order information in the client app. We hooked function used to execute SHA1-RSA signing of the order information in the MA with the help of Frida, a universal.

# 5. Order substituting
We proved that Order Substituting Attack can be automated and let user pay for the attacker’s order without awareness. We employed the attack on a wireless router of our local area network. Since we control the router, we can conduct MITM attack to the devices in the same LAN. We set a MITM proxy on the router to replace self-signed HTTPS certificate to the original one and decrypt the content of HTTPS connection.