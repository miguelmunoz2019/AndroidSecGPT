The type system for well-typed code in  is inductively defined as a relation typing (Fig. 12). The relation checks that a term is well-typed (follows certain rules) in the environment. There are twelve typing rules (each begin with a vertical line |) for twelve terms. These terms are selected in the rules based on their relevance for enforcing best practices. In addition to a rule for free variables (typing_var, lines 2–5, Fig. 12), there is a constructor for each rule of the type system in . The predicate ok ensures the environment does not have duplicate bindings and the relation binds binds the variable x with type T in the environment E.

To read data from a content provider (lines 6–8, Fig. 12) with permissions READ/WRITE in its context, the reader component must have the same READ/WRITE permissions (data can flow from contexts with at most permission WRITE to contexts with at least permission READ ). Similarly, a trusted component (with highest integrity level >) can write data (lines 9–12) with the WRITE label to a provider with specified permission WRITE. The rule typing_reg (lines 13–17) registers a new receiver and sets it with permission SEND that will be required in the context to send data to.

16556 VOLUME 7, 2019
# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
This rule deals with binders and cofinite quantification  is introduced here. The body of term t is opened up with a free variable named x where the set L is some finite set of names chosen. A broadcast receiver can receive intents only if it has the permission RECEIVE in its context. The rest of the rules are either straight forward or explained in . Note that, the rule typing_lett and typing_reg deals with binders and hence are formalized using cofinite quantification.

The type checker, as defined earlier, can be applied to any term (program) and their correctness can be checked in presence of other conditions. Just as an example, consider an activity component of the phone application requests (read) a contact x from the content provider of the contacts application. This is modeled as program read x with security labels READ/WRITE for the data x and content provider context. The best practice enforces the security policy described in Section I: the data from a content provider with a label can only be read by a component with a label at least as high as the content provider. The correctness of the term in accordance to the best practice is stated as a lemma in Fig. 13 and proved in proof assistant Coq Conformance of other terms with the security policy can similarly be stated and proved mechanically. Readers are advised to refer to  for other encoded examples in the type system defined in Fig. 3 and formalized in 12.

It states that if an expression is well-typed in an environment 0, then it is well-typed after the environment is extended with a name bound to some type U. Formally,
(R-WEAKENING)
0 ` e : T
0, n : U ` e : T
The same property is formalized as a lemma in Fig. 14, where E and F are non-empty environments, the operator ++ concatenates the two environments, and the predicate ok ensures the concatenation of two environments do not have double bindings.

To prove this lemma, a more stronger property needs to be proved first. The property is strong in the sense that the property holds for extension of the environment at the middle. This lemma is proved using induction on the relation typing. This stronger property, lemma typing_weakening_strengthened in Fig. 15, is then used (simple application) in the proof of lemma typing_weakening in Fig. 14.

# IV. PROOF OF SOUNDNESS PROPERTIES
The formal definition of syntax of language to describe Android applications, basic operation, and Android type system in theorem prover altogether build language-based security on Android systems. To demonstrate that the formal development can effectively be used to formally reason about the type system and Android terms (applications), formal proof of properties of the type system are carried out in the Coq tool.

The type system in Fig. 12 establishes rules for well-formed (safe) code. To ensure that well-typed expressions indeed are correct (allows only safe data flows) and will never go wrong, type soundness properties of the type system itself needs to be satisfied. Proofs of two properties, weakening and strengthening, of the type system defined in Fig. 12 are carried out in theorem prover.

# A. PROOF OF WEAKENING PROPERTY
The weakening property states that adding type bindings to the environment does not affect derivability. In other words,
(R-STRENGTHENING)
0, n : U ` e : T        n 6 ∈ {freenamesofe}
0 ` e : T
The above rule is formalized in Coq as lemma in Fig. 16. The function fv returns the set of free names in term e. This lemma is proved using induction on the relation typing.

# C. DISCUSSION
The first soundness property, weakening, of our type system asserts that if an Android application component is proved
All the Coq definitions and proofs are available from the Github repository at https://github.com/wilstef/secdroid
VOLUME 7, 2019
# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
# V. RELATED WORK
Interactive proof assistants have been applied in the past to investigate Android systems security. In a recent work by one of the co-authors , they formally analyzed the security of Android inter-component communication based on intent messages. A formal model, dubbed as Crash-Safe, was defined in Coq and used in formal verification of crash safety property of Android applications. CrashSafe is a lightweight formal model of Android inter-component communication, however, it does not include Android permissions system. Even though, there are means to circumvent Android permissions , but it is still the main defence mechanism of Android system, if used carefully by applications developer. Shin et al. ,  proposed formal model of Android permission mechanism and investigated it by specifying Android system elements, characterized security properties and proved that the system preserves the security properties. They specified the permission mechanism for Android system as a state machine and proved in Coq, the system is secure over the specified states and transitions. Their work focuses on the behavioral aspect of the framework rather than evaluating applications based on the Android permissions in order to exclude malicious ones. In a similar work, Betarte et al. ,  developed a comprehensive formal specification of the permissions in Coq and verified several security properties. These formal models either do not address security issues related to Android permissions  or capture only specific security vulnerabilities in Android permissions systems –. The type checker developed in this paper, on the other hand, enforces best practices, which capture classes of security vulnerabilities. Furthermore, the enforcement mechanism in this paper is based on language-based security technique, which offers numerous advantages over other techniques ,.

ScanDroid  extracts application specific security specifications from applications’ manifests and applies data flow analysis to check data flow consistency with respect to the specifications. Felt et al.  found that about one-third of applications request permissions they normally do not need. They developed a tool Stowaway to detect overprivilege in Android applications by finding the maximum set of permissions required for an application and compared it with the set of permissions requested. Stowaway can determine if an application is overprivileged, however, it does not formally study the security implications of overprivilege. There are a number of other tools developed to reveal potential risks in Android system or improve their overall security. Taint-Droid  demonstrates potential threats to phone users’ data from third-party applications. Chin et al. developed Com-Droid to improve Android applications security by detecting inter-application communication. A number of tools, such as DroidSafe , Horndroid  and Flowdroid  to name a few, have been proposed to analyze the data flow security of Android applications.

Locally nameless representation has been used in a number of other formal results using theorem prover Coq or Isabelle/HOL. A non-exhaustive list of research papers employing locally nameless representation is given in . Using Coq theorem prover, Jia et al.  proved decidability and soundness of the type system of programming language AURA. Benton and Koutavas  introduced bisimulation for v-calculus and formalized its metatheory in Coq. Garrigue  formalized a certified interpreter for the core ML using theorem prover Coq.