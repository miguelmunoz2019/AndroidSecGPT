HAL lies on the services layer of the Android system. The service layer consists of Android runtime libraries and native C libraries. These can be easily accessed by the application layer to perform various Android related functions such as accessing the camera module to record, media module to play something, notification service for sending notifications, and various other Android provided services.

The Java API layer is placed on the top of the service layer. It is an intermediary layer that makes it easy for the application layer to access Android services using Java-based APIs corresponding to them. The topmost layer is the application layer where all the applications installed on the device remain and make use of the Java API framework to access various required Android services.

The Android low-level security model is based on application sandboxing , . Android sandboxing is the process of isolating an application in the system. It prevents outside influences on the layers mentioned in the architecture. All applications are assigned a user ID while they are running. They have access rights to their own files only. It prevents outside malware and security threats; if an application experiences a security breach, other applications’ operations will not be affected.

Android provides hardware-backed key protection for cryptographic services. The stored keys provide a safe, secure channel for the authentication of user data. Verified Boot is used to check the state of the system when it starts . It verifies whether the system is in a good state. In Android 8 (Oreo), Google introduced Project Treble to increase low-level security , . Project Treble separates the open-source Android OS framework from the hardware code implementations at the vendor level. It has had a positive impact on device security and the speed of updates.

# B. APPLICATION SECURITY
Android uses the permission model to prevent an app from using sensitive data and resources that are not required during runtime. Apps need corresponding permissions to use APIs to interact with the underlying system –. All permissions taken by an app must be specified in the application’s manifest file.

Permissions are grouped into three categories corresponding to the risk and security level associated with resources and APIs: normal, dangerous, and signature permissions. Normal permissions include the permissions where the application must interact with resources out of the sandbox and do not pose any threat to user privacy. Normal permissions include Bluetooth, KILL_BACKGROUND_PROCESS, and Internet. Signature permissions are granted at the install time and allow an application to use the permissions signed by the identical certificate. VPN_SERVICE is included in the signature permissions. Dangerous permissions are the permissions that could pose a potential security threat or a threat to user privacy. The user is required to approve each of these permissions needed by the application after installation. SMS, storage, and camera permissions are some of the permissions included in this category.

In earlier versions (Until Android 5), users were not allowed to choose a subset of permissions. They needed to accept all the permissions mentioned by the application in their manifest file to install the software application into their devices. In Android 6 (Android Marshmallow), Google introduced a new mechanism for permission, called runtime permission . Where users are notified of any dangerous permissions at runtime and choose not to give specific permission, it gives a choice to the user to understand the usage of the app and determine whether the requested permission is required for the proper functioning of the app. In some cases, if permissions are not given, the app may not work correctly. Ultimately, the user is forced to accept all the permissions to use the app.

Android’s System Alert Window API was modified in Android 8. It does not allow apps to draw special windows used to notify the user of the critical messages. It has resulted in the prevention of clickjacking that was used by malicious apps creating overlays on the screen. Users are now allowed to tap the notification to hide overlays.

For protecting user phone data, Android provides strict policies for sensitive APIs. In Android 8 and above, the GET_ACCOUNTS permission is no longer sufficient to gain complete access to the list of accounts active on the device. For example, the user is now required to grant permission to the Gmail app to access the Google account on the device even though Google owns Gmail. As concrete examples, Settings.Secure.ANDROID_ID or SSAID is an ID provided to all apps. To prevent misuse of the ANDROID_ID value, Android 8 provides a mechanism that does not allow the change in ANDROID_ID when the application is re-installed until the package name and key are identical. Another feature, Build.getSerial() returns the actual serial number of the device till the caller holds the PHONE permission. Android 8 has deprecated this API’s use, and it protects the serial number of the device from being misused by the applications.

Android has seen advancements in hardening security policies. However, it can be noted that as of October 2020, only 40% of devices are running Android 10, and 22% of devices are running Android 9 (Pie). More than 35 percent of users are using older versions of Android on their phones . Due to a lack of knowledge in users and lack of security in sensitive APIs, users are often manipulated into using over-privileged applications.

# III. RELATED WORK
With the growth of Android in the market, malicious applications have also surfaced, which has driven many studies and research works towards it. Iman and Aala  proposed a comprehensive analysis of Android permission systems. They provided important insight into the permission system evolution over the years and how permission usage has increased up to 73% in top applications by 2020.

Sanz et al.  proposed a method to recognize malicious Android applications with the help of machine learning (ML) techniques, which extracts the Android permissions from the application. Permissions extracted from the Android Manifest file of an app were utilized to categorize an application as malware using the machine learning model for Android permissions. Karim et al.  suggested permissions of an Android app using the collaborative filtering method, associative rule mining, and Bayesian text mining. This approach tried to predict the permissions that must be used by the application after making an association with similar applications. This was developed to help developers know what type of permissions their app might require; it does not include the feedback from the end-users.

Mathur et al.  presented a malware detection framework for Android called NATICUSdroid, which investigated and classified benign and malware using statistically selected native and custom Android permissions as features for various ML classifiers. However, these approaches were limited to only mobile resources for its processing and classification. Furthermore, these approaches lacked learning abilities, dynamic processing, and they did nothing to stop these malicious activities in the application, which kept them from being overly successful.

Azim and Neamtiu  used static dataflow analysis on the apps bytecode for systematic testing of Android apps, which as a result, constructed a high-level control flow graph among various activities inside the apps. They deduced a method of depth-first flow among these activities, which mimicked the user actions. This approach showed good potential and was the basis of dynamic analysis, though it was still unable to make it learn for itself. It used mobile processing power to do the analysis, which has some shortcomings.

Ricardo et al.  worked on a framework for Android apps, which instrumented the app with injections to keep track of any malicious activity an app performs. This approach used dynamic analysis and is the basis of the proposed work. However, this approach was also unable to use the previous results and did not learn from the apps.

Shahriar et al.  proposed an approach to reduce the number of apps needed to be sandboxed to determine if they are malicious. They used Latent Semantic Indexing (LSI) to identify malware apps though this was limited to the identification of malware applications.

Sadeghi et al.  presented a Terminator framework which can provide an effective yet non-disruptive defense against permission-induced attacks by identifying the system’s safe state and controlling the permission based on this. It provided access to the permissions and revoked identified unsafe permissions without modifying the app’s implementation logic.

Zhang et al.  presented VetDroid to analyze fine-grained causes of information leaks by capturing the app’s sensitive behaviors with permission to use graphs. Security analysts were utilized to analyze the internal sensitive behaviors of the app by reconstructing these behaviors after they have been allowed dangerous permissions. Although, it has a lot of potential but lacks a way to inform and educate users about security threats and does nothing to protect it.

Wu et al.  proposed a system that achieved the robust and interpretable classification of Android malware. Their work demonstrated state-of-the-art obfuscation-resilient malware analysis which can work on obfuscated Android apps hiding their functionality. Mill et al.  proposed a way to classify both obfuscated and unobfuscated apps as malicious or benign.