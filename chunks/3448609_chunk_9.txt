ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

# The Android Platform Security Model
# 4. Network Sandboxing Improvements in Android Releases
Android 10 introduced support for Adiantium , a new wide-block cipher mode based on AES, ChaCha, and Poly1305 to enable full device encryption without hardware AES acceleration support. While this does not change encryption of data at rest for devices with existing AES support, lower-end processors can now also encrypt all data without prohibitive performance impact. The significant implication is that all devices shipping originally with Android 10 are required to encrypt all data by default without any further exemptions, homogenizing the Android ecosystem in that aspect.

Note that encryption of data at rest helps significantly with enforcing rule © (safe reset), as effectively wiping user data only requires to delete the master key material, which is much quicker and not subject to the complexities of, e.g., flash translation layer interactions.

# 4 Encryption of Data in Transit
Android assumes that all networks are hostile and could be injecting attacks or spying on traffic. To ensure that network level adversaries do not bypass app data protections, Android takes the stance that all network traffic should be end-to-end encrypted. Link level encryption is insufficient. This primarily protects against [T.N1] and [T.N2].

In addition to ensuring that connections use encryption, Android focuses heavily on ensuring that the encryption is used correctly. While TLS options are secure by default, we have seen that it is easy for developers to incorrectly customize TLS in a way that leaves their traffic vulnerable to OPA/MITM . Table 4 lists recent improvements in terms of making network connections safe by default.

# 4 Exploit Mitigation
A robust security system should assume that software vulnerabilities exist and actively defend against them. Historically, about 85% of security vulnerabilities on Android result from unsafe memory access (cf. Reference [92, slide 54]). While this section primarily describes mitigations against memory unsafety ([T.P1-P4], [T.N2], [T.A1-A3,A7], [T.D2]) we note that the best defense is the memory safety offered by languages such as Java or Kotlin. Much of the Android framework is written in Java, effectively defending large swathes of the OS from entire categories of security bugs.

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

R. Mayrhofer et al.

Android mandates the use of a number of mitigations including ASLR , RWX memory restrictions (e.g., W ⊕ X, cf. Reference ), and buffer overflow protections (such as stack-protector for the stack and allocator protections for the heap). Similar protections are mandated for Android kernels.

In addition to the mitigations listed above, Android is selectively enabling new mitigations, focusing first on code areas that are remotely reachable (e.g., the media frameworks ) or have a history of high severity security vulnerabilities (e.g., the kernel). Android has pioneered the use of LLVM undefined behavior sanitizer and other address sanitizers  in production devices to protect against integer overflow vulnerabilities in the media frameworks and other security sensitive components. Android is also rolling out Control Flow Integrity (CFI)  in the kernel and security sensitive userspace components including media, Bluetooth, WiFi, NFC, and parsers  in a fine-grained variant as implemented by current LLVM  that improves upon previous, coarse-grained approaches that have been shown to be ineffective . Starting with Android 10, the common Android kernel as well as parts of the Bluetooth stack can additionally be protected against backwards-edge exploitation through the use of Shadow Call Stack (SCS), again as implemented by current LLVM  as the best tradeoff between performance overhead and effectiveness.

These code and runtime safety mitigation methods work in tandem with isolation and containment mechanisms (cf. Tables 1 to 3 for added mitigations over time) to form many layers of defense; even if one layer fails, other mechanisms aim to prevent a successful exploitation chain. Mitigation mechanisms also help to uphold rules © (open ecosystem) and © (compatibility) without placing additional assumptions on which languages apps are written in.

However, there are other types of exploits than apps directly trying to circumvent security controls of the platform or other apps: malicious apps can try to mislead users through deceptive UI tactics to either receive technical consent grants against users’ interests (including clickjacking ) ([T.A4]–[T.A6]), existing legitimate apps can be repackaged together with malicious code ([T.A1]–[T.A2]), or look-alike and similarly named apps could try to get users to install them instead of other well-known apps. Such user deception is not only a problem in the Android ecosystem but more generally of any UI-based interaction. As deception attacks tend to develop and change quickly, platform mitigations are often too slow to roll out, making dynamic blocking more effective. Within the Android ecosystem, mitigations against such kinds of exploits are therefore based on multiple mechanisms, notably submission-time checks on Google Play and on-device runtime checks with Google Play Protect. Nonetheless, platform security has adapted over time to make certain classes of UI deception exploits harder or impossible, e.g., through restricting SYSTEM_ALERT_WINDOW, background activity limitations, or scoped external storage (cf. Table 1).

# 4 System Integrity
Finally, system (sometimes also referred to as device) integrity is an important defense against attackers gaining a persistent foothold. AOSP has supported Verified Boot using the Linux kernel dm-verity support since Android KitKat, providing strong integrity enforcement for the TCB and system components to implement rule © (safe reset). Verified Boot  has been mandated since Android Nougat (with an exemption granted to devices that cannot perform AES crypto above 50 MiB/s up to Android 8, but no exemptions starting with Android 9) and makes modifications to the boot chain detectable by verifying the boot, TEE, and additional vendor/OEM partitions, as well as performing on-access verification of blocks on the system partition . That is, attackers cannot permanently modify the TCB even after all previous layers of defense have failed, leading to a successful kernel compromise. Note that this assumes the primary boot loader as root of trust.

ACM Transactions on Privacy and Security, Vol. 24, No. 3, Article 19. Publication date: April 2021.

# The Android Platform Security Model
to still be intact. As this is typically implemented in a ROM mask in sufficiently simple code, critical bugs at that stage are less likely.

Additionally, rollback protection with hardware support (counters stored in tamper-proof persistent storage, e.g., a separate TRH as used for Strongbox or enforced through RPMB as implemented in a combination of TEE and eMMC controller ) prevents attacks from flashing a properly signed but outdated system image that has known vulnerabilities and could be exploited. Finally, the Verified Boot state is included in key attestation certificates (provided by Keymaster/Strongbox) in the deviceLocked and verifiedBootState fields, which can be verified by apps as well as passed onto backend services to remotely verify boot integrity  to support rule ©3 (compatibility).

Starting with Android 10 on some devices supporting the latest Android Verified Boot (AVB), the recommended default implementation for verifying the integrity of read-only partitions , version 2, the VBMeta struct digest (a top-level hash over all parts) is included in these key attestation certificates to support firmware transparency by verifying that digest match released firmware images . In combination with server side validation, this can be used as a form of remote system integrity attestation akin to PCR verification with trusted platform modules. Integrity of firmware for other CPUs (including, but not limited to, the various radio chipsets, the GPU, touch screen controllers, etc.) is out of the scope of AVB at the time of this writing and is typically handled by OEM-specific boot loaders.

# 4 Verification Key Hierarchy and Updating.

While the details for early boot stages are highly dependent on the respective chipset hardware and low-level boot loaders, Android devices generally use at least the following keys for verifying system integrity:
1. The first (and potentially multiple intermediate) boot loader(s) is/are signed by a key KA held by the hardware manufacturer and verified through a public key embedded in the chipset ROM mask. This key cannot be changed.

2. The (final) bootloader responsible for loading the Android Linux kernel is verified through a key KB embedded in a previous bootloader. Updating this signing key is chipset specific, but may be possible in the field by updating a previous, intermediate bootloader block. Android 10 strongly recommends that this bootloader use the reference implementation of Android Verified Boot  and VBMeta structs for verifying all read-only (e.g., system, vendor, etc.) partitions.