To show comprehensiveness of their approach, Aydemir et al.  created several large formal developments using Coq proof assistant. The mechanization of the formal language in this paper is built on top of the libraries developed by Aydemir et al. In the next section, formal definitions are introduced. For further details about the functions used, readers are advised to refer to proof assistant Coq libraries in.

# A. LANGUAGE SYNTAX
To begin with, Android permissions are defined as an inductive type Pm (Fig. 5) using Coq Inductive keyword of sort Type. These permissions (each make a constructor of type Pm) are the following: an application requires to have CALL permission in order to create an activity, BIND is needed for an application to bind to a service, READ/WRITE are required to read/write from/to a content provider, respectively. Similarly, an application can send data to a receiver only if it has SEND permission and the receiver likewise can receive it only if it has the permission RECEIVE. The two permissions TOP and BOTTOM bound other types above (highest authority) and below (lowest authority), respectively.

# III. FORMALIZING LANGUAGE-BASED ANDROID SECURITY
To protect against application-level attacks on modern computer systems, language-based security techniques are applied at programming language (application) level , . The formal language for representing Android applications and the type system (language-based Android security) , enforcing best practices, cannot be read by computer-aided verification tool and hence are not fit for mechanical reasoning and computer-based checking. To enable computer-based checking and reasoning, the language and type checker both must be defined in the logic of a theorem prover. In this section, the formal language and the type system enforcing the best practices for Android applications development, as described in , are extended with locally nameless representation and formalized in the logic of theorem prover. The reason formal language and type system in  are chosen for mechanization is that they are simple and abstract while at the same time they are expressive enough to establish formal reasoning against Android permissions.

To track data flow within applications, a system of security types ty for the language is inductively defined (Fig. 6) to label data. The type ty_stuck is given to programs that are blocked due to access control and the type ty_dnc represents data whose security is of no concern The types ty_pro, ty_act and ty_rvr are, respectively, for components provider, activity and receiver and are given to names bound in the environment. Following , services are encoded with receivers; therefore, there is no separate type for services. The third and fourth arguments of type ty in ty_act represent stack type, which is given to the code run by an activity (window). Values returned to the current window have type ty (second argument).

Inside type ty is a mutually dependent type Ty with a subtype constructor Ty_sub, which would be used to
2This is, instead, represented by ’_’ in.

# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
convert type ty to Ty (see below). The type system is extended with two constructors Ty_bvar and Ty_fvar for bound and free variables, respectively. The argument of type atom in Ty_fvar will be used to represent free names. The argument of type nat in Ty_bvar is used to model bound variables using de Bruijn indexes. In addition, it should be noted that the constructors in type ty in  are more specific while they are defined parametric in Fig. 6 to make them more general. Such a general representation enables to universally quantify over permission, type, number and name in the proofs, extending the scope of formal developments and proofs.

To write Android applications (programs), terms are inductively defined as shown in Fig. 7. To formally implement the locally nameless approach in Coq, bound and free variables in terms need to be distinguished. As mentioned before, de Bruijn indices and names are used to represent bound and free variables, respectively. The term bvar takes a natural number as the index to represent bound variables and fvar takes a name (of type atom) to represent free variables. The natural number index is the number of abstractions needed to be traversed to reach abstraction binding that variable. Lambda abstraction is formalized with constructor lam with the only argument defines the body of the abstraction. Calling an activity is modeled using call, which gets an activity name and a value that is passed to the activity. Unlike in  where name and value pair is separately defined as an intent, these parameters of type atom make the two arguments of constructor call. The type atom abstractly model both implicit and explicit intents where the identifier of type atom represents component name (to be accessed) or action (to be performed), respectively. Our formal setting captures data flow through intents either if the component is accessed by name or action. In other words, our type system captures flows through both implicit and explicit intents.

The program ret returns control by popping the current window off the stack and returns control to the previous activity. To bind to a service, the program bind is used, where the first two arguments make the intent and the third argument is the code to be executed. The program reg registers a new receiver with a body (second argument) and sets it with a permission (first argument). To send intent to a receiver, the program send is used where the first argument of type Pm is the permission required and last two arguments of type atom make the intent to be sent. The next five constructors are for reading/writing from/to a provider, evaluate, fork, choice, result and void, respectively.

# B. OPENING AND SUBSTITUTION OPERATIONS
The major advantage of locally nameless representation is that all alpha-equivalent terms now have unique representation and thus issues with alpha-equivalence and variable capture are avoided. To formally implement locally nameless representation, some basic operations are required. The function fv (free variables) is recursively defined in Fig. 8 which collects a set of names that are free in terms. There is no free variable in term bvar and void and singleton sets of names are returned for the term fvar, ret, read, and result where the name in the argument of each term is the only member of the set returned. For all other terms, the set of free names is the union of names in all sub-terms.

An important operation is opening a term (abstractions such as lambda terms and let expressions) where a bound variable in a term is instantiated (replaced) with a term.

VOLUME 7, 2019
16555
# W. Khan et al.: Formal Analysis of Language-Based Android Security Using Theorem Proving Approach
This operation is used to pass through a binder and turn a bound variable into a free variable. The function open_rec (Fig. 9) takes an index representing a bound variable and two terms and replaces the index (bound variable) in one term (third argument) with another term (second argument). The function has no effect on terms without bound variables (such as fvar, call, ret, read, write, result and void). The function is defined general that opens up terms deep into multiple binders. However, this complicates the proof and is, therefore, limited to zero index by another definition in Fig. 10.

To ease proofs, the free variable substitution (Fig. 11) operation is required, which replaces a free variable (first argument) in a term (third argument) with another term (second argument). An environment env is defined as a list of name and type pairs each binding a variable with a type. An environment is well-formed (ok) if there is no duplicated name (each atom is bounded at most once).

# C. FORMALIZING TYPE CHECKER
To capture secure data flows within mobile device and enforce best practices in applications development, a type checker is defined in the theorem prover. The type checker can be defined either as an inductive type or as a recursive function. Inductive definitions in theorem prover are favorable when formal proofs are carried out while recursive definitions are good for executing programs. As binders in programming languages complicates formal reasoning in theorem provers, the focus should be to facilitate the more challenging part: the formal proofs in theorem prover. This motivates towards inductive definition of Android type checker in Coq.