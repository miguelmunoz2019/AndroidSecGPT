Results from P1, P4 and P6 indicated that it was difficult to evaluate their code because a working client was required to test server functionalities and a working server was required to test client functionalities. Therefore, it was difficult to test the code they developed and evaluate its progress. P1 in their questionnaire response commented on this and mentioned “It was somewhat difficult [to evaluate the progress]. In order to test the server and client we should have their counterpart implemented”. We observed this in the screen recordings and think aloud results of P4 and P6. Once the client is implemented, P6 wanted to test the code they developed, but they could not do so. It was evident in his think aloud results where they mentioned “We now have client socket, of course it does not run, because we need server side”.

Other participants mentioned in their questionnaire responses that stopping in the middle of the task and evaluating the progress was easy. From their responses, we identified that the reason for this mismatch of opinion of participants was their level of expectation. Participants who did not expect to evaluate the progress after completing only 1 component (i.e. server or client) were happy with the opportunities they had to evaluate the progress. P10 in their questionnaire response.

# 62
# Computers & Security 80 (2019) 54–73
commented on their experience of evaluating the progress in the middle of the task saying “[Stopping in the middle and evaluating progress was] Quite easy. I checked the compilation / execution after: 1. defining the new SSLSockets 2. adding System properties (keystores) 3. tampering with the keystore.jks passwords”. We identified when observing the recording that P10 did not get the client and the server to work properly at every time they executed the client and the server. However, they had some expected outcomes of each execution and checked whether or not it gives the expected outcome.

# 5. Premature commitment of JSSE API
Premature commitment describes “The amount of decisions that developers have to make when writing code for a given scenario and the consequences of those decisions.”. The API is more usable if the programmer needs to take minimum decisions while using the API.

P3 and P4 reported in their questionnaire responses that there were certain subtasks that needed to be completed prior to others and they had to learn that through trial and error. P3 mentioned in their responses to the questionnaire that “I had to learn through trial and error, which parts need to be implemented first, for example, to write code to add keystore first or do that after creating the connection”. P4 also described a similar experience. They mentioned that “Some objects require parameters you have to account for beforehand, I had to identify those by learning through trial and error”.

# 5. Penetrability of JSSE API
Penetrability describes “the way the API facilitates exploration, analysis and understanding of its components and its security related information, and the way a targeted developer should go about retrieving what is needed.”. This discusses how components of API including its documentation facilitate programmers to explore, analyze and understand the API. Interestingly, this was the aspect that participants of our study reported to have the most number of issues.

From the 25 issues we identified in the area of penetrability, 17 were only experienced by 1 participant. Therefore, as we did for other dimensions, we gave more focus to the 8 issues (Table 5) that were experienced by at least 2 participants.

We identified 4 main areas of concern in these 8 issues, which are:
- Issues related to the structure/presentation of details of the API
- Issues related to examples on how to use the API
- Issues related to details available about keystores/truststores and SSL protocol
- Issues related to the amount of details shown in error messages
Participants reported in their responses to the questionnaire that details about the API are not well structured. P1 highlighted this in their response to the questionnaire mentioning “It was difficult to find details about the API while using it, because documentation is not written in a structured manner”. P4 also suggested in their questionnaire response that “The JSSE API is all over the place, so it was hard to find details”. P6 also provided useful thoughts on this mentioning that “Details are described from an implementation point of view, not developer’s [i.e. application developer who use the API] point of view”. We observed this issue while observing screen recordings and think aloud results of P2, P4, P8 and P9 as well. Another issue related to the structure of details of the API is that details of the API are all over the place and the API does not provide any guidance for programmers into doing the right thing. P6 mentioned in their response to the questionnaire that there was no guidance provided to find required details of the API. We identified that P3, P4, P5 and P9 also experienced this issue while observing their screen recordings and think-aloud results.

Another aspect of penetrability that we identified was related to examples of using JSSE API. We observed in questionnaire responses of P1, P2 and P11 as well as in video recordings of P1, P2, P4 and P10 that it was difficult to find end to end examples on how to use the API. P4 and P11 said in their questionnaire responses that there is a lack of examples. P1 in his response to the questionnaire mentioned that “end to end examples were more difficult to find”. We observed this in participant screen recordings and think-aloud results where participants searched for sample code, but failed to find what they were looking for. Some participants found exam-
# Computers & Security 80 (2019) 54–73
Q - Observed in the questionnaire response. V - Observed in the screen recording.

P4 mentioned in their think-aloud results: “They need simple examples of how I can use this”.

We also observed that participants experienced difficulties due to the lack of details exposed about the use of keystores and truststores, and due to the difficulty in accessing them. We observed in screen recordings that most of the resources that participants referred (including official JSSE reference guide (2017b)) have been presented with assuming that keystores and truststores for the client/server will be set outside the code, however, have not properly communicated it. Even though, participants did not report this in their questionnaire responses, we observed it in screen recordings and think aloud results. In think-aloud results, P4 mentioned that “Details about keystores and truststores were not written anywhere in the doc”. They tried to follow SSLSocket-Client.java that is available at JSSE reference guide (2017b), which did not mention anything about keystore or truststore and it made participants think that they do not have to do anything with truststores in the client. This misunderstanding made them to spend more time to figure out that they need to specify the keystore and the truststore that the client and the server have to use. Furthermore, participants mentioned in both questionnaire responses and think-aloud results that it was difficult to find details about keystores that are required to use the API and how to connect to them from Java code. P10 mentioned in his questionnaire response that “How to use keystores was difficult to find. Most websites demonstrate the use of keytool, which did not help. I had to figure out how to use keystores from external sources and sample codes”.

Moreover, participants experienced issues due to the less informativeness in the error messages returned by the API. P9 described an issue they faced because of this in their response to the questionnaire. They described “API gave an invalid handshake error when I used API incorrectly. It should be more specific. I like error messages that tell exactly what is wrong and why”. We identified this issue while observing screen recordings and think aloud results as well. Both P3 and P4 received NoSuchAlgorithmException when they used a wrong password for the keystore file. They could not identify the root cause for the error they got by just looking at the initial part of the exception, but had to follow complete stack trace to identify the cause. We observed many other exceptions and error messages such as “SSLHandshakeException: Received fatal_alert: handshake_failure”, “SSLHandhshakeException: no cipher suites in common”, “SunCertPathBuilderException” and “ValidatorException” where participants failed to get an idea about what has really gone wrong. Appendix F shows a complete list of exceptions encountered by participants and how they reacted to them.

# 5. Role expressiveness of JSSE API
Role expressiveness describes “how apparent the relationship is between each component exposed by an API and the program as a whole.” . This is mainly associated with how easy it is to tell what a code that uses the API does, from reading the code. Furthermore, it discusses whether or not class/interface names and exceptions are self-explanatory.