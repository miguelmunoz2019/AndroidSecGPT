Other types of security weaknesses that are less diffused but still relevant in the context of controlling resources are: CWE-178: Improper Handling of Case Sensitivity (12 cases) and CWE-665: Improper Initialization (13). The complete dataset of labeled weaknesses is available in the replication package (Mazuera-Rozo et al., 2021).

(2) Improper Adherence to Coding Standards (98 instances - 24%). This category frames security weaknesses present in software due to ignored development best practices. The most represented sub-category for both programming languages is CWE-1164: Irrelevant Code, with 18 Java and 19 Kotlin instances. This category is related, for example, to the presence of dead code in the apps (i.e., code that is not executed in any of the app’s features). Such code, while not executed in the normal app’s usage, can still be unintentionally invoked/tested by software developers, or even exploited and executed by an attacker. The execution of dead code can be particularly dangerous since it is often not maintained with the latest security-related updates.

A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al. The Journal of Systems & Software 187 (2022) 111233
Notice that for both investigated languages, dead code is not removed from the APK (i.e., the compiled app) after compilation. Besides being possibly exploited, dead code can “come back to life” by mistake, thus leading to unexpected consequences. For example, the implementation of a new feature can by mistake be invoking an old (dead) implementation of a method accessing the database, leading to a loss of information when the app is deployed. In addition, dead code “might indirectly make it easier to introduce security-relevant weaknesses or make them more difficult to detect” When dead code is identified, two strategies are usually adopted by developers to remove it : (i) adding an explanatory comment before the dead fragment in question in which the developer mentions that the fragment it is or could be dead; and (ii) commenting out the code, leaving it available for future usage. The latter strategy is the one that has been applied in one of the fixing commits we inspected. The developer is commenting out dead code that seems to be related to the management of contacts in the database. Two days before this commit, the same developer added a comment on top of the dead code saying //TODO: what is this for again? (see changes to file MVP_Activity_Contacts in commit f0801d88).

The prevalence of CWE-561: Dead Code weaknesses in our fuzzers that work at source-code level for Kotlin nor Dart/Flutter taxonomy confirms the importance for researchers to investigate approaches able to automatically identify code components that can be removed without ripple effects on the code functionalities. To the best of our knowledge, very few tools are available for this task such as the one by Romano et al. (2020), the Android Lint tool , and the Kotlin DCE plugin.

Another well-represented subcategory is CWE-248: Uncaught Exception, that may cause the program to crash and/or expose sensitive information. Uncaught exceptions are a well-known issue in Android apps, especially when apps strongly rely on Android abstractions (e.g., activities, asynctasks, etc.) . The prevalence of this type of weakness in our taxonomy supports previous findings reported in the literature, and highlights the potential usefulness for developers of tools developed in academia to automatically test Android apps using systematic input generation (see e.g., Liñán et al., 2018; Li et al., 2017).

# (4) Protection Mechanism Failure (59 instances - 14%)
These security weaknesses are related to the incorrect restriction of access to a resource from an unauthorized actor. Thus, an attacker can compromise the security of the app by gaining privileges, accessing sensitive information, etc. Most of the weaknesses in this category are related to CWE-287: Improper Authentication. Fig. 5 shows an example of this type of security weakness, in which the developer fixes a security bug due to the missing authentication step in a feature requiring the user to have a valid authorization.

# (3) Improper Check or Handling of Exceptional Conditions (84 instances - 21%)
This category includes weaknesses that can lead to unpredictable behavior due to the improper or missing handling of exceptional conditions rarely occurring during the normal operation of the app. Within this category, the most represented type of security weakness is CWE-707: Improper Neutralization, happening when messages and/or data are not properly checked to be well-formed, valid, or benign (i.e., the exceptional condition of malformed messages/data is not properly handled). This category is mostly composed by cases related to CWE-20: Improper Input Validation (e.g., issues related to the improper validation of the password in a login form, such as commit 4875515b in the ccomeaux/boardgamegeek4android app, which could lead to a future credential management error).

This type of issues can be addressed by relying on dynamic analysis, and in particular on fuzz testing, which aims at feeding unexpected input data that may generate crashes, exploit security weaknesses, or induce unexpected states in the app. Several tools for this scope exist nowadays (Arzt et al., 2014; Google, 2019c; Ye et al., 2013; Huang et al., 2019; Cai and Jenkins, 2018; Fang et al., 2015; Nilizadeh et al., 2019), thus giving to practitioners a vast repertory of available options that can be adopted for their testing activities.

However, these tools work on Java and to the best of our knowledge, there are neither proposals of use of hard-coded credentials, such as commit f92221f from the UserLAnd app
12 https://cwe.mitre.org/data/definitions/561.html.

13 https://github.com/CypherpunkArmory/UserLAnd/commit/f92221f.

# A. Mazuera-Rozo, C. Escobar-Velásquez, J. Espitia-Acero et al.

# The Journal of Systems & Software 187 (2022) 111233
# 3. Java vs. Kotlin
This section compares the distribution of security weaknesses we observed in Java and Kotlin code. We focus on second-level categories (i.e., the direct child nodes of the root categories). We do not consider in this discussion categories in which there are less than ten overall instances when summing up the weaknesses for Java and Kotlin. Indeed, whatever observation made for these categories may be due to the low number of instances in the category. Also, it is worth noting that our goal is simply to highlight the differences we found in our taxonomy. Indeed, explaining the reasons for the observed differences without best-guessing is not possible with the available empirical data. A different experimental design targeting this RQ is needed to properly answer it.

We found a balanced distribution of Kotlin/Java instances among most of the subcategories. In particular, no major differences are observed in the subtree related to CWE-710: Improper Adherence to Coding Standards. Instead, when moving to the CWE-664: Improper Control of a Resource Through its Lifetime subtree, we observe a slight prevalence of Kotlin-related security weaknesses. This is mostly due to more issues related to improper thread synchronization and handling of case sensitivity (i.e., the code does not properly handle differences in case sensitivity, possibly leading to inconsistent results).

Concerning the CWE-703: Improper Check or Handling of Exceptional Conditions tree, the main category exhibiting differences.

# 3. Survey with Developers
Our taxonomy has been validated/complemented through the survey we performed with software developers. In the developers’ answers to Q8 and Q9 (see Table 1), we found mentions to 87 software security weaknesses, that can be classified into the 28 types labeled with a gray number (i.e., the number of developers who mentioned that security weakness type) in Fig. 2. Out of these, 22 were already part of our taxonomy as output of the mining-based study, while six were added: CWE-269: Improper Privilege Management, CWE-325: Missing Required Cryptographic Step, CWE-625: Permissive Regular Expression, CWE-1104: Use of Unmaintained Third Party Components, Hijacking, and Missing Code Obfuscation. The fact that 78% of the security weakness types mentioned by developers (22/28) were already part of our taxonomy, provides a good level of confidence about its comprehensiveness.

The most common security weaknesses (Q8) mentioned by the surveyed developers can be easily seen in Fig. 2, with those belonging to the CWE-693: Protection Mechanism Failure and CWE-664: Improper Control of a Resource Through its Lifetime trees representing 81% of the mentioned security weaknesses (71/87). There is a common thread we found when analyzing the answers provided to Q9, meaning the most dangerous weaknesses perceived by developers. All developers are mostly worried about unauthorized access to sensitive, private data stored in the app or sent/received through/by it. Some of the (shortened) answers: ‘vulnerabilities related to confidentiality, since they can expose user information’, ‘wrong/missing encryption of data being stored within the app’, ‘the leak of user personal information’.

Answers to Q9 confirm the importance of research studying security weaknesses related to data stored/manipulated by the apps (Arzt et al., 2014; Bello-Jiménez et al., 2019; Zhang et al., 2013).

An orthogonal view about the harmfulness of security weaknesses as perceived by developers is given by the answers to Q6 (i.e., the factors impacting the likelihood of a security weakness to be exploited) and Q7 (i.e., the factors impacting the harmfulness of the security weakness if exploited).