# 5 RQ5: Vulnerability Lifetime
Vulnerability lifetime means the time difference between the introduction of vulnerability in the code and when the vulnerability is eventually patched . It is difficult to find an actual patching time for Android vulnerabilities, i.e., when Google releases the security patches for a vulnerability. For this reason, the published time of a security bulletin gives the upper bound for when a patch is released; and we consider this as the patching date. In order to calculate the introduction time of a vulnerability in the code, we use an algorithm called SZZ . The general idea behind the SZZ algorithm is to identify the changed lines for fixing a bug and then identify when these lines were added for the first time. By doing so, first, we manually clone all the AOSP Git repository branches being used for patching the vulnerabilities.

After cloning the branches, for each reference, we take the commit ID. With this commit ID, we issue the command diff  under the corresponding branch in order to detect which lines are changed from the previous revision to last revision. Since the algorithm relies on only the line deletions, we have to find when these deleted lines were added in the first place. Hence, we use the command annotate on the previous revision for each changed file where the changes were made . Following this process, we can find the first time when the lines were added to the code. Note that there can be
more than one deleted line. Furthermore, it is possible that each deleted line is added at different times. As a result, we use the terms maximum lifetime and minimum lifetime for better understanding of this time interval. These terms are in agreement with the original SZZ paper . The maximum lifetime shows the time interval between the line addition time of the first deleted line and the time of publishing the vulnerability patch on the security bulletin. On the other hand, the minimum lifetime is the time interval between the line addition time of the last deleted line and the time of publishing the vulnerability patch on the security bulletin.

As mentioned before, this algorithm only checks the deleted lines. As a result, it excludes the cases where only additions are made. To identify that, a static code analysis must be done which is not the focus of this work. Besides, we also exclude the patched vulnerability that do not have any references. After excluding all of them, we have 549 patched vulnerabilities for which we are able to identify the maximum and minimum lifetimes. Among them, we notice 133, 300, 112, and 4 patched vulnerabilities with critical, high, moderate, and low severity levels, respectively. The result of our analysis for both maximum lifetime and minimum lifetime is represented in Figure 12.

As we see in Figure 12, both minimum and maximum patched vulnerability lifetimes are very high. In particular, there are patched vulnerabilities with high and low severity levels that have a maximum vulnerability lifetime of more than 6000 days, which is longer than the lifetime of Android. The reason is that the algorithm also checks files and lines that might be irrelevant for the vulnerability like a log, build files and even comments. For instance, if the fix-commit includes a comment deletion, then the algorithm takes this into consideration. Therefore, the above outcomes can occur, for example, when a build file or log file has not been changed for 7-8 years and then has been changed in the last fix-commit. Further, since this issue might also happen on external branches that have older commit histories than Android AOSP, we can observe these outliers. In general, the minimum patched vulnerability lifetimes fluctuate between 300 and 800 days, which is still high. On the contrary, the maximum vulnerability lifetimes vary from 700 to 2200 days (including the aforementioned outliers).

In order to see whether these data are statistically different, we perform a Mann Whitney U test for all minimum and maximum vulnerability lifetime data with each other. In other words, each minimum/maximum vulnerability lifetime set is compared to another dataset of a minimum/maximum vulnerability lifetime with different severity levels. Our null hypothesis, HO, is that all minimum/maximum vulnerability lifetime datasets are equally distributed. Table 15 and Table 16 depict the p-values of the Mann-Whitney U tests.

According to the results, the p-values of all pairs are larger than the significant level, i.e., p = 0. This means that the null hypothesis cannot be rejected. In other words, there are no statistical differences between the datasets.

# 6 Discussion
We believe that our work represents important steps in understanding the security practices in the Android ecosystem, as well as its likely impact on users. We now present the emerging themes and practical security policy recommendations based on our study.

# 6 Comprehensive Security Bulletins
The first commercialized version of Android was released on September 23, 2008. Since then, Google has released 63 different AOSP versions with 28 API levels . Due to the openness of the platform, Android has been adopted by different vendors, like Samsung, LG, etc., which results in the
# Minimum and Maximum Lifetime of Vulnerabilities by Severity Ranking
# Critical
# High
# Moderate
# Low
# Minimum Lifetime
The highest market share among mobile phone devices. Considering the large and widespread use of Android devices and their impact on human lives, it is vital to keep Android devices secure over time. Because of that, Google provides monthly security patch updates to fix security vulnerabilities. Based on data from the CVEDetails website , the Android-related CVEs existed back in 2009. However, Google started its Android security bulletins only in August 2015. Subsequently, also some vendors began releasing their own security bulletins. For instance, Samsung started in October 2015 and LG started in May 2016.

According to the CVEDetails website, there are 2,146 Android-related vulnerabilities by the end of 2018. However, the recorded number of Android-related vulnerabilities from 2009 to the end of 2014 is only equal to 43 . That means, from 2015 (start of Android security bulletins), the number of Android CVEs has increased drastically. Therefore, it seems that releasing Android security bulletins has certainly provided better knowledge about Android security. In contrast, we do not have too much information about the early days of Android (2008) until 2015. From a research perspective, it would be useful if Google starts adding also security bulletins that belong to the time before August 2015 to enable a comprehensive overview of security patches from the introduction of Android to the present day.

# 6 Coherent Security Platforms
There are many different platforms providing detailed information of CVEs, like CVEDetails , MITRE  and the National Vulnerability Database (NVD) . These three are general purpose databases and are not limited to one vendor or platform. Therefore, we can potentially find any vendor-related as well as Android-related vulnerabilities on them. In this paper, we use CVEDetails and Android security bulletins to investigate Android patched vulnerabilities. The expectation is that all of these publicly available platforms should be consistent with each other; and that there are no contradictions. In other words, only checking one of them should be sufficient for the majority of problems.

However, based on our results in Section 5, we notice inconsistencies between the Android security bulletins and CVEDetails. These inconsistencies included but are not limited to different information regarding updated and affected AOSP versions, and unknown CVE IDs on the CVEDetails website. Due to these inconsistencies, for example, if a person only relies on CVEDetails, s/he might miss some of the Android-related vulnerabilities on Android security bulletins considering that they are unknown in CVEDetails. Furthermore, Google provides updated versions while CVEDetails provide affected versions. In some cases, these two seem to systematically differ from each other. As a result, an observer cannot rely on only one of them. We believe it is essential that different publicly available websites that explain the vulnerabilities in detail should strive to be consistent with each other. Consistency would help security practitioners to find reliable information easily and they would not have to check different resources.

# 6 User-Centric Security Policy and Security after End-Of-Life (EOL)
Each vendor stops providing software updates after some period of time. Microsoft clearly states the end of support for its Windows operating systems . For example, for Windows 7, the end of mainstream support was January 13, 2015, and the end of extended support is January 14, 2020. Microsoft provides the exact date of support clearly on their website. Unlike Microsoft, Google does not mention these dates exactly ; however, clearly announcing such a schedule would be a desirable practice for developers that work within the Android ecosystem as well as consumers.