1 private Camera connectToCamera(int checkInterval, int maxTimeout) {
2     long start = System.currentTimeMillis();
3     if (this.useCamera) {
4         do {
5             try { return Camera.open(); }
6             catch (RuntimeException e) {...}
7         } while (System.currentTimeMillis() - start < maxTimeout);
8     }
9     return null;
10 }
We observe that no filter mechanism is mentioned in TRIGGER SCOPE’s paper. We contacted the authors, but we could not get the information on whether a filter was used or not in their implementation. According to our results, to reach such a low rate of false-positives (0%), at least a library filter has to be used to rule out repeated false-positives.

The reader may have noticed the structure of the previous logic bombs, i.e., nested conditions. It raises the question of whether this type of structure is often used in trigger-based behavior. Also, we want to verify if considering nested conditions could have been treated as a single logic bomb by TRIGGER SCOPE developers. Therefore, it could explain the gap between our results and theirs. We measured this and found that only 16% of detected triggers have a nested structure. According to this number, we can conclude that it does not impact the conclusion when comparing T RIGGER S COPE and TSOPEN.

We were able to construct a dataset with the same properties as the one used in the original paper. However, TSOPEN yielded a high false-positive rate by detecting 3099 potential apps with logic bombs (>27%). We see the importance of having the original list for reproducing this experiment as it can significantly impact the false-positive rate. Therefore, with the information that has been provided to us and the description of the approach made in the original paper, we conclude that the approach might be used in a realistic setting to detect logic bombs.

The values in parenthesis represent T RIGGER SCOPE ’s results for the original dataset. (SC: Suspicious Checks, STB: Suspicious Triggered Behavior, PF: Post-Filters).

#sms/#body.matches(”health”) which represents a suspicious narrow check against the body of an incoming SMS. It is triggered if the time-bomb is satisfied, meaning at a specific date, here the May, 21st 2011. It triggers the deletion of data through the content resolver. This implies that our implementation is not entirely identical to the original. We do not claim that this additional finding makes our implementation more precise because it may introduce more false-positives in other applications.

Finally, regarding the ”Zitmo” and ”RCSAndroid” malicious applications they provided us, TSOPEN was able to extract the same logic bombs as T RIGGER S COPE.

# 5 LIMITATIONS
Trigger Types. Only three trigger types have been modeled, which is not representative of logic bombs, though expanding it to other types would be easy. Regarding other types of logic bombs, we recently found that a new banking Trojan named "Cerberus" made smart use of the accelerometer sensor for monitoring the device . Indeed, it is based on the assumption that a real person would move with its device, hence changing the step counter’s values. Only if this condition is satisfied would the malicious code be triggered.

In a recent analysis, Stone found a malicious application using multiple evading techniques . The malware will first check if the device has a Bluetooth adapter and a name, which is important as emulators use default names. Then it would check if the device has a sensor and verify the content of /proc/cpuinfo to find both intel and amd strings. As most devices use ARM processors, those strings should not appear. It also checks the appearance of any Bluestacks files, which is an emulator solution and other emulation detections. Finally, this application would deliberately throw an exception and check the content to find any matching string that would show an emulator’s existence.

Predicate Minimization. The next limitation lies in the fact that predicate recovery and predicate minimization are performed systematically, which increases the probability of running into a complicated formula for which the minimization step would never end. Besides, this step is responsible for 22% of the analysis time and responsible, in 35% of the cases, for reaching the timeout of the analysis. Unlike the symbolic execution step, which is responsible for the largest part of an application’s analysis time (61%), the path predicate recovery and minimization are not necessary for the entire application. Indeed, the symbolic execution phase is necessary to decide on the suspiciousness of conditions. A countermeasure would be to locate interesting checks and then perform the full path predicate recovery and minimization.

Maliciousness. The most critical weakness of T RIGGER S COPE approach is the control dependency step, which compares method calls dominated by suspicious triggers with a list of sensitives methods. This phase requires more attention as it is used to qualify the maliciousness of a condition. Indeed, a suspicious check can be harmless due to the same usage benign and malicious applications make of trigger-based behavior. Nevertheless, we recognize the difficulty of this step, given the lack of a formal definition of malware. Despite having considerable resources, major companies also realize the difficulty to automatically qualify malicious code, e.g., Google still accepts malicious applications in its PlayStore.

Implementation Errors. Even though we reproduced faithfully the approach described in TRIGGER S COPE paper and reused available and well-tested state-of-the-art code when possible, we are not immune from implementation errors.

Implementation Unknowns. Given the details in the original paper, we are not able to reproduce the results. Therefore, we tried to vary parameters and implementation details to get as close as T RIGGER S COPE’s results. However, it is challenging to test all the combinations of implementation/parameters to get the original results.

# 6 R ELATED W ORK
In 2008, Brumley & al.  developed M INES WEEPER which is an interesting approach to assist an analyst. Their solution worked directly at the binary level of an executable application. Their goal was to uncover trigger-based behavior by constructing conditional paths and input values to execute the application. The next step was to ask a solver whether the path is feasible or not. If not, they would not explore this path. On the contrary, they would explore this path and ask the solver to construct -if possible- input values to satisfy the formula. They would then execute the application with the computed trigger input values to inspect the behavior, and if a malicious behavior were encountered, they would know the conditional path leading to this behavior, thus detecting if a logic bomb exists. They conducted their experiments on four real-world applications and succeeded in finding trigger-based behavior in less than 30 minutes per application with less than 14 potential logic bombs per application. Unlike TSOPEN, the process is not entirely static nor fully automatic and requires a human to infer the logic bomb.

Four years later, Zheng & al.  focused on finding a user interface-based trigger that could be used to hide malicious code to traditional analysis in Android applications. They construct what they call the FCG (Function Call Graph) to retrieve call paths to sensitive Android APIs. The next step is constructing what they call the ACG (Activity Call Graph) to have the relationship between the application activities, i.e., how to go from one activity to another via user interface methods. Having those details, they run the application by triggering user interface elements to go to the sensitive activity, which calls a sensitive API and monitors the behavior to check if anything suspicious happens. That way, they can deduce if the user interface triggering process is used to trigger malicious code. Their approach is not generic and focuses on one single type of logic bomb. Also, we note the use of dynamic analysis of their approach again.

Pan & al.  presented a new machine-learning based technique to detect Hidden Sensitive Operations in Android apps. They do not specifically focus on malicious behavior contrary to T RIGGER S COPE’s approach, which targets malicious activities. Their approach is composed of a pre-processing part where lightweight data-flow and control-flow analysis are performed to extract a condition-path graph. This latter is then used to extract features that will feed the SVM classification. Doing so, HSOM INER performs a precision of 98% (based on 125 randomly chosen apps from a set of 63372) and a recall of 94%. Though the approach is interesting (SVM is resistant to overfitting), it does not fit the goal of detecting logic bombs hidden in Android apps.