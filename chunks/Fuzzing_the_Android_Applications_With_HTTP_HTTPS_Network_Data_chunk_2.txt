Regarding device information inference, Malik et al.  used time interval of messages generated by mobile devices to infer operating systems running on devices, successfully distinguished between Android, iOS and Windows Phone. Application information inference includes application identification and malicious application detection. SAMPLES  is an adaptive application identification framework that abstracts the appearance pattern of application identifiers in HTTP traffic into a set of text rules containing HTTP fields, prefixes, and suffix strings of application identifiers. AppScanner  extracts 54 statistical features from receiving data, sending data, and bidirectional network flows, trains random forest classifiers to identify applications on networks, and evaluates the impact of several factors on detection rate. In the field of private information leakage detection, the method proposed by Continella et al.  utilizes black box difference analysis technology. They used
# X. Huang et al.: Fuzzing the Android Applications With HTTP/HTTPS Network Data
differential analysis to detect data changes in corresponding network traffic after the PII (Personally identifiable information) data changed, to detect leaked PII information (even if it has been encrypted or confused).

# III. FUZZING APPS WITH MUTATED NETWORK DATA
In this section, the main principle and processing flow of the proposed fuzzing method are summarized in Section A, the method is described in detail in Section B. Before explaining how to achieve the repeatability of fuzzing, we first introduce the determination of fuzzing objects and the specific content of the general fuzzing strategies.

# A. OVERVIEW
In order to implement fuzzing on HTTP/HTTPS response data received by an Android application, we need to operate the application to trigger various network operations. The server generates and returns corresponding response data after receiving HTTP/HTTPS requests sent by the application. The method first intercepts response data by means of a middleman agent, mutates the data, then returns it to the application to test its ability on processing response data beyond expectations. The specific processing flow of the method is shown in Fig.

Scope and Assumptions: The Fuzzing method proposed in this paper focuses on testing Android applications using the HTTP/HTTPS protocol. For HTTPS, the content is encrypted, we use Fiddler (a free web debugging proxy)  to capture and decrypt the network data of applications, mutate the successfully decrypted plaintext data. The scheme mutates packets to discover the following security risks in applications: whether the HTTP/HTTPS response data are validated, whether there is a correct handling mechanism for various malformed data. Currently, the communication channel between the target application and the middleman agent is Wi-Fi, in the future our framework could be extended to other channels with some additional efforts.

# B. FUZZING
# 1) FUZZING OBJECTS
The input data of Android applications, which may cause security issues, can be divided into the following three categories.

VOLUME 7, 2019
59953
# X. Huang et al.: Fuzzing the Android Applications With HTTP/HTTPS Network Data
(The test objects listed in this table are the common response data fields of HTTP and HTTPS. We do not study HTTPS’ different fields from HTTP.)
(We selected response data belonging to 2XX and 3XX as test objects, which covered a large part of the response data of an application.)
1. Users’ operations.

2. Files with various formats.

3. Various data from network packets.

Research in this paper focuses on HTTP/HTTPS response data from servers. Android applications receive numerous response data, but some of them have no meaning for testing. According to the specific structure of HTTP response data (status line, response header, blank line, response body), we studied and determined appropriate test objects. Finalized test objects are organized in Table 1.

Response data containing informational status code 1XX (indicating that the server is processing requests) and error status code 4XX/5XX do not have an additional impact on the operation of Android applications (they will only perform simple judgment on such response data). Therefore, we limited test objects to response data containing success status code 2XX (indicating that the server has processed requests and returned data) and redirect status code 3XX (requires applications to perform additional operations to complete requests).

As shown in Table 2, when operating an application, 97% of the response packets belong to returned data after successful processing, and 0% are redirected data. For the former, we focused on the response body specified by response headers “Content-Type” and “Content-Length”. For the latter, we focused on the data containing the response header “Location”. The “Location” header contains the redirect URL. If there is no legality judgment on this field, attackers may induce the application to access malicious address by replacing the URL. We finally determined test objects as follows.

1. The response data with status code 2XX and “Content-Length” not equaling 0.

2. The response data with status code 3XX and containing “Location” in the response header.

# 2) FUZZING STRATEGIES
Considering the significant differences on the structure and content of network data between different applications, we summarized the general processing procedures and methods used by Android applications on network data, formulated specific strategies based on these methods, to develop suitable general fuzzing strategies.

Nowadays, general processing methods on network data are as follows.

1. Content display, applications display content such as HTML and image in response packets.

2. Download file resources, some response data contain links pointing to the data required by applications, the application will open the links to download required data.

3. Control the execution flow of applications, the response data in JSON format returned by the server have data that may affect the execution flow of an application, the application executes different code according to different data.

In previous test, we captured the response data by running applications (com.ifeng.newvideo, com.culiukeji.huanletao) and counted the proportion of each type. We noticed that JSON data widely existed in various response data. Since JSON data have a key-value pair format of {key:value}, we extracted key-value pairs from the response data, mutated the value of common data type (int, float, boolean, string, null) by adopting the following heuristic mutation rules.

1. Changing the length and content of strings for stack-based or heap-based overflow and out-of-bound access. In our implementation, the original strings are replaced by random strings of the same length or appended with a variable number of special characters such as “//”, “ ”, to construct malformed messages.

2. Changing the integer or float values for integer overflow and out-of-bound access. We mutated the original values into boundary cases and large values. Also, to trigger the cases of miscounting of boundary conditions, we also generate the off-by-one values.

3. Changing the types, or providing empty values for uninitialized variable vulnerability.

For the other data with higher frequency (image, HTML, etc.) shown in Fig, we referred to the idea of file-based fuzzing, generated a large number of test cases in advance using corresponding open source fuzzing tools (zzuf , domato ).

The general fuzzing strategy is finally formulated as shown in Fig. After intercepting the response data from the server, the status code is first obtained. If the code is outside the range (2XX/3XX), no further processing will be performed. Response data with status code of 2XX/3XX will be mutated according to the following strategies.

1. When status code is 302, get the value of “Location” field in response header, replace it with other URLs (such as Baidu, Google).

# X. Huang et al.: Fuzzing the Android Applications With HTTP/HTTPS Network Data
different pages.) that could trigger the same processing code (e.g. image parsing code in the application) repeatedly. Therefore, multiple response data of the same type (e.g. images) received during the execution of the same application can be regarded as effective carriers of the same type of mutated test cases. This partially achieves the repetitiveness of fuzzing. Specifically, for each response data whose transmission content is image/HTML, the original content is replaced by different samples generated before. For data of JSON format, since different contents could have different impacts on execution of the application, the action script of the application is recorded with the command line tool replaykit , which provides the ability to record touchscreen events from one device, to ensure the same execution flow each time. Multiple recurring executions of script implement repeated testing.

(We selected image, JSON, HTML, javascript, which has the highest proportion in the figure, as test objects. For plain and octet-stream, we only considered the plaintext JSON data.)
# 2) When status code is 2XX/3XX
get the value of ‘‘Content-Type’’ field in response header, if it is in the range (text/html, image/gif/jpeg/png/icon/webp, text/javascript, application/json) and the value of ‘‘Content-length’’ field is not 0, according to test rules of each type, the content in response body is mutated and replaced, and then sent to the application.