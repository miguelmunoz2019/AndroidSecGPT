Even though with a different purpose, these works proposed an approach similar to ours. They identified specific patterns and exploited static analysis to detect them in Android apps. However, other works specifically targeted the adoption of protections against malicious reverse engineering in Android apps, either to assess their implementation rate or to conduct derivative studies.

# 7. Large-scale study on the adoption of protections in android apps
Wermke et al.  investigated the extent to which Obfuscation is used in Android apps. They exploited static analysis considering identifiers like package names, classes, methods and fields. They aimed at detecting Obfuscation by Proguard They tested their algorithm on manually protected open source apps from F-Droid Finally, they launched a large-scale analysis on more than a million Android apps from the Google Play store, finding that only 24% of apps are obfuscated by the developers. Kaur et al.  tackled the task of Obfuscation identification from a different and novel approach, exploiting spatial analysis. This technique investigates patterns present in images calculated directly from binary files. The authors created grey-scale images from Android APKs and then calculated first- and second-order statistics like the Shannon Entropy and Chi-Square. They were able to achieve a significant accuracy (nearly 90%) in fingerprinting Obfuscation tools together with their configuration. Wang Yan et al.  exploited Machine Learning techniques to study and classify Obfuscation in Android apps. Their purpose was to distinguish whether an app is obfuscated or not and what tool the developers employed. They employed several tools to create different obfuscated versions of open-source apps downloaded from the F-Droid repository. After defining and tuning their classifiers, they performed a Large-Scale analysis of Google Play apps to study the percentage of obfuscated apps and the most frequent tools. They managed to identify the configuration of the tools with more than 90% accuracy. Wang Pei et al.  studied the deployment of Obfuscation techniques on the Apple Store apps. Their purpose was to discover to what extent iOS developers employ this protection. For each app, they assessed the amount of protected code discerning third-party libraries. Eventually, they tested the resilience of the Obfuscation techniques on a set of apps. Despite an increasing trend of the usage of such protection, they found that many apps are still vulnerable to low-effort reverse engineering.

The literature presents several studies on protections against malicious reverse engineering and large-scale studies on Android apps. As we discussed, many researchers proposed an approach similar to ours. First, they identified peculiar patterns, analogue to our protection atoms. Then, they tuned the patterns on toy apps. Once automatized the process, they started a large-scale study on apps. However, regarding protections against attackers, all of these studies focused on Obfuscation identification only. They did not consider other kinds of protections against malicious reverse engineering. To the best of our knowledge, we are the first to assess the adoption rate of AD and AT protections in Android apps.

# 8. Future work
Several interesting areas can be investigated to enhance the large-scale analysis we presented:
- ATADetector does not consider the context in the detection of the protections. It identifies each protection atom separately and then it consults the fingerprint. Instead, it would be interesting to introduce a context in the extraction of protection atoms. We could track a particular protection atom to see when and how the developers used it. For instance, we could check whether the package name of an app store and the value returned by the getinstallerpackagename API are the parameters of a .equals method. In this way, we would obtain very accurate detections by removing many false positives.

- Since not strictly related to AD or AT, we excluded some protections from our analysis, like the Root Detection protection. Indeed, this protection focuses on the status of the smartphone rather than on eventual tampering on the app. However, it would be interesting to investigate the adoption of.

13 https://www.guardsquare.com/en/products/proguard.

14 https://f-droid.org/.

# Detection of AD and AT Protections in Android Apps
This protection also. Similarly, there may be other protections worth considering.

- ATADetector detects the protections by identifying the protection atoms through static analysis. We chose to exploit static analysis since it was the natural automation process for our extraction of protection atoms. However, we can automatize the detection with other techniques and check whether they perform better or not. Indeed, there are different approaches for the actual implementation:
- Machine learning: The protection atoms we defined can work as features for training the model. The challenge is to produce a training set large enough to train the model.

- Dynamic analysis: This approach would overcome Reflection and String Encryption. However, an app could activate certain protections under certain particular conditions only. For instance, it could run AD protections after the login or AT protections when a free trial of eventual premium features expires. Therefore, it would be difficult to tell whether there are no protections or the analysis was not thorough enough.

- Spatial analysis: Kaur et al.  employed this interesting kind of analysis for Obfuscation detection in Android apps. However, we have to understand whether the protection atoms we are interested in are too small to be accurately detected in the generated images or not.

# 9. Conclusion
In this paper, we described the first large-scale study about the detection of AD and AT protections in Android apps. Our purpose is to understand the extent to which Android app developers employ these protections. We identified and described nine different protections against malicious reverse engineering. We collected example implementations and extracted peculiar protection atoms, both at Java and Native levels, producing and refining the fingerprints. We developed a tool, ATADetector, to automatize the detection task. Before launching the large-scale analysis, we tuned the fingerprints with three incremental validation steps to achieve more accurate detection rates. Finally, we analyzed 37,783 Android apps.

We defined five research questions and four metrics. We analyzed the percentage of protected apps by category and how frequent protections integrate each other. Then, we investigated whether the detected protections came from third-party libraries or not. We compared the ratio of protections implemented at Java and Native levels and then assessed the evolution of the adoption of the protections between 2015 and 2019.

At first, the results seemed to indicate that a high percentage of apps deploy AD and AT protections. Almost all apps implement AT protections and around two out of three implementing AD protections. Furthermore, an app contains 3 protections on average. However, we discovered that only 28% of all protections come from app developers, while the remaining derive from third-party libraries. Therefore, the vast majority of protections do not provide any defense against attacks to the logic of the app. We also found that the ratio between Java and Native level protections is of 99 to 1. This implies that developers implement almost all protections in Java that attackers can more easily reverse and bypass compared to Native protections. Furthermore, we observed that apps from 2019 generally employ more protections than apps from 2015.

Attackers analyze and tamper Android apps to unlock premium features, insert malware and redirect ads revenue. Even though it is not possible to definitively block malicious reverse engineering, app developers can hinder the process by securing the code through the use of AD and AT protections. Our findings show that Android apps are not as protected as they could be. This result is even more serious since we considered top-category apps.

The final reports and aggregated results can be found, together with ATADetector and other material, in our GitHub repository.

# Declaration of Competing Interests
The authors declare that they have no known competing financial interests or personal relationships that could have appeared to influence the work reported in this paper.

# Appendix A. Protections Implementation Collection
This appendix contains the example implementations for the protections we identified. First, we divide between AD and AT protections. Then, for each protection, we describe the implementation and report the Java and the Native code, when present. Additional information can be found in the related references.

# A1. AD Protections
- Emulator detection (Java implementation in Fig. A1, page 25): an app can obtain the properties of the smartphone in several ways. It can access the android.os.Properties class through Reflection  (lines 22-37 Java), query the Build class (lines 2-19 Java)  or execute the getprop command (lines 40-44 Java) , both at Java and at Native level. It can also check the presence of emulator related files  (lines 47-51 Java).