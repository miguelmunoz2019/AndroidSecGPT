# 6 Validity Threats
Validity is important for researchers and practitioners for empirically validating results of different approaches. The generalization of results for different groups and datasets is the key requirement from researchers and practitioners. External validity focuses on evaluating the generalization of results. The approach presented in this paper mitigates external validity threats as we performed experiments on 4 Android open source applications of different types and sizes for the evaluation of our approach. Moreover, we also evaluated our approach on 3 industrial applications of moderate size for the generalization of our results. We performed experiments on a large number of Android code bad smells as compared to previous approaches that are restricted to only a few Android code bad smells. However, we cannot assert that our results may produce same accuracy for other large and complex Android applications. We also accept that there might be a chance of errors during manual evaluation of false positives and false negatives from source code. To minimize this threat, both authors carefully cross-validated results. Internal validity is used to evaluate the effect of independent variables on dependent variables. The lack of standard and formal definitions, Android source code metrics and unavailability of standard benchmark systems for results of Android code bad smell detection techniques is a major
# Arabian Journal for Science and Engineering (2020) 45:3289–3315
# Bad smells/
# SAND
# AmazeFileManager
# Arabian Journal for Science and Engineering (2020) 45:3289–3315
MIM Member Ignoring Method, NLMR No Low Memory Resolver, IGS Internal Getter/Setter, IDFP Inefficient Data Format and Parser, IDS Inefficient Data Structure, LT Leaking Thread, SL Slow Loop PD DE RAM Rigid Alarm Manager, UC Unclosed Closable, LIC Leaking Inner Class DR Debuggable Release, SV Static Views, SC Static Context, SB Static Bitmap, CV Collection of Views, CB Collection of Bitmaps DD Dropped Data Unt Untouchable, UFO Uncontrolled Focus Order, NDUI Not Descriptive UI, NL Nested Layout, SCC Set Config Changes, OP Overdrawn Pixel
# 7 Conclusion and Future Work
The mobile applications expect high reliability and performance from end users as compared to desktop and web applications. The detection of code smells from Android applications is beneficial for refactoring, maintenance and evolution of mobile applications. A very few approaches are presented in the state of the art for detection of Android-specific code bad smells from mobile applications. The existing approaches are limited only to few Android code bad smells and they have issues of accuracy and flexibility. We present a flexible approach by integrating the concepts of source code analysis and source code metrics. The presented approach is validated with tool support to recover 25 Android code bad smells from 7 mobile Android applications. We evaluate our approach by performing experiments on 7 Android mobile applications and compare the recovered results with a representative state-of-the-art approach. We publish our results on the web as the first benchmark for researchers. The precision, recall and F-measure are the accuracy measures used for the validation of results. Currently, our prototyping tool is limited to Java programming language but the proposed approach is flexible and extendable for other programming languages. Due to lose specification of bad smells and their threshold values, the detection results may vary. There is a need for a comprehensive and standard benchmark for specifications of Android-specific code smells. We have a plan to extend our prototyping tool for other mobile application platforms like iPhone. Other mobile application languages like C#, Swift, Kotlin will be added.

# Arabian Journal for Science and Engineering (2020) 45:3289–3315
in order to detect bad smells. We also plan to extend our approach for correction of these Android bad smells.